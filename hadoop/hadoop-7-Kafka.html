<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Kafka | JavaChen Wiki</title>
    <meta name="description" content="JavaChen Wiki">
    <link rel="icon" href="/wiki/img/logo.ico">
  <meta http-quiv="pragma" cotent="no-cache">
  <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
  <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/wiki/assets/css/0.styles.bdf32acf.css" as="style"><link rel="preload" href="/wiki/assets/js/app.dd178f5a.js" as="script"><link rel="preload" href="/wiki/assets/js/2.9f273a62.js" as="script"><link rel="preload" href="/wiki/assets/js/26.59450304.js" as="script"><link rel="prefetch" href="/wiki/assets/js/10.e389070d.js"><link rel="prefetch" href="/wiki/assets/js/11.19e9f97f.js"><link rel="prefetch" href="/wiki/assets/js/12.f95e0459.js"><link rel="prefetch" href="/wiki/assets/js/13.127730fd.js"><link rel="prefetch" href="/wiki/assets/js/14.34eed2f7.js"><link rel="prefetch" href="/wiki/assets/js/15.a8cf4000.js"><link rel="prefetch" href="/wiki/assets/js/16.6346731c.js"><link rel="prefetch" href="/wiki/assets/js/17.143af375.js"><link rel="prefetch" href="/wiki/assets/js/18.7d95703a.js"><link rel="prefetch" href="/wiki/assets/js/19.8726bd0b.js"><link rel="prefetch" href="/wiki/assets/js/20.2914a04f.js"><link rel="prefetch" href="/wiki/assets/js/21.ebd751e0.js"><link rel="prefetch" href="/wiki/assets/js/22.f6801be0.js"><link rel="prefetch" href="/wiki/assets/js/23.87ecfe73.js"><link rel="prefetch" href="/wiki/assets/js/24.cabcaf93.js"><link rel="prefetch" href="/wiki/assets/js/25.306828f5.js"><link rel="prefetch" href="/wiki/assets/js/27.44fddb85.js"><link rel="prefetch" href="/wiki/assets/js/28.4e15bea1.js"><link rel="prefetch" href="/wiki/assets/js/29.bed7cbfd.js"><link rel="prefetch" href="/wiki/assets/js/3.28138f41.js"><link rel="prefetch" href="/wiki/assets/js/30.36a67cca.js"><link rel="prefetch" href="/wiki/assets/js/31.dde8666e.js"><link rel="prefetch" href="/wiki/assets/js/32.148ea73a.js"><link rel="prefetch" href="/wiki/assets/js/33.61c937cc.js"><link rel="prefetch" href="/wiki/assets/js/34.eb7c4b0c.js"><link rel="prefetch" href="/wiki/assets/js/35.abb4ce3d.js"><link rel="prefetch" href="/wiki/assets/js/36.f03d0378.js"><link rel="prefetch" href="/wiki/assets/js/37.84491176.js"><link rel="prefetch" href="/wiki/assets/js/38.2a06b872.js"><link rel="prefetch" href="/wiki/assets/js/39.63965d3b.js"><link rel="prefetch" href="/wiki/assets/js/4.c0af9872.js"><link rel="prefetch" href="/wiki/assets/js/40.bf2e354a.js"><link rel="prefetch" href="/wiki/assets/js/41.bed53451.js"><link rel="prefetch" href="/wiki/assets/js/42.34d4f2f5.js"><link rel="prefetch" href="/wiki/assets/js/43.867c0e23.js"><link rel="prefetch" href="/wiki/assets/js/44.0201a314.js"><link rel="prefetch" href="/wiki/assets/js/45.d6f1a311.js"><link rel="prefetch" href="/wiki/assets/js/46.419d44e4.js"><link rel="prefetch" href="/wiki/assets/js/47.a3f8b595.js"><link rel="prefetch" href="/wiki/assets/js/48.574cc219.js"><link rel="prefetch" href="/wiki/assets/js/49.224dd6c4.js"><link rel="prefetch" href="/wiki/assets/js/5.c521f8b1.js"><link rel="prefetch" href="/wiki/assets/js/50.c8825040.js"><link rel="prefetch" href="/wiki/assets/js/51.2dab614a.js"><link rel="prefetch" href="/wiki/assets/js/52.8382a180.js"><link rel="prefetch" href="/wiki/assets/js/53.bfab18a9.js"><link rel="prefetch" href="/wiki/assets/js/54.87a1d37c.js"><link rel="prefetch" href="/wiki/assets/js/55.5f207671.js"><link rel="prefetch" href="/wiki/assets/js/56.f0e8e082.js"><link rel="prefetch" href="/wiki/assets/js/57.c868e5c9.js"><link rel="prefetch" href="/wiki/assets/js/6.6a737c5b.js"><link rel="prefetch" href="/wiki/assets/js/7.48bba6b4.js"><link rel="prefetch" href="/wiki/assets/js/8.26532964.js"><link rel="prefetch" href="/wiki/assets/js/9.3c4a4032.js">
    <link rel="stylesheet" href="/wiki/assets/css/0.styles.bdf32acf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/wiki/" class="home-link router-link-active"><!----> <span class="site-name">JavaChen Wiki</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/wiki/" class="nav-link">主页</a></div><div class="nav-item"><a href="/wiki/docker/" class="nav-link">Docker</a></div><div class="nav-item"><a href="/wiki/elasticsearch/" class="nav-link">Elasticsearch</a></div><div class="nav-item"><a href="/wiki/hadoop/" class="nav-link router-link-active">Hadoop</a></div><div class="nav-item"><a href="/wiki/interview/" class="nav-link">Interview</a></div><div class="nav-item"><a href="/wiki/rabbitMQ/" class="nav-link">RabbitMQ</a></div><div class="nav-item"><a href="/wiki/redis/" class="nav-link">Redis</a></div><div class="nav-item"><a href="/wiki/spring-cloud-cshop/" class="nav-link">Spring-cloud-cshop</a></div><div class="nav-item"><a href="/wiki/about.html" class="nav-link">关于</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/wiki/" class="nav-link">主页</a></div><div class="nav-item"><a href="/wiki/docker/" class="nav-link">Docker</a></div><div class="nav-item"><a href="/wiki/elasticsearch/" class="nav-link">Elasticsearch</a></div><div class="nav-item"><a href="/wiki/hadoop/" class="nav-link router-link-active">Hadoop</a></div><div class="nav-item"><a href="/wiki/interview/" class="nav-link">Interview</a></div><div class="nav-item"><a href="/wiki/rabbitMQ/" class="nav-link">RabbitMQ</a></div><div class="nav-item"><a href="/wiki/redis/" class="nav-link">Redis</a></div><div class="nav-item"><a href="/wiki/spring-cloud-cshop/" class="nav-link">Spring-cloud-cshop</a></div><div class="nav-item"><a href="/wiki/about.html" class="nav-link">关于</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Hadoop</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/wiki/hadoop/" class="sidebar-link">大数据概论</a></li><li><a href="/wiki/hadoop/hadoop-2-Hadoop概述.html" class="sidebar-link">Hadoop</a></li><li><a href="/wiki/hadoop/hadoop-3-hdfs.html" class="sidebar-link">HDFS</a></li><li><a href="/wiki/hadoop/hadoop-4-MapReduce.html" class="sidebar-link">MapReduce</a></li><li><a href="/wiki/hadoop/hadoop-5-Yarn.html" class="sidebar-link">Yarn</a></li><li><a href="/wiki/hadoop/hadoop-6-Hive.html" class="sidebar-link">Hive</a></li><li><a href="/wiki/hadoop/hadoop-7-Kafka.html" class="active sidebar-link">Kafka</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/hadoop/hadoop-7-Kafka.html#kafka是什么" class="sidebar-link">kafka是什么</a></li><li class="sidebar-sub-header"><a href="/wiki/hadoop/hadoop-7-Kafka.html#实现原理" class="sidebar-link">实现原理</a></li><li class="sidebar-sub-header"><a href="/wiki/hadoop/hadoop-7-Kafka.html#为什么需要消息队列" class="sidebar-link">为什么需要消息队列</a></li><li class="sidebar-sub-header"><a href="/wiki/hadoop/hadoop-7-Kafka.html#kafka架构" class="sidebar-link">kafka架构</a></li><li class="sidebar-sub-header"><a href="/wiki/hadoop/hadoop-7-Kafka.html#分布式模型" class="sidebar-link">分布式模型</a></li><li class="sidebar-sub-header"><a href="/wiki/hadoop/hadoop-7-Kafka.html#操作" class="sidebar-link">操作</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="kafka"><a href="#kafka" aria-hidden="true" class="header-anchor">#</a> Kafka</h1> <h2 id="kafka是什么"><a href="#kafka是什么" aria-hidden="true" class="header-anchor">#</a> kafka是什么</h2> <p>在流式计算中，kafka一般用来缓存数据，storm通过消费kafka的数据进行计算。</p> <ul><li><p>Apache kafka是一个开源的消息系统，由scala写成，是由Apache软件基金会开发的一个开源消息系统项目。</p></li> <li><p>kafka最初始由Linkedin公司开发，并于2011年初开源。2012年10月从Apache incubator毕业。该项目的目标是为处理实时数据提供一个统一、高通量、低等待的平台。</p></li> <li><p>kafka是一个分布式消息队列。kafa对消息保存时根据Topic进行归类，发送消息者为Producer，消息接收者为Consumer，此外kafka集群有多个kafka实例组成，每个实例（server）称为broker。</p></li> <li><p>无论是kafa集群，还是producer和Consumer都依赖于zookeeper集群保存一些meta信息，来保证系统可用性。</p></li></ul> <h2 id="实现原理"><a href="#实现原理" aria-hidden="true" class="header-anchor">#</a> 实现原理</h2> <p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g5aapiqb0rj31sy0u0n6z.jpg" alt="img"></p> <p>1、点对点模式（一对一，消费者主动拉取数据，消息收到后消息清除）</p> <p>点对点模型通常是一个基于拉取或者轮询的消息传送模型，这种模型从队列中请求信息，而不是将消息推送到客户端。这个模型的特点是发送到队列的消息被一个且只有一个接收者接收处理，即使有多个消息监听者也是如此。</p> <p>2、发布/订阅模式（一对多，数据生产后，推送给所有订阅者）</p> <p>发布订阅模型则是一个基于推送的消息传送模型。发布订阅模型可以有多种不同的订阅者，临时订阅者只在主动监听主题时才接收消息，而持久订阅者则监听主题的所有消息，即使当前订阅者不可用，处于离线状态。</p> <h2 id="为什么需要消息队列"><a href="#为什么需要消息队列" aria-hidden="true" class="header-anchor">#</a> 为什么需要消息队列</h2> <h3 id="解耦"><a href="#解耦" aria-hidden="true" class="header-anchor">#</a> 解耦</h3> <p>允许独立的扩展或修改两边的处理过程，只要确保它们遵守统一的接口约束。</p> <h3 id="冗余"><a href="#冗余" aria-hidden="true" class="header-anchor">#</a> 冗余</h3> <p>消息队列把数据进行持久化直到他们已经完全处理，通过这一方式规避了数据丢失防线。许多消息队列采用的“插入-获取-删除”范式中，在把一个消息从消息队列中删除之前，需要处理系统明确的指出该消息已经被处理完毕，从而确保数据被安全的保存直到使用完毕。</p> <h3 id="扩展性"><a href="#扩展性" aria-hidden="true" class="header-anchor">#</a> 扩展性</h3> <p>因为消息队列解耦了处理过程，所以增大消息入队和处理频率是很容易的事情，只要另外增加处理过程即可。</p> <h3 id="灵活性和峰值处理能力"><a href="#灵活性和峰值处理能力" aria-hidden="true" class="header-anchor">#</a> 灵活性和峰值处理能力</h3> <p>在访问量剧增的情况下，应用仍然需要继续发挥作用，但只有的突发流量并不常见。如果为了处理这类峰值访问的标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关节组件顶住突发访问的压力，而不会因为突发的超负荷的请求而全面崩溃。</p> <h3 id="可恢复性"><a href="#可恢复性" aria-hidden="true" class="header-anchor">#</a> 可恢复性</h3> <p>体统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</p> <h3 id="顺序保证"><a href="#顺序保证" aria-hidden="true" class="header-anchor">#</a> 顺序保证</h3> <p>在大多数的场景下，数据处理的顺序都很重要。大部分消息队列本生就是排序的，并且保证数据会按照特定的顺序来处理。（kafka保证一个partition内部的消息的有序性）。</p> <h3 id="缓冲"><a href="#缓冲" aria-hidden="true" class="header-anchor">#</a> 缓冲</h3> <p>有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况。</p> <h3 id="异步通信"><a href="#异步通信" aria-hidden="true" class="header-anchor">#</a> 异步通信</h3> <p>有些时候，用户并不想立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p> <h2 id="kafka架构"><a href="#kafka架构" aria-hidden="true" class="header-anchor">#</a> kafka架构</h2> <p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5aapawg6pj31ib0r4186.jpg" alt="img"></p> <p>Producer：消息生产者，向kafka broker发消息的客户端。</p> <p>Consumer：消息消费者，想kafka broker获取消息的客户端。</p> <p>Topic：可以理解为队列</p> <p>Consumer Group（CG）：这是kafka用来实现一个topic消息的广播（发给所有的Consumer）和单播（发给任意一个Consumer）的手段。一个topic可以有多个CG。topic的消息会复制给Consumer。如果需要实现广播，只要每个Consumer有一个独立的CG就可以了。要实现单播只要所有的Consumer在同一个CG中。用CG还可以将Consumer进行自由的分组而不需要多次发送消息到不同的topic。</p> <p>Broker：一台kafka服务器就是一个broker。一个集群由多个broker组成。一个broker可以容纳多个topic。</p> <p>Partition：为了实现扩展性，一个非常大的topic可以分布到多个Broker（即服务器）上，一个topic可以分为多个Partition，每个partition是一个有序队列。Partition中的每条消息都会被分配一个有序的id（offset）。kafka只保证按一个partition中顺序将消息发给Consumer，不保证一个topic的整体（多个partition）的顺序。</p> <p>Offset：kafka的村塾文件都是按照offset.kafka来命名，用offset做名字的好处就是方便查找。比如想找到2049的位置，只要找到2048.kafka的文件即可。the first offset是 00000000000.kafka</p> <h2 id="分布式模型"><a href="#分布式模型" aria-hidden="true" class="header-anchor">#</a> 分布式模型</h2> <p>Kafka每个主题（Topic）的多个分区日志分布式存储在Kafka集群上，同时为了故障容错，每个分区都会以副本的方式复制到多个消息代理节点上。其中一个节点会作为主副本（leader），其他节点作为备份副本（Follower，备份副本）。主副本会负责所有客户端读写操作，备份副本仅仅从主副本同步数据。当主副本出现故障时，备份副本中的一个副本会被选择为新的主副本。因为每个分区的副本只有一个主副本接收读写，所以每个服务器都会作为某些分区的主副本，以及另外一些分区的备份副本，这样kafka集群的所有服务端整体上对客户端是负载均衡的。</p> <p>kafka的生产者和消费者相对于服务器端而言都是客户端。</p> <p>kafka生产者客户端发布消息到服务端的指定主题，会指定消息所属的分区。生产者发布消息时根据消息是否有键，来采取不同的分区策略。消息没有键时，通过轮询方式进行客户端负载均衡；消息有键时，根据分区语义保证相同键的消息总是发送到同一个分区。</p> <p>Kafka的消费者通过订阅主题来消费消息，并且每个消费者都会设置一个消费组名称。因为生产者发布到主题的每一条消息都只会发送给消费者组的一个消费者。所以，如果要实现传统消息系统的“队列”模型，可以让每个消费者都拥有相同的消费组名称，这样消息就会负责均衡到所有的消费者；如果要实现“发布-订阅”模型，则每个消费者的消费者组名称都不相同，这样每条消息就会广播给所有的消费者。</p> <p>分区是消费者现场模型的最小并行单位。如下图（图1）所示，生产者发布消息到一台服务器的3个分区时，只有一个消费者消费所有的3个分区。在下图（图2）中，3个分区分布在3台服务器上，同时有3个消费者分别消费不同的分区。假设每个服务器的吞吐量时300MB，在下图（图1）中分摊到每个分区只有100MB，而在下图（图2）中，集群整体的吞吐量有900MB。可以看到，增加服务器节点会提升集群的性能，增加消费者数量会提升处理性能。</p> <p>同一个消费组下多个消费者互相协调消费工作，Kafka会将所有的分区平均地分配给所有的消费者实例，这样每个消费者都可以分配到数量均等的分区。Kafka的消费组管理协议会动态地维护消费组的成员列表，当一个新消费者加入消费者组，或者有消费者离开消费组，都会触发再平衡操作。</p> <p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5ac55h7bhj30pb0plq5n.jpg" alt="img"></p> <p>Kafka的消费者消费消息时，只保证在一个分区内的消息的完全有序性，并不保证同一个主题汇中多个分区的消息顺序。而且，消费者读取一个分区消息的顺序和生产者写入到这个分区的顺序是一致的。比如，生产者写入“hello”和“Kafka”两条消息到分区P1，则消费者读取到的顺序也一定是“hello”和“Kafka”。如果业务上需要保证所有消息完全一致，只能通过设置一个分区完成，但这种做法的缺点是最多只能有一个消费者进行消费。一般来说，只需要保证每个分区的有序性，再对消息假设键来保证相同键的所有消息落入同一分区，就可以满足绝大多数的应用。</p> <h2 id="操作"><a href="#操作" aria-hidden="true" class="header-anchor">#</a> 操作</h2> <h3 id="命令行操作"><a href="#命令行操作" aria-hidden="true" class="header-anchor">#</a> 命令行操作</h3> <p>1.查看当前服务器中的所有topic</p> <div class="language- extra-class"><pre class="language-text"><code>bin/kafka-topics.sh --zookeeper localhost:2181 --list
</code></pre></div><p>2.创建topic</p> <div class="language- extra-class"><pre class="language-text"><code>bin/kafka-topics.sh --zookeeper localhost:2181 --create --replication-factor 3 --partitions 1 --topic first

</code></pre></div><p>参数说明：</p> <ul><li><p>--topic 定义topic名</p></li> <li><p>--replication-factor 定义副本数</p></li> <li><p>--partitions 定义分区数</p></li></ul> <p>3.删除topic</p> <div class="language- extra-class"><pre class="language-text"><code>bin/kafka-topics.sh --zookeeper localhost:2181 --delete --topic first
</code></pre></div><p>需要server.properties中设置delete.topic.enable = true 否则只是标记删除或者直接重启</p> <p>4.发送消息</p> <div class="language- extra-class"><pre class="language-text"><code>bin/kafka-console-producer.sh --broker-list localhost:9092 --topic first
</code></pre></div><p>在输入需要发送的内容</p> <p>5.消费消息</p> <div class="language- extra-class"><pre class="language-text"><code>bin/kafka-console-consumer.sh --zookeeper localhost:2181 --from-beginning --topic first
</code></pre></div><p>--from-beginning：会吧first主题中以往所有的数据都读出来。更具业务场景选择是否增加该配置。</p> <p>6.查看某个Topic的详情</p> <div class="language- extra-class"><pre class="language-text"><code>bin/kafka-topics.sh --zookeeper loaclhost:2181 --describe --topic first
</code></pre></div><h3 id="生产者写入流程"><a href="#生产者写入流程" aria-hidden="true" class="header-anchor">#</a> 生产者写入流程</h3> <p>1.写入方式</p> <p>Producer采用推（push）模式将消息发送到broker，每条消息都被追加（append）到分区（partition）中，属于顺序写磁盘（顺序写磁盘效率比随机写要高，保障kafka吞吐率，在读取使用的时候读取速度也会更快）。</p> <p>2.分区（partition）</p> <p>kafka集群有多个消息代理服务器（broker-server）组成，发布到Kafka集群的每条消息都有一个类别，用主题（topic）来表示。通常，不同应用产生不同类型的数据，可以设置不同的主题。一个主题一般会有多个消息的订阅者，当生产者发布消息到某个主题时，订阅了这个主题的消费者都可以接收到生产者写入的新消息。</p> <p>kafka集群为每一个主题维护了分布式的分区（partition）日志文件，物理意义上可以把主题（topic）看作进行了分区的日志文件（partition log）。主题的每个分区都是一个有序的、不可变的记录序列，新的消息会不断追加到日志中。分区中的每条消息都会按照时间顺序分配到一个单调递增的顺序编号，叫做偏移量（offset），这个偏移量能够唯一的定位当前分区的每一条消息。</p> <p>消息发送时都被发送到一个topic，本质就是一个目录，而topic是由一些partitionLogs（分区日志）组成，其组织结构如下。</p> <p>图中的topic有3个分区，每个分区的偏移量都从0开始，不同分区之间的偏移量都是独立的，不会互相影响。</p> <p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5ac59pj7rj30sa0vrtdt.jpg" alt="img"></p> <p>每个partition中的消息都是有序的，生产的消息被不断追加到partition log上，其中的每个消息都被赋予了一个唯一的offset值。</p> <p>发布到kafka主题的每条消息包括键值和时间戳。消息到达服务器端的指定分区后，都会被分配一个自增的偏移量。原始的消息内容和分配的偏移量以及其他一些元数据信息最后都会存储到分区日志文件中。消息的键也可以不用设置，这个情况下消息会均衡地分布到不同的分区。</p> <p>分区原因</p> <ul><li><p>方便在集群中扩展，每个Partition可以通过调整以适应它所在的机器，而一个topic有可以有多个Partition组成，因此整个集群就可以适应任意大小的数据了。</p></li> <li><p>可以提高并发，因为可以以partition为单位读写了。</p></li></ul> <p>传统消息系统在服务端保持消息的顺序，如果有多个消息者消息同一个消息队列，服务端会以消费存储的顺序依次发送给消费者。但由于消息是异步发送给消费者的，消息到达消费者的顺序可能是无序的，这就意味着在并行消费时，传统消息系统无法很好地保证消息被顺序处理。虽然我们可以设置一个专用的消费者值消费一个队列，以此来解决消息顺序的问题，但是这就使得消费处理无法真正执行。</p> <p>kafka比传统消息系统有更强的顺序性保证，它使用主题的分区作为消息处理的并行单元。kafka以分区作为最小的粒度，将每个分区分配给消费者组中不同的而且是唯一的消费者，并确保一个分区只属于一个消费者，即这个消费者就是这个分区的唯一读取线程。那么只要分区的消息是有序的，消费者处理的消息顺序就有保证。每个主题有多个分区，不同的消费者处理不同的分区，所以kafka不仅保证了消息的有序性，也做到了消费者的负载均衡。</p> <p>3.副本（Replication）</p> <p>同一个partition可能会有多个replication（对应server.properties配置中的default.replication.factor=N）。没有replication的情况下，一旦broker宕机，其中所有partition的数据都不可被消费，同时producer也不能再将数据存于其上的partition。引入replication之后，同一个partition可能会有多个replication，而这时需要在这些replication之间选出一个leader，producer和consumer只与这个leader交互，其它replication作为follower从leader中复制数据。</p> <p>4.写入流程</p> <p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5ac5cw2cij30zl0hq0uv.jpg" alt="img"></p> <ol><li>producer先从zookeeper的“/brokers/.../state”节点找到该partition的leader</li> <li>producer将消息发送给该leader</li> <li>leader将消息写入本地log</li> <li>followers从leader pull消息，写入本地log后向leader发送ACK</li> <li>leader收到所有ISR中的replication的ACK后，增加HW（high watermark，最后commit的offset）并向producer发送ACK。</li></ol> <h3 id="消费过程"><a href="#消费过程" aria-hidden="true" class="header-anchor">#</a> 消费过程</h3> <h4 id="kafka在zookeeper中的存储结构"><a href="#kafka在zookeeper中的存储结构" aria-hidden="true" class="header-anchor">#</a> kafka在zookeeper中的存储结构</h4> <p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g5ac5fuqi7j310q0kpacz.jpg" alt="img"></p> <p>producer不在zk中注册，消费者在zk中注册。</p> <h4 id="kafka消费过程分析"><a href="#kafka消费过程分析" aria-hidden="true" class="header-anchor">#</a> kafka消费过程分析</h4> <p>kafka提供了两套consumer API：高级Consumer Api和低级Api</p> <p>1.高级Api</p> <p>优点：</p> <ul><li><p>编写简单，不需要自行管理offset，系统通过zookeeper自行管理</p></li> <li><p>不需要管理分区，副本等情况，系统自动管理。</p></li> <li><p>消费者断线会自动根据上一次记录在zookeeper中的offset去接着获取数据（默认设置1分钟更新一下zookeeper中存的offset）</p></li> <li><p>可以使用group来区分一个topic的不同程序访问分离开来</p></li></ul> <p>缺点</p> <ul><li><p>不能手动控制offset</p></li> <li><p>不能细化控制分区、副本、zk等</p></li></ul> <p>2.低级Api</p> <p>优点</p> <p>能够让开发者自己控制offset</p> <p>手动控制连接分区，对分区自定义负载均衡策略</p> <p>对zookeeper的依赖性降低</p> <p>缺点</p> <p>过于复杂，手动控制offset的代价过高</p> <p>3.消费者模型</p> <p>​    消息有生产者发布到kafka集群后，会被消费者消费。消息的消费模型有两种，推送模型（push）和拉取模型（pull）。</p> <p>​    基于推送模型（push）的消息系统，有消息代理记录消费者的消费状态。消息代理在将消息推送到消费者后，标记这条消息已经消费，但这种方式无法很好地保证消费被处理。如果要保证消息被处理，消息代理发送完消息后，要设置状态为“已发送”，只要收到消费者的确认请求后才更新为“已消费”，这就需要代理中记录所有的消费状态，但显然这种方式不可取。</p> <p>​    kafka采用拉取模型，由消费者自己记录消费状态，每个消费者互相独立地顺序拉取每个分区的消息。如下图所示，有两个消费者（不同消费者组）拉取同一个主题的消息，消费者A的消费进度是3，消费者B的消费进度是6。消费者拉取的最大上限通过最高水位（watermark）控制，生产者最新写入的消息如果还没有达到备份数量，对消费者是不可见的。这种由消费者控制偏移量的优点是：消费者可以按照任意的顺序消费消息。比如，消费者可以重置到旧的偏移量，重新处理之前已经消费过的消息；或者直接跳到最近的位置，从当前的时刻开始消费。</p> <p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5ac5ik252j30lh06u74f.jpg" alt="img"></p> <p>​    在一些消息系统中，消息代理会在消息被消费之后立即删除消息。如果有不同类型的消费者订阅同一个主题，消息代理可能需要冗余地存储同一消息；或者等所有消费者都消费完才删除，这就需要消息代理跟踪每个消费者的消费状态，这种设计很大程度上限制了消息系统的整体吞吐量和处理延迟。Kafka的做法是生产者发布的所有消息会一致保存在Kafka集群中，不管消息有没有被消费。用户可以通过设置保留时间来清理过期的数据，比如，设置保留策略为两天。那么，在消息发布之后，它可以被不同的消费者消费，在两天之后，过期的消息就会自动清理掉。</p> <p>4.消费者组</p> <p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5ac5mdpo4j30x50e1gmr.jpg" alt="img"></p> <p>​    消费者是以consumer group消费者组的方式工作，由一个或者多个消费者组成一个组，共同消费一个topic。每个分区在同一时间只能由group中的一个消费者读取，但是多个group可以同时消费这个partition。在图中，有一个由三个消费者组成的group，有一个消费者读取主题中的两个分区，另外两个分别读取一个分区。某个消费者读取某个分区，也可以叫做某个消费者是某个分区的拥有者。</p> <p>​    在这种情况下，消费者可以通过水平扩展的方式同时读取大量的消息。另外，如果一个消费者失败了，那么其他的group成员会自动负载均衡读取之前失败的消费者读取的分区。</p> <p>5.消费方式</p> <p>​    consumer采用pull（拉）模式从broker中读取数据。</p> <p>​    push（推）模式很难适应消费速率不同的消费者，因为消息发送速率是由broker决定的。它的目标是尽可能以最快速度传递消息，但是这样很容易造成consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而pull模式则可以根据consumer的消费能力以适当的速率消费消息。</p> <p>​    对于Kafka而言，pull模式更合适，它可简化broker的设计，consumer可自主控制消费消息的速率，同时consumer可以自己控制消费方式——即可批量消费也可逐条消费，同时还能选择不同的提交方式从而实现不同的传输语义。</p> <p>​    pull模式不足之处是，如果kafka没有数据，消费者可能会陷入循环中，一直等待数据到达。为了避免这种情况，我们在我们的拉请求中有参数，允许消费者请求在等待数据到达的“长轮询”中进行阻塞（并且可选地等待到给定的字节数，以确保大的传输大小）。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/wiki/hadoop/hadoop-6-Hive.html" class="prev">
          Hive
        </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/wiki/assets/js/app.dd178f5a.js" defer></script><script src="/wiki/assets/js/2.9f273a62.js" defer></script><script src="/wiki/assets/js/26.59450304.js" defer></script>
  </body>
</html>
