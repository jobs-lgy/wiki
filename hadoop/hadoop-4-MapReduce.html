<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>MapReduce | JavaChen Wiki</title>
    <meta name="description" content="JavaChen Wiki">
    <link rel="icon" href="/wiki/img/logo.ico">
  <meta http-quiv="pragma" cotent="no-cache">
  <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
  <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/wiki/assets/css/0.styles.bdf32acf.css" as="style"><link rel="preload" href="/wiki/assets/js/app.dd178f5a.js" as="script"><link rel="preload" href="/wiki/assets/js/2.9f273a62.js" as="script"><link rel="preload" href="/wiki/assets/js/23.87ecfe73.js" as="script"><link rel="prefetch" href="/wiki/assets/js/10.e389070d.js"><link rel="prefetch" href="/wiki/assets/js/11.19e9f97f.js"><link rel="prefetch" href="/wiki/assets/js/12.f95e0459.js"><link rel="prefetch" href="/wiki/assets/js/13.127730fd.js"><link rel="prefetch" href="/wiki/assets/js/14.34eed2f7.js"><link rel="prefetch" href="/wiki/assets/js/15.a8cf4000.js"><link rel="prefetch" href="/wiki/assets/js/16.6346731c.js"><link rel="prefetch" href="/wiki/assets/js/17.143af375.js"><link rel="prefetch" href="/wiki/assets/js/18.7d95703a.js"><link rel="prefetch" href="/wiki/assets/js/19.8726bd0b.js"><link rel="prefetch" href="/wiki/assets/js/20.2914a04f.js"><link rel="prefetch" href="/wiki/assets/js/21.ebd751e0.js"><link rel="prefetch" href="/wiki/assets/js/22.f6801be0.js"><link rel="prefetch" href="/wiki/assets/js/24.cabcaf93.js"><link rel="prefetch" href="/wiki/assets/js/25.306828f5.js"><link rel="prefetch" href="/wiki/assets/js/26.59450304.js"><link rel="prefetch" href="/wiki/assets/js/27.44fddb85.js"><link rel="prefetch" href="/wiki/assets/js/28.4e15bea1.js"><link rel="prefetch" href="/wiki/assets/js/29.bed7cbfd.js"><link rel="prefetch" href="/wiki/assets/js/3.28138f41.js"><link rel="prefetch" href="/wiki/assets/js/30.36a67cca.js"><link rel="prefetch" href="/wiki/assets/js/31.dde8666e.js"><link rel="prefetch" href="/wiki/assets/js/32.148ea73a.js"><link rel="prefetch" href="/wiki/assets/js/33.61c937cc.js"><link rel="prefetch" href="/wiki/assets/js/34.eb7c4b0c.js"><link rel="prefetch" href="/wiki/assets/js/35.abb4ce3d.js"><link rel="prefetch" href="/wiki/assets/js/36.f03d0378.js"><link rel="prefetch" href="/wiki/assets/js/37.84491176.js"><link rel="prefetch" href="/wiki/assets/js/38.2a06b872.js"><link rel="prefetch" href="/wiki/assets/js/39.63965d3b.js"><link rel="prefetch" href="/wiki/assets/js/4.c0af9872.js"><link rel="prefetch" href="/wiki/assets/js/40.bf2e354a.js"><link rel="prefetch" href="/wiki/assets/js/41.bed53451.js"><link rel="prefetch" href="/wiki/assets/js/42.34d4f2f5.js"><link rel="prefetch" href="/wiki/assets/js/43.867c0e23.js"><link rel="prefetch" href="/wiki/assets/js/44.0201a314.js"><link rel="prefetch" href="/wiki/assets/js/45.d6f1a311.js"><link rel="prefetch" href="/wiki/assets/js/46.419d44e4.js"><link rel="prefetch" href="/wiki/assets/js/47.a3f8b595.js"><link rel="prefetch" href="/wiki/assets/js/48.574cc219.js"><link rel="prefetch" href="/wiki/assets/js/49.224dd6c4.js"><link rel="prefetch" href="/wiki/assets/js/5.c521f8b1.js"><link rel="prefetch" href="/wiki/assets/js/50.c8825040.js"><link rel="prefetch" href="/wiki/assets/js/51.2dab614a.js"><link rel="prefetch" href="/wiki/assets/js/52.8382a180.js"><link rel="prefetch" href="/wiki/assets/js/53.bfab18a9.js"><link rel="prefetch" href="/wiki/assets/js/54.87a1d37c.js"><link rel="prefetch" href="/wiki/assets/js/55.5f207671.js"><link rel="prefetch" href="/wiki/assets/js/56.f0e8e082.js"><link rel="prefetch" href="/wiki/assets/js/57.c868e5c9.js"><link rel="prefetch" href="/wiki/assets/js/6.6a737c5b.js"><link rel="prefetch" href="/wiki/assets/js/7.48bba6b4.js"><link rel="prefetch" href="/wiki/assets/js/8.26532964.js"><link rel="prefetch" href="/wiki/assets/js/9.3c4a4032.js">
    <link rel="stylesheet" href="/wiki/assets/css/0.styles.bdf32acf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/wiki/" class="home-link router-link-active"><!----> <span class="site-name">JavaChen Wiki</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/wiki/" class="nav-link">主页</a></div><div class="nav-item"><a href="/wiki/docker/" class="nav-link">Docker</a></div><div class="nav-item"><a href="/wiki/elasticsearch/" class="nav-link">Elasticsearch</a></div><div class="nav-item"><a href="/wiki/hadoop/" class="nav-link router-link-active">Hadoop</a></div><div class="nav-item"><a href="/wiki/interview/" class="nav-link">Interview</a></div><div class="nav-item"><a href="/wiki/rabbitMQ/" class="nav-link">RabbitMQ</a></div><div class="nav-item"><a href="/wiki/redis/" class="nav-link">Redis</a></div><div class="nav-item"><a href="/wiki/spring-cloud-cshop/" class="nav-link">Spring-cloud-cshop</a></div><div class="nav-item"><a href="/wiki/about.html" class="nav-link">关于</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/wiki/" class="nav-link">主页</a></div><div class="nav-item"><a href="/wiki/docker/" class="nav-link">Docker</a></div><div class="nav-item"><a href="/wiki/elasticsearch/" class="nav-link">Elasticsearch</a></div><div class="nav-item"><a href="/wiki/hadoop/" class="nav-link router-link-active">Hadoop</a></div><div class="nav-item"><a href="/wiki/interview/" class="nav-link">Interview</a></div><div class="nav-item"><a href="/wiki/rabbitMQ/" class="nav-link">RabbitMQ</a></div><div class="nav-item"><a href="/wiki/redis/" class="nav-link">Redis</a></div><div class="nav-item"><a href="/wiki/spring-cloud-cshop/" class="nav-link">Spring-cloud-cshop</a></div><div class="nav-item"><a href="/wiki/about.html" class="nav-link">关于</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Hadoop</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/wiki/hadoop/" class="sidebar-link">大数据概论</a></li><li><a href="/wiki/hadoop/hadoop-2-Hadoop概述.html" class="sidebar-link">Hadoop</a></li><li><a href="/wiki/hadoop/hadoop-3-hdfs.html" class="sidebar-link">HDFS</a></li><li><a href="/wiki/hadoop/hadoop-4-MapReduce.html" class="active sidebar-link">MapReduce</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/hadoop/hadoop-4-MapReduce.html#mapreduce概述" class="sidebar-link">MapReduce概述</a></li><li class="sidebar-sub-header"><a href="/wiki/hadoop/hadoop-4-MapReduce.html#为什么要mapreduce" class="sidebar-link">为什么要MapReduce</a></li><li class="sidebar-sub-header"><a href="/wiki/hadoop/hadoop-4-MapReduce.html#inputformat切片机制" class="sidebar-link">InputFormat切片机制</a></li><li class="sidebar-sub-header"><a href="/wiki/hadoop/hadoop-4-MapReduce.html#maptask机制" class="sidebar-link">MapTask机制</a></li><li class="sidebar-sub-header"><a href="/wiki/hadoop/hadoop-4-MapReduce.html#shuffle机制" class="sidebar-link">Shuffle机制</a></li><li class="sidebar-sub-header"><a href="/wiki/hadoop/hadoop-4-MapReduce.html#reducetask工作机制" class="sidebar-link">ReduceTask工作机制</a></li><li class="sidebar-sub-header"><a href="/wiki/hadoop/hadoop-4-MapReduce.html#数据压缩" class="sidebar-link">数据压缩</a></li><li class="sidebar-sub-header"><a href="/wiki/hadoop/hadoop-4-MapReduce.html#优化" class="sidebar-link">优化</a></li><li class="sidebar-sub-header"><a href="/wiki/hadoop/hadoop-4-MapReduce.html#面试" class="sidebar-link">面试</a></li></ul></li><li><a href="/wiki/hadoop/hadoop-5-Yarn.html" class="sidebar-link">Yarn</a></li><li><a href="/wiki/hadoop/hadoop-6-Hive.html" class="sidebar-link">Hive</a></li><li><a href="/wiki/hadoop/hadoop-7-Kafka.html" class="sidebar-link">Kafka</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="mapreduce"><a href="#mapreduce" aria-hidden="true" class="header-anchor">#</a> MapReduce</h1> <h2 id="mapreduce概述"><a href="#mapreduce概述" aria-hidden="true" class="header-anchor">#</a> MapReduce概述</h2> <p>Mapreduce是一个分布式运算程序的编程框架，是用户开发“基于hadoop的数据分析应用”的核心框架；</p> <p>Mapreduce核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个hadoop集群上。</p> <h2 id="为什么要mapreduce"><a href="#为什么要mapreduce" aria-hidden="true" class="header-anchor">#</a> 为什么要MapReduce</h2> <p>1）海量数据在单机上处理因为硬件资源限制，无法胜任</p> <p>2）而一旦将单机版程序扩展到集群来分布式运行，将极大增加程序的复杂度和开发难度</p> <p>3）引入mapreduce框架后，开发人员可以将绝大部分工作集中在业务逻辑的开发上，而将分布式计算中的复杂性交由框架来处理。</p> <p>4）mapreduce分布式方案考虑的问题</p> <p>（1）运算逻辑要不要先分后合？</p> <p>（2）程序如何分配运算任务（切片）？</p> <p>（3）两阶段的程序如何启动？如何协调？</p> <p>（4）整个程序运行过程中的监控？容错？重试？</p> <p>分布式方案需要考虑很多问题，但是我们可以将分布式程序中的公共功能封装成框架，让开发人员将精力集中于业务逻辑上，而mapreduce就是这样一个分布式程序的通用框架。</p> <h3 id="核心思想"><a href="#核心思想" aria-hidden="true" class="header-anchor">#</a> 核心思想</h3> <p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g5acqyjtcej31ip0pshdm.jpg" alt="img"></p> <p>1）分布式的运算程序往往需要分成至少2个阶段</p> <p>2）第一个阶段的maptask并发实例，完全并行运行，互不相干</p> <p>3）第二个阶段的reduce task并发实例互不相干，但是他们的数据依赖于上一个阶段的所有maptask并发实例的输出</p> <p>4）MapReduce编程模型只能包含一个map阶段和一个reduce阶段，如果用户的业务逻辑非常复杂，那就只能多个mapreduce程序，串行运行</p> <p><strong>MapReduce</strong>进程</p> <p>一个完整的mapreduce程序在分布式运行时有三类实例进程：</p> <p>1）MrAppMaster：负责整个程序的过程调度及状态协调</p> <p>2）MapTask：负责map阶段的整个数据处理流程</p> <p>3）ReduceTask：负责reduce阶段的整个数据处理流程</p> <h3 id="编程规范"><a href="#编程规范" aria-hidden="true" class="header-anchor">#</a> 编程规范</h3> <p>用户编写的程序分成三个部分：Mapper，Reducer，Driver(提交运行mr程序的客户端)</p> <p>1）Mapper阶段</p> <p>​	（1）用户自定义的Mapper要继承自己的父类</p> <p>​	（2）Mapper的输入数据是KV对的形式（KV的类型可自定义）</p> <p>​	（3）Mapper中的业务逻辑写在map()方法中</p> <p>​	（4）Mapper的输出数据是KV对的形式（KV的类型可自定义）</p> <p>​	（5）map()方法（maptask进程）对每一个&lt;K,V&gt;调用一次</p> <p>2）Reducer阶段</p> <p>​	（1）用户自定义的Reducer要继承自己的父类</p> <p>​	（2）Reducer的输入数据类型对应Mapper的输出数据类型，也是KV</p> <p>​	（3）Reducer的业务逻辑写在reduce()方法中</p> <p>​	（4）Reducetask进程对每一组相同k的&lt;k,v&gt;组调用一次reduce()方法</p> <p>3）Driver阶段</p> <p>整个程序需要一个Drvier来进行提交，提交的是一个描述了各种必要信息的job对象</p> <h3 id="mapreduce运行流程"><a href="#mapreduce运行流程" aria-hidden="true" class="header-anchor">#</a> <strong>MapReduce</strong>运行流程</h3> <h4 id="运行机制"><a href="#运行机制" aria-hidden="true" class="header-anchor">#</a> 运行机制</h4> <p>1）在MapReduce程序读取文件的输入目录上存放相应的文件。</p> <p>2）客户端程序在submit()方法执行前，获取待处理的数据信息，然后根据集群中参数的配置形成一个任务分配规划。</p> <p>3）客户端提交job.split、jar包、job.xml等文件给yarn，yarn中的resourcemanager启动MRAppMaster。</p> <p>4）MRAppMaster启动后根据本次job的描述信息，计算出需要的maptask实例数量，然后向集群申请机器启动相应数量的maptask进程。</p> <p>5）maptask利用客户指定的inputformat来读取数据，形成输入KV对。</p> <p>6）maptask将输入KV对传递给客户定义的map()方法，做逻辑运算</p> <p>7）map()运算完毕后将KV对收集到maptask缓存。</p> <p>8）maptask缓存中的KV对按照K分区排序后不断写到磁盘文件</p> <p>9）MRAppMaster监控到所有maptask进程任务完成之后，会根据客户指定的参数启动相应数量的reducetask进程，并告知reducetask进程要处理的数据分区。</p> <p>10）Reducetask进程启动之后，根据MRAppMaster告知的待处理数据所在位置，从若干台maptask运行所在机器上获取到若干个maptask输出结果文件，并在本地进行重新归并排序，然后按照相同key的KV为一个组，调用客户定义的reduce()方法进行逻辑运算。</p> <p>11）Reducetask运算完毕后，调用客户指定的outputformat将结果数据输出到外部存储。</p> <p>工作机制：</p> <p>更详细的过程：</p> <p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g5acr96dfrj31kw0rttjy.jpg" alt="img"></p> <p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g5acreaxdvj31l60r0114.jpg" alt="img"></p> <p>上面的流程是整个mapreduce最全工作流程，但是shuffle过程只是从第7步开始到第16步结束，具体shuffle过程详解，如下：</p> <p>1）maptask收集我们的map()方法输出的kv对，放到内存缓冲区中</p> <p>2）从内存缓冲区不断溢出本地磁盘文件，可能会溢出多个文件</p> <p>3）多个溢出文件会被合并成大的溢出文件</p> <p>4）在溢出及合并的过程中，都要调用partitioner进行分区和针对key进行排序</p> <p>5）reducetask根据自己的分区号，去各个maptask机器上取相应的结果分区数据</p> <p>6）reducetask会取到同一个分区的来自不同maptask的结果文件，reducetask会将这些文件再进行合并（归并排序）</p> <p>7）合并成大文件后，shuffle的过程也就结束了，后面进入reducetask的逻辑运算过程（从文件中取出一个一个的键值对group，调用用户自定义的reduce()方法）</p> <blockquote><p>注意：Shuffle中的缓冲区大小会影响到mapreduce程序的执行效率，原则上说，缓冲区越大，磁盘io的次数越少，执行速度就越快。</p> <p>缓冲区的大小可以通过参数调整，参数：io.sort.mb  默认100M</p></blockquote> <h2 id="inputformat切片机制"><a href="#inputformat切片机制" aria-hidden="true" class="header-anchor">#</a> InputFormat切片机制</h2> <h3 id="fileinputformat"><a href="#fileinputformat" aria-hidden="true" class="header-anchor">#</a> <strong>FileInputFormat</strong></h3> <p><strong>1）job提交流程源码详解</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token function">waitForCompletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 1建立连接</span>
	<span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
	<span class="token comment">// 1）创建提交job的代理</span>
 	<span class="token keyword">new</span> <span class="token class-name">Cluster</span><span class="token punctuation">(</span><span class="token function">getConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// （1）判断是本地yarn还是远程</span>
	<span class="token function">initialize</span><span class="token punctuation">(</span>jobTrackAddr<span class="token punctuation">,</span> conf<span class="token punctuation">)</span><span class="token punctuation">;</span> 

	<span class="token comment">// 2 提交job</span>
	submitter<span class="token punctuation">.</span><span class="token function">submitJobInternal</span><span class="token punctuation">(</span><span class="token class-name">Job</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> cluster<span class="token punctuation">)</span>

	<span class="token comment">// 1）创建给集群提交数据的Stag路径</span>
	<span class="token class-name">Path</span> jobStagingArea <span class="token operator">=</span> <span class="token class-name">JobSubmissionFiles</span><span class="token punctuation">.</span>*getStagingDir<span class="token operator">*</span><span class="token punctuation">(</span>cluster<span class="token punctuation">,</span> conf<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 2）获取jobid ，并创建job路径</span>
	<span class="token class-name">JobID</span> jobId <span class="token operator">=</span> submitClient<span class="token punctuation">.</span><span class="token function">getNewJobID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 3）拷贝jar包到集群</span>
	<span class="token function">copyAndConfigureFiles</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> submitJobDir<span class="token punctuation">)</span><span class="token punctuation">;</span>	
	rUploader<span class="token punctuation">.</span><span class="token function">uploadFiles</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> jobSubmitDir<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 4）计算切片，生成切片规划文件</span>
	<span class="token function">writeSplits</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> submitJobDir<span class="token punctuation">)</span><span class="token punctuation">;</span>
	maps <span class="token operator">=</span> <span class="token function">writeNewSplits</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> jobSubmitDir<span class="token punctuation">)</span><span class="token punctuation">;</span>
	input<span class="token punctuation">.</span><span class="token function">getSplits</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 5）向Stag路径写xml配置文件</span>
	<span class="token function">writeConf</span><span class="token punctuation">(</span>conf<span class="token punctuation">,</span> submitJobFile<span class="token punctuation">)</span><span class="token punctuation">;</span>
	conf<span class="token punctuation">.</span><span class="token function">writeXml</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 6）提交job,返回提交状态</span>
	status <span class="token operator">=</span> submitClient<span class="token punctuation">.</span><span class="token function">submitJob</span><span class="token punctuation">(</span>jobId<span class="token punctuation">,</span> submitJobDir<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> job<span class="token punctuation">.</span><span class="token function">getCredentials</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g5acrjky9cj31p60u047e.jpg" alt="img"></p> <p><strong>2）FileInputFormat源码解析(input.getSplits(job))</strong></p> <p>（1）找到你数据存储的目录。</p> <p>（2）开始遍历处理（规划切片）目录下的每一个文件</p> <p>（3）遍历第一个文件ss.txt</p> <p>​		a）获取文件大小fs.sizeOf(ss.txt);</p> <p>​		b）计算切片大小computeSliteSize(Math.max(minSize,Math.min(maxSize,blocksize)))=blocksize=128M</p> <p>​		c）默认情况下，切片大小=blocksize</p> <p>​		d）开始切，形成第1个切片：ss.txt—0:128M 第2个切片ss.txt—128:256M 第3个切片ss.txt—256M:300M（每次切片时，都要判断切完剩下的部分是否大于块的1.1倍，不大于1.1倍就划分一块切片）</p> <p>​		e）将切片信息写到一个切片规划文件中</p> <p>​		f）整个切片的核心过程在getSplit()方法中完成。</p> <p>​		g）数据切片只是在逻辑上对输入数据进行分片，并不会再磁盘上将其切分成分片进行存储。InputSplit只记录了分片的元数据信息，比如起始位置、长度以及所在的节点列表等。</p> <p>​		h）注意：block是HDFS上物理上存储的存储的数据，切片是对数据逻辑上的划分</p> <p>（4）提交切片规划文件到yarn上，yarn上的MrAppMaster就可以根据切片规划文件计算开启maptask个数。</p> <p><strong>3）FileInputFormat中默认的切片机制：</strong></p> <p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g5acrp3l4bj31it0ofk51.jpg" alt="img"></p> <p>（1）简单地按照文件的内容长度进行切片</p> <p>（2）切片大小，默认等于block大小</p> <p>（3）切片时不考虑数据集整体，而是逐个针对每一个文件单独切片</p> <p>比如待处理数据有两个文件：</p> <div class="language- extra-class"><pre class="language-text"><code> file1.txt    320M  
 file2.txt    10M 
</code></pre></div><p>经过FileInputFormat的切片机制运算后，形成的切片信息如下：</p> <div class="language- extra-class"><pre class="language-text"><code>file1.txt.split1--  0~128 
file1.txt.split2--  128~256 
file1.txt.split3--  256~320 
file2.txt.split1--  0~10M 
</code></pre></div><p><strong>4）FileInputFormat切片大小的参数配置</strong></p> <p>（1）通过分析源码，在FileInputFormat中，计算切片大小的逻辑：Math.max(minSize, Math.min(maxSize, blockSize));</p> <p>切片主要由这几个值来运算决定</p> <div class="language-java extra-class"><pre class="language-java"><code>mapreduce<span class="token punctuation">.</span>input<span class="token punctuation">.</span>fileinputformat<span class="token punctuation">.</span>split<span class="token punctuation">.</span>minsize<span class="token operator">=</span><span class="token number">1</span>    <span class="token comment">//默认值为1</span>

mapreduce<span class="token punctuation">.</span>input<span class="token punctuation">.</span>fileinputformat<span class="token punctuation">.</span>split<span class="token punctuation">.</span>maxsize<span class="token operator">=</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token class-name">MAXValue</span> <span class="token comment">//默认值Long.MAXValue</span>
</code></pre></div><p>因此，默认情况下，切片大小=blocksize。</p> <p>maxsize（切片最大值）：参数如果调得比blocksize小，则会让切片变小，而且就等于配置的这个参数的值。</p> <p>minsize（切片最小值）：参数调的比blockSize大，则可以让切片变得比blocksize还大。</p> <p><strong>5）获取切片信息API</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 根据文件类型获取切片信息</span>
<span class="token class-name">FileSplit</span> inputSplit <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">FileSplit</span><span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">getInputSplit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取切片的文件名称</span>
<span class="token class-name">String</span> name <span class="token operator">=</span> inputSplit<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="combinetextinputformat"><a href="#combinetextinputformat" aria-hidden="true" class="header-anchor">#</a> <strong>CombineTextInputFormat</strong></h3> <p>关于大量小文件的优化策略</p> <p>1）默认情况下TextInputformat对任务的切片机制是按文件规划切片，不管文件多小，都会是一个单独的切片，都会交给一个maptask，这样如果有大量小文件，就会产生大量的maptask，处理效率极其低下。</p> <p>2）优化策略</p> <p>​	（1）最好的办法，在数据处理系统的最前端（预处理/采集），将小文件先合并成大文件，再上传到HDFS做后续分析。</p> <p>​	（2）补救措施：如果已经是大量小文件在HDFS中了，可以使用另一种InputFormat来做切片（CombineTextInputFormat），它的切片逻辑跟TextFileInputFormat不同：它可以将多个小文件从逻辑上规划到一个切片中，这样，多个小文件就可以交给一个maptask。</p> <p>​	（3）优先满足最小切片大小，不超过最大切片大小</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">CombineTextInputFormat</span><span class="token punctuation">.</span><span class="token function">setMaxInputSplitSize</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token number">4194304</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 128m</span>

<span class="token class-name">CombineTextInputFormat</span><span class="token punctuation">.</span><span class="token function">setMinInputSplitSize</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token number">2097152</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2m</span>
</code></pre></div><p>​	举例：0.5m+1m+0.3m+5m=2m + 4.8m=2m + 4m + 0.8m</p> <p>3）具体实现步骤</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 如果不设置InputFormat,它默认用的是TextInputFormat.class</span>
job<span class="token punctuation">.</span><span class="token function">setInputFormatClass</span><span class="token punctuation">(</span><span class="token class-name">CombineTextInputFormat</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token class-name">CombineTextInputFormat</span><span class="token punctuation">.</span><span class="token function">setMaxInputSplitSize</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token number">4194304</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4m</span>
<span class="token class-name">CombineTextInputFormat</span><span class="token punctuation">.</span><span class="token function">setMinInputSplitSize</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token number">2097152</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2m</span>
</code></pre></div><h2 id="maptask机制"><a href="#maptask机制" aria-hidden="true" class="header-anchor">#</a> MapTask机制</h2> <h3 id="并行度决定机制"><a href="#并行度决定机制" aria-hidden="true" class="header-anchor">#</a> 并行度决定机制</h3> <p>1）问题引出</p> <p>maptask的并行度决定map阶段的任务处理并发度，进而影响到整个job的处理速度。那么，mapTask并行任务是否越多越好呢？</p> <p>2）MapTask并行度决定机制</p> <p>​	<strong>一个job的map阶段MapTask并行度（个数），由客户端提交job时的切片个数决定。</strong></p> <h3 id="maptask工作机制"><a href="#maptask工作机制" aria-hidden="true" class="header-anchor">#</a> <strong>MapTask</strong>工作机制</h3> <p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g5acrw1v1sj31s40u0aki.jpg" alt="img"></p> <p>​	（1）Read阶段：Map Task通过用户编写的RecordReader，从输入InputSplit中解析出一个个key/value。</p> <p>​	（2）Map阶段：该节点主要是将解析出的key/value交给用户编写map()函数处理，并产生一系列新的key/value。</p> <p>​	（3）Collect收集阶段：在用户编写map()函数中，当数据处理完成后，一般会调用OutputCollector.collect()输出结果。在该函数内部，它会将生成的key/value分区（调用Partitioner），并写入一个环形内存缓冲区中。</p> <p>​	（4）Spill阶段：即“溢写”，当环形缓冲区满后，MapReduce会将数据写到本地磁盘上，生成一个临时文件。需要注意的是，将数据写入本地磁盘之前，先要对数据进行一次本地排序，并在必要时对数据进行合并、压缩等操作。</p> <p>​	<strong>溢写阶段详情：</strong></p> <p>​	步骤1：利用快速排序算法对缓存区内的数据进行排序，排序方式是，先按照分区编号partition进行排序，然后按照key进行排序。这样，经过排序后，数据以分区为单位聚集在一起，且同一分区内所有数据按照key有序。</p> <p>​	步骤2：按照分区编号由小到大依次将每个分区中的数据写入任务工作目录下的临时文件output/spillN.out（N表示当前溢写次数）中。如果用户设置了Combiner，则写入文件之前，对每个分区中的数据进行一次聚集操作。</p> <p>​	步骤3：将分区数据的元信息写到内存索引数据结构SpillRecord中，其中每个分区的元信息包括在临时文件中的偏移量、压缩前数据大小和压缩后数据大小。如果当前内存索引大小超过1MB，则将内存索引写到文件output/spillN.out.index中。</p> <p>​	（5）Combine阶段：当所有数据处理完成后，MapTask对所有临时文件进行一次合并，以确保最终只会生成一个数据文件。</p> <p>​	当所有数据处理完后，MapTask会将所有临时文件合并成一个大文件，并保存到文件output/file.out中，同时生成相应的索引文件output/file.out.index。</p> <p>​	在进行文件合并过程中，MapTask以分区为单位进行合并。对于某个分区，它将采用多轮递归合并的方式。每轮合并io.sort.factor（默认100）个文件，并将产生的文件重新加入待合并列表中，对文件排序后，重复以上过程，直到最终得到一个大文件。</p> <p>​	让每个MapTask最终只生成一个数据文件，可避免同时打开大量文件和同时读取大量小文件产生的随机读取带来的开销。</p> <h2 id="shuffle机制"><a href="#shuffle机制" aria-hidden="true" class="header-anchor">#</a> Shuffle机制</h2> <h3 id="shuffle机制-2"><a href="#shuffle机制-2" aria-hidden="true" class="header-anchor">#</a> <strong>Shuffle</strong>机制</h3> <p>Mapreduce确保每个reducer的输入都是按键排序的。系统执行排序的过程（即将map输出作为输入传给reducer）称为shuffle。</p> <p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5aacqkh6yj31o90u0n9j.jpg" alt="img"></p> <h3 id="partition分区"><a href="#partition分区" aria-hidden="true" class="header-anchor">#</a> <strong>partition</strong>分区</h3> <p>0）问题引出</p> <p>要求将统计结果按照条件输出到不同文件中（分区）。比如：将统计结果按照手机归属地不同省份输出到不同文件中（分区）</p> <p>1）默认partition分区</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashPartitioner</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Partitioner</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token comment">/** Use {@link Object#hashCode()} to partition. */</span>
  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getPartition</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> numReduceTasks<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span> <span class="token operator">%</span> numReduceTasks<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>​	默认分区是根据key的hashCode对reduceTasks个数取模得到的。用户没法控制哪个key存储到哪个分区。</p> <p>2）自定义Partitioner步骤</p> <p>​	（1）自定义类继承Partitioner，重写getPartition()方法</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProvincePartitioner</span> <span class="token keyword">extends</span> <span class="token class-name">Partitioner</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">FlowBean</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getPartition</span><span class="token punctuation">(</span><span class="token class-name">Text</span> key<span class="token punctuation">,</span> <span class="token class-name">FlowBean</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> numPartitions<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 1 获取电话号码的前三位</span>
		<span class="token class-name">String</span> preNum <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token keyword">int</span> partition <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
		
		<span class="token comment">// 2 判断是哪个省</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">&quot;136&quot;</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>preNum<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			partition <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">&quot;137&quot;</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>preNum<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			partition <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">&quot;138&quot;</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>preNum<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			partition <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">&quot;139&quot;</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>preNum<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			partition <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> partition<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>​	（2）在job驱动中，设置自定义partitioner：</p> <div class="language-java extra-class"><pre class="language-java"><code>job<span class="token punctuation">.</span><span class="token function">setPartitionerClass</span><span class="token punctuation">(</span><span class="token class-name">CustomPartitioner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
</code></pre></div><p>​	（3）自定义partition后，要根据自定义partitioner的逻辑设置相应数量的reduce task</p> <div class="language-java extra-class"><pre class="language-java"><code> job<span class="token punctuation">.</span><span class="token function">setNumReduceTasks</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div><p>3）注意：</p> <p>如果reduceTask的数量&gt; getPartition的结果数，则会多产生几个空的输出文件part-r-000xx；</p> <p>如果1&lt;reduceTask的数量&lt;getPartition的结果数，则有一部分分区数据无处安放，会Exception；</p> <p>如果reduceTask的数量=1，则不管mapTask端输出多少个分区文件，最终结果都交给这一个reduceTask，最终也就只会产生一个结果文件 part-r-00000；</p> <p>​	例如：假设自定义分区数为5，则</p> <p>（1）job.setNumReduceTasks(1);会正常运行，只不过会产生一个输出文件</p> <p>（2）job.setNumReduceTasks(2);会报错</p> <p>（3）job.setNumReduceTasks(6);大于5，程序会正常运行，会产生空文件</p> <h3 id="writablecomparable排序"><a href="#writablecomparable排序" aria-hidden="true" class="header-anchor">#</a> <strong>WritableComparable</strong>排序</h3> <p>排序是MapReduce框架中最重要的操作之一。Map Task和Reduce Task均会对数据（按照key）进行排序。该操作属于Hadoop的默认行为。任何应用程序中的数据均会被排序，而不管逻辑上是否需要。</p> <p>对于Map Task，它会将处理的结果暂时放到一个缓冲区中，当缓冲区使用率达到一定阈值后，再对缓冲区中的数据进行一次排序，并将这些有序数据写到磁盘上，而当数据处理完毕后，它会对磁盘上所有文件进行一次合并，以将这些文件合并成一个大的有序文件。</p> <p>对于Reduce Task，它从每个Map Task上远程拷贝相应的数据文件，如果文件大小超过一定阈值，则放到磁盘上，否则放到内存中。如果磁盘上文件数目达到一定阈值，则进行一次合并以生成一个更大文件；如果内存中文件大小或者数目超过一定阈值，则进行一次合并后将数据写到磁盘上。当所有数据拷贝完毕后，Reduce Task统一对内存和磁盘上的所有数据进行一次合并。</p> <p>每个阶段的默认排序：</p> <p><strong>1）排序的分类：</strong></p> <p>​	（1）部分排序：</p> <p>MapReduce根据输入记录的键对数据集排序。保证输出的每个文件内部排序。</p> <p>​	（2）全排序：</p> <p>如何用Hadoop产生一个全局排序的文件？最简单的方法是使用一个分区。但该方法在处理大型文件时效率极低，因为一台机器必须处理所有输出文件，从而完全丧失了MapReduce所提供的并行架构。</p> <p>​	替代方案：首先创建一系列排好序的文件；其次，串联这些文件；最后，生成一个全局排序的文件。主要思路是使用一个分区来描述输出的全局排序。例如：可以为上述文件创建3个分区，在第一分区中，记录的单词首字母a-g，第二分区记录单词首字母h-n, 第三分区记录单词首字母o-z。</p> <p>（3）辅助排序：（GroupingComparator分组）</p> <p>​	Mapreduce框架在记录到达reducer之前按键对记录排序，但键所对应的值并没有被排序。甚至在不同的执行轮次中，这些值的排序也不固定，因为它们来自不同的map任务且这些map任务在不同轮次中完成时间各不相同。一般来说，大多数MapReduce程序会避免让reduce函数依赖于值的排序。但是，有时也需要通过特定的方法对键进行排序和分组等以实现对值的排序。</p> <p>​	（4）二次排序：</p> <p>​	在自定义排序过程中，如果compareTo中的判断条件为两个即为二次排序。</p> <p><strong>2）自定义排序WritableComparable</strong></p> <p>bean对象实现WritableComparable接口重写compareTo方法，就可以实现排序</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">FlowBean</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 倒序排列，从大到小</span>
	<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sumFlow <span class="token operator">&gt;</span> o<span class="token punctuation">.</span><span class="token function">getSumFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="groupingcomparator"><a href="#groupingcomparator" aria-hidden="true" class="header-anchor">#</a> <strong>GroupingComparator</strong></h3> <p>对reduce阶段的数据根据某一个或几个字段进行分组。</p> <h3 id="combiner合并"><a href="#combiner合并" aria-hidden="true" class="header-anchor">#</a> <strong>Combiner</strong>合并</h3> <p>1）combiner是MR程序中Mapper和Reducer之外的一种组件</p> <p>2）combiner组件的父类就是Reducer</p> <p>3）combiner和reducer的区别在于运行的位置：</p> <ul><li><p>Combiner是在每一个maptask所在的节点运行</p></li> <li><p>Reducer是接收全局所有Mapper的输出结果；</p></li></ul> <p>4）combiner的意义就是对每一个maptask的输出进行局部汇总，以减小网络传输量</p> <p>5）自定义Combiner实现步骤：</p> <p>（1）自定义一个combiner继承Reducer，重写reduce方法</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WordcountCombiner</span> <span class="token keyword">extends</span> <span class="token class-name">Reducer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">IntWritable</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">IntWritable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">reduce</span><span class="token punctuation">(</span><span class="token class-name">Text</span> key<span class="token punctuation">,</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">IntWritable</span><span class="token punctuation">&gt;</span></span> values<span class="token punctuation">,</span>
			<span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
		<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">IntWritable</span> v <span class="token operator">:</span>values<span class="token punctuation">)</span><span class="token punctuation">{</span>
			count <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">IntWritable</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>（2）在job驱动类中设置：</p> <div class="language-java extra-class"><pre class="language-java"><code> job<span class="token punctuation">.</span><span class="token function">setCombinerClass</span><span class="token punctuation">(</span><span class="token class-name">WordcountCombiner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div><p>6）combiner能够应用的前提是不能影响最终的业务逻辑，而且，combiner的输出kv应该跟reducer的输入kv类型要对应起来</p> <div class="language- extra-class"><pre class="language-text"><code>Mapper

3 5 7 -&gt;(3+5+7)/3=5 

2 6 -&gt;(2+6)/2=4

Reducer

(3+5+7+2+6)/5=23/5    不等于    (5+4)/2=9/2
</code></pre></div><h3 id="数据倾斜"><a href="#数据倾斜" aria-hidden="true" class="header-anchor">#</a> 数据倾斜</h3> <p>1）数据倾斜原因</p> <p>如果是多张表的操作都是在reduce阶段完成，reduce端的处理压力太大，map节点的运算负载则很低，资源利用率不高，且在reduce阶段极易产生数据倾斜。</p> <p>2）解决方案</p> <p>在map端缓存多张表，提前处理业务逻辑，这样增加map端业务，减少reduce端数据的压力，尽可能的减少数据倾斜。</p> <p>3）具体办法：采用distributedcache</p> <p>​	（1）<strong>在mapper的setup阶段，将文件读取到缓存集合中</strong></p> <p>​	（2）在驱动函数中加载缓存。</p> <div class="language-java extra-class"><pre class="language-java"><code>job<span class="token punctuation">.</span><span class="token function">addCacheFile</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">URI</span><span class="token punctuation">(</span><span class="token string">&quot;file:/e:/mapjoincache/pd.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 缓存普通文件到task运行节点</span>
</code></pre></div><h2 id="reducetask工作机制"><a href="#reducetask工作机制" aria-hidden="true" class="header-anchor">#</a> ReduceTask工作机制</h2> <p>1）设置ReduceTask</p> <p>reducetask的并行度同样影响整个job的执行并发度和执行效率，但与maptask的并发数由切片数决定不同，<strong>Reducetask数量的决定是可以直接手动设置</strong>：</p> <div class="language-java extra-class"><pre class="language-java"><code> <span class="token comment">//默认值是1，手动设置为4 </span>
job<span class="token punctuation">.</span><span class="token function">setNumReduceTasks</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div><p>2）注意</p> <p>（1）reducetask=0	，表示没有reduce阶段，输出文件个数和map个数一致。</p> <p>（2）reducetask默认值就是1，所以输出文件个数为一个。</p> <p>（3）如果数据分布不均匀，就有可能在reduce阶段产生数据倾斜</p> <p>（4）reducetask数量并不是任意设置，还要考虑业务逻辑需求，有些情况下，需要计算全局汇总结果，就只能有1个reducetask。</p> <p>（5）具体多少个reducetask，需要根据集群性能而定。</p> <p>（6）如果分区数不是1，但是reducetask为1，是否执行分区过程。答案是：不执行分区过程。因为在maptask的源码中，执行分区的前提是先判断reduceNum个数是否大于1。不大于1肯定不执行。</p> <p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g5acs31epaj31j10pkanu.jpg" alt="img"></p> <p>​	（1）Copy阶段：ReduceTask从各个MapTask上远程拷贝一片数据，并针对某一片数据，如果其大小超过一定阈值，则写到磁盘上，否则直接放到内存中。</p> <p>​	（2）Merge阶段：在远程拷贝数据的同时，ReduceTask启动了两个后台线程对内存和磁盘上的文件进行合并，以防止内存使用过多或磁盘上文件过多。</p> <p>​	（3）Sort阶段：按照MapReduce语义，用户编写reduce()函数输入数据是按key进行聚集的一组数据。为了将key相同的数据聚在一起，Hadoop采用了基于排序的策略。由于各个MapTask已经实现对自己的处理结果进行了局部排序，因此，ReduceTask只需对所有数据进行一次归并排序即可。</p> <p>​	（4）Reduce阶段：reduce()函数将计算结果写到HDFS上。</p> <h2 id="数据压缩"><a href="#数据压缩" aria-hidden="true" class="header-anchor">#</a> 数据压缩</h2> <h3 id="概述"><a href="#概述" aria-hidden="true" class="header-anchor">#</a> 概述</h3> <p>压缩技术能够有效减少底层存储系统（HDFS）读写字节数。压缩提高了网络带宽和磁盘空间的效率。在Hadood下，尤其是数据规模很大和工作负载密集的情况下，使用数据压缩显得非常重要。在这种情况下，I/O操作和网络数据传输要花大量的时间。还有，Shuffle与Merge过程同样也面临着巨大的I/O压力。</p> <p>鉴于磁盘I/O和网络带宽是Hadoop的宝贵资源，数据压缩对于节省资源、最小化磁盘I/O和网络传输非常有帮助。不过，尽管压缩与解压操作的CPU开销不高，其性能的提升和资源的节省并非没有代价。</p> <p>如果磁盘I/O和网络带宽影响了MapReduce作业性能，在任意MapReduce阶段启用压缩都可以改善端到端处理时间并减少I/O和网络流量。</p> <p>压缩<strong>mapreduce</strong>的一种优化策略：通过压缩编码对<strong>mapper</strong>或者<strong>reducer</strong>的输出进行压缩，以减少磁盘<strong>IO</strong>，提高MR程序运行速度（但相应增加了cpu运算负担）。</p> <p>注意：压缩特性运用得当能提高性能，但运用不当也可能降低性能。</p> <p>基本原则：</p> <p>（1）运算密集型的job，少用压缩</p> <p>（2）IO密集型的job，多用压缩</p> <h3 id="支持的压缩编码"><a href="#支持的压缩编码" aria-hidden="true" class="header-anchor">#</a> 支持的压缩编码</h3> <table><thead><tr><th>压缩格式</th> <th>工具</th> <th>算法</th> <th>文件扩展名</th> <th>是否可切分</th></tr></thead> <tbody><tr><td>DEFAULT</td> <td>无</td> <td>DEFAULT</td> <td>.deflate</td> <td>否</td></tr> <tr><td>Gzip</td> <td>gzip</td> <td>DEFAULT</td> <td>.gz</td> <td>否</td></tr> <tr><td>bzip2</td> <td>bzip2</td> <td>bzip2</td> <td>.bz2</td> <td>是</td></tr> <tr><td>LZO</td> <td>lzop</td> <td>LZO</td> <td>.lzo</td> <td>否</td></tr> <tr><td>LZ4</td> <td>无</td> <td>LZ4</td> <td>.lz4</td> <td>否</td></tr> <tr><td>Snappy</td> <td>无</td> <td>Snappy</td> <td>.snappy</td> <td>否</td></tr></tbody></table> <p>为了支持多种压缩/解压缩算法，Hadoop引入了编码/解码器，如下表所示</p> <table><thead><tr><th>压缩格式</th> <th>对应的编码/解码器</th></tr></thead> <tbody><tr><td>DEFLATE</td> <td>org.apache.hadoop.io.compress.DefaultCodec</td></tr> <tr><td>gzip</td> <td>org.apache.hadoop.io.compress.GzipCodec</td></tr> <tr><td>bzip2</td> <td>org.apache.hadoop.io.compress.BZip2Codec</td></tr> <tr><td>LZO</td> <td>com.hadoop.compression.lzo.LzopCodec</td></tr> <tr><td>LZ4</td> <td>org.apache.hadoop.io.compress.Lz4Codec</td></tr> <tr><td>Snappy</td> <td>org.apache.hadoop.io.compress.SnappyCodec</td></tr></tbody></table> <h3 id="压缩性能的比较"><a href="#压缩性能的比较" aria-hidden="true" class="header-anchor">#</a> 压缩性能的比较</h3> <table><thead><tr><th>压缩算法</th> <th>原始文件大小</th> <th>压缩文件大小</th> <th>压缩速度</th> <th>解压速度</th></tr></thead> <tbody><tr><td>gzip</td> <td>8.3GB</td> <td>1.8GB</td> <td>17.5MB/s</td> <td>58MB/s</td></tr> <tr><td>bzip2</td> <td>8.3GB</td> <td>1.1GB</td> <td>2.4MB/s</td> <td>9.5MB/s</td></tr> <tr><td>LZO</td> <td>8.3GB</td> <td>2.9GB</td> <td>49.3MB/s</td> <td>74.6MB/s</td></tr></tbody></table> <p>http://google.github.io/snappy/</p> <p>On a single core of a Core i7 processor in 64-bit mode, Snappy compresses at about 250 MB/sec or more and decompresses at about 500 MB/sec or more.</p> <h3 id="常见几种压缩算法"><a href="#常见几种压缩算法" aria-hidden="true" class="header-anchor">#</a> 常见几种压缩算法</h3> <p><strong>Gzip压缩</strong></p> <p>​    优点：压缩率比较高，而且压缩/解压速度也比较块：hadoop本身支持，在应用中处理gzip格式的文件就和直接处理文本一样；大部分linux系统都自带gzip命令，使用方便。</p> <p>​    缺点：不支持分区（split）</p> <p>​    应用场景：每当文件压缩之后在130m以内的，都可以考虑用Gzip压缩格式，hive程序，Streaming程序和java写的MapReduce程序完全和文本处理一样，压缩之后原来的程序不需要做任何修改。</p> <p><strong>Bzip2压缩</strong></p> <p>​    优点：支持Split，具有很高的压缩率，比Gzip压缩率都高，hadoop本身支持，但不支持native，在linux系统下自带bzip2命令，使用方便。</p> <p>​    缺点：压缩、解压速度慢，不支持native</p> <p>​    应用场景：适合对速度要求不高，但需求较高的压缩率的时候，可以作为MapReduce作业的输出格式，或者输出之后的数据比较大，处理之后的数据需要压缩文档减少磁盘空间并且以后数据用的比较少的情况，或者对单个很大的文本文件想要压缩减少存储空间，同时又需要支持split，而且兼容之前的应用程序的情况。</p> <p><strong>Lzo压缩</strong></p> <p>​    优点：压缩/解压速度也比较快，合理的压缩率，支持split，是hadoop中最流行的压缩格式，可以在linux系统下安装lzop命令，使用方便。</p> <p>​    缺点：压缩比例比gzip要低一些，hadoop本身并不支持，需要安装，在应用中对lzo格式的文件需要做一些特殊处理。（为了支持split需要建立索引，还需要指定inputformat为lzo格式）</p> <p>​    应用场景：一个很大的文本文件，压缩之后还大于200m以上的可以考虑，而且单个文件越大，lzo优点越明显。</p> <p><strong>Snappy压缩</strong></p> <p>​    优点：高速压缩速度和合理的压缩率</p> <p>​    缺点：不支持Split，压缩率比gzip低，hadoop本身不支持</p> <p>​    应用场景：当MapReduce作业的Map输出的数据比较大的时候，作为Map到Reduce的中间数据的压缩格式，或者作为一个MapReduce作业的输出和另外一个MapReduce作业的输入</p> <h3 id="采用压缩的位置"><a href="#采用压缩的位置" aria-hidden="true" class="header-anchor">#</a> 采用压缩的位置</h3> <p>压缩可以在MapReduce作用的任意阶段启用。</p> <p>1）输入压缩：</p> <p>​	在有大量数据并计划重复处理的情况下，应该考虑对输入进行压缩。然而，你无须显示指定使用的编解码方式。Hadoop自动检查文件扩展名，如果扩展名能够匹配，就会用恰当的编解码方式对文件进行压缩和解压。否则，Hadoop就不会使用任何编解码器。</p> <p>2）压缩mapper输出：</p> <p>当map任务输出的中间数据量很大时，应考虑在此阶段采用压缩技术。这能显著改善内部数据Shuffle过程，而Shuffle过程在Hadoop处理过程中是资源消耗最多的环节。如果发现数据量大造成网络传输缓慢，应该考虑使用压缩技术。可用于压缩mapper输出的快速编解码器包括LZO、LZ4或者Snappy。</p> <p>​	注：LZO是供Hadoop压缩数据用的通用压缩编解码器。其设计目标是达到与硬盘读取速度相当的压缩速度，因此速度是优先考虑的因素，而不是压缩率。与gzip编解码器相比，它的压缩速度是gzip的5倍，而解压速度是gzip的2倍。同一个文件用LZO压缩后比用gzip压缩后大50%，但比压缩前小25%~50%。这对改善性能非常有利，map阶段完成时间快4倍。</p> <p>3）压缩reducer输出：</p> <p>​	在此阶段启用压缩技术能够减少要存储的数据量，因此降低所需的磁盘空间。当mapreduce作业形成作业链条时，因为第二个作业的输入也已压缩，所以启用压缩同样有效。</p> <h3 id="压缩配置参数"><a href="#压缩配置参数" aria-hidden="true" class="header-anchor">#</a> 压缩配置参数</h3> <p>在Hadoop中启用压缩，可以配置以下参数（mapred-site.xml文件中）：</p> <table><thead><tr><th>参数</th> <th>默认值</th> <th>阶段</th></tr></thead> <tbody><tr><td>io.compression.ccodecs</td> <td>org.apache.hadoop.io.compress.DefaultCodec, org.apache.hadoop.io.compress.GzipCodec, org.apache.hadoop.io.compress.Lz4Codec,   org.apache.hadoop.io.compress.BZip2Codec,</td> <td>输入压缩</td></tr> <tr><td>mapreduce.map.output.compress</td> <td>false</td> <td>mapper输出</td></tr> <tr><td>mapreduce.map.output.compress.codec</td> <td>org.apache.hadoop.io.compress.DefaultCodec</td> <td>mapper输出</td></tr> <tr><td>mapreduce.output.fileoutputformat.compress.codec</td> <td>org.apache.hadoop.io.compress.DefaultCodec</td> <td>reducer输出</td></tr> <tr><td>mapreduce.output.fileoutputformat.compress.type</td> <td>RECORD</td> <td>reducer输出</td></tr></tbody></table> <h3 id="压缩、解压缩实例"><a href="#压缩、解压缩实例" aria-hidden="true" class="header-anchor">#</a> 压缩、解压缩实例</h3> <p>CompressionCodec有两个方法可以用于轻松地压缩或解压缩数据。要想对正在被写入一个输出流的数据进行压缩，我们可以使用createOutputStream（OutputStreamout）方法创建一个CompressionOutputStream,将其以压缩格式写入低层的流。相反，想要对输入流读取而来的数据进行解压缩，则需要调用createInputStream(InputStreamin)函数，从而获取一个CompressionInputStream，从而从低层的流读取未压缩的数据。</p> <h2 id="优化"><a href="#优化" aria-hidden="true" class="header-anchor">#</a> 优化</h2> <h3 id="mr跑的慢的原因"><a href="#mr跑的慢的原因" aria-hidden="true" class="header-anchor">#</a> MR跑的慢的原因</h3> <p>Mapreduce 程序效率的瓶颈在于两点：</p> <p>1）计算机性能</p> <p>​	CPU、内存、磁盘健康、网络</p> <p>2）I/O 操作优化</p> <p>（1）数据倾斜</p> <p>（2）map和reduce数设置不合理</p> <p>（3）reduce等待过久</p> <p>（4）小文件过多</p> <p>（5）大量的不可分块的超大文件</p> <p>（6）spill次数过多</p> <p>（7）merge次数过多等。</p> <h3 id="mr优化方法"><a href="#mr优化方法" aria-hidden="true" class="header-anchor">#</a> MR优化方法</h3> <h4 id="_1）数据输入"><a href="#_1）数据输入" aria-hidden="true" class="header-anchor">#</a> <strong>1</strong>）数据输入</h4> <p>（1）合并小文件：在执行mr任务前将小文件进行合并，大量的小文件会产生大量的map任务，增大map任务装载次数，而任务的装载比较耗时，从而导致 mr 运行较慢。</p> <p>（2）采用ConbinFileInputFormat来作为输入，解决输入端大量小文件场景。</p> <p>map task的启动数量也和下面这几个参数有关系：</p> <div class="language- extra-class"><pre class="language-text"><code>mapred.min.split.size：Input Split的最小值 默认值1
mapred.max.split.size：Input Split的最大值
dfs.block.size：HDFS 中一个block大小，默认值128MB
</code></pre></div><p>当mapred.min.split.size小于dfs.block.size的时候，一个block会被分为多个分片，也就是对应多个map task</p> <p>当mapred.min.split.size大于dfs.block.size的时候，一个分片可能对应多个block，也就是一个map task读取多个block数据</p> <p>（3）选择合理的Writable类型。为应用程序处理的数据选择合适的Writable类型可大大提升性能。 比如处理整数类型数据时，直接采用IntWritable比先以Text类型读入在转换为整数类型要高效。</p> <p>（4）增加输入文件的副本数，就是充分利用本地读</p> <p>（5）集群的网络、IO等性能很好的时候，建议调高block块大小：dfs.block.size。</p> <p>（6）采用数据压缩的方式，减少网络IO的的时间。安装Snappy和LZOP压缩编码器。</p> <p>（7）使用SequenceFile二进制文件</p> <h4 id="_2）map阶段"><a href="#_2）map阶段" aria-hidden="true" class="header-anchor">#</a> <strong>2</strong>）<strong>map</strong>阶段</h4> <p>（1）减少spill次数：通过调整io.sort.mb及sort.spill.percent参数值，增大触发spill的内存上限，减少spill次数，从而减少磁盘 IO。</p> <p>（2）减少merge次数：通过调整io.sort.factor参数，增大merge的文件数目，减少merge的次数，从而缩短mr处理时间。</p> <p>（3）在 map 之后先进行combine处理，减少 I/O。</p> <p>我们知道如果map side设置了Combiner，那么会根据设定的函数对map输出的数据进行一次类reduce的预处理</p> <p>但是和分组、排序分组不一样的是，combine发生的阶段可能是在merge之前，也可能是在merge之后</p> <p>这个时机可以由一个参数控制：min.num.spill.for.combine，默认值为3</p> <p>当job中设定了combiner，并且spill数最少有3个的时候，那么combiner函数就会在merge产生结果文件之前运行</p> <p>例如，产生的spill非常多，虽然我们可以通过merge阶段的io.sort.factor进行优化配置，但是在此之前我们还可以通过先执行combine对结果进行处理之后再对数据进行merge ，这样一来，到merge阶段的数据量将会进一步减少，IO开销也会被降到最低输出中间数据到磁盘</p> <p>（4）提高map输出的Buffer</p> <p>该阶段是map side中将结果输出到磁盘之前的一个处理方式，通过对其进行设置的话可以减少map任务的IO开销，从而提高性能。</p> <p>由于map任务运行时中间结果首先存储在buffer中,默认当缓存的使用量达到80%的时候就开始写入磁盘,这个过程叫做spill(溢出)</p> <p>这个buffer默认的大小是100M可以通过设定io.sort.mb的值来进行调整</p> <p>当map产生的数据非常大时，如果默认的buffer大小不够看，那么势必会进行非常多次的spill，进行spill就意味着要写磁盘，产生IO开销 ，这时候就可以把io.sort.mb调大，那么map在整个计算过程中spill的次数就势必会降低，map task对磁盘的操作就会变少</p> <p>如果map tasks的瓶颈在磁盘上，这样调整就会大大提高map的计算性能，但是如果将io.sort.mb调的非常大的时候，对机器的配置要求就非常高，因为占用内存过大，所以需要根据情况进行配置</p> <p>map并不是要等到buffer全部写满时才进行spill，因为如果全部写满了再去写spill，势必会造成map的计算部分等待buffer释放空间的情况。</p> <p>所以，map其实是当buffer被写满到一定程度（比如80%）时，才开始进行spill</p> <p>可以通过设置io.sort.spill.percent的值来调整这个阈值</p> <p>这个参数同样也是影响spill频繁程度，进而影响map task运行周期对磁盘的读写频率，但是通常情况下只需要对io.sort.mb进行调整即可</p> <p>（5）合理的开启map压缩</p> <p>其实无论是spill的时候，还是最后merge产生的结果文件，都是可以压缩的</p> <p>压缩的好处在于，通过压缩减少写入读出磁盘的数据量。对中间结果非常大，磁盘速度成为map执行瓶颈的job，尤其有用</p> <p>控制输出是否使用压缩的参数是mapred.compress.map.output，值为true或者false</p> <p>启用压缩之后，会牺牲CPU的一些计算资源，但是可以节省IO开销，非常适合IO密集型的作业（如果是CPU密集型的作业不建议设置）</p> <p>设置压缩的时候，我们可以选择不同的压缩算法</p> <p>Hadoop默认提供了GzipCodec，LzoCodec，BZip2Codec，LzmaCodec等压缩格式</p> <p>通常来说，想要达到比较平衡的cpu和磁盘压缩比，LzoCodec比较合适，但也要取决于job的具体情况</p> <p>如果想要自行选择中间结果的压缩算法，可以设置配置参数：</p> <div class="language- extra-class"><pre class="language-text"><code>//或者其他用户自行选择的压缩方式
mapred.map.output.compression.codec=org.apache.hadoop.io.compress.DefaultCodec
</code></pre></div><p>map端调优的相关参数：</p> <div class="language- extra-class"><pre class="language-text"><code>选项	默认值	描述
mapred.min.split.size		1	Input Split的最小值
mapred.max.split.size			Input Split的最大值
io.sort.mb		100	map缓冲区大小
io.sort.spill.percent		0.8	缓冲区阈值
io.sort.factor		10	并行处理spill的个数
min.num.spill.for.combine		3	最少有多少个spill的时候combine在merge之前进行
mapred.compress.map.output		false	map中间数据是否采用压缩
mapred.map.output.compression.codec		压缩算法
</code></pre></div><h4 id="_3）reduce阶段"><a href="#_3）reduce阶段" aria-hidden="true" class="header-anchor">#</a> <strong>3</strong>）<strong>reduce</strong>阶段</h4> <p>（1）合理设置map和reduce数：两个都不能设置太少，也不能设置太多。太少，会导致task等待，延长处理时间；太多，会导致 map、reduce任务间竞争资源，造成处理超时等错误。</p> <p>（2）设置map、reduce共存：调整slowstart.completedmaps参数，使map运行到一定程度后，reduce也开始运行，减少reduce的等待时间。</p> <p>（3）Shuffle阶段优化。</p> <ul><li>设置并行拷贝线程数：mapred.reduce.parallel.copies。</li> <li>设置merge的buffer大小，减小IO次数</li></ul> <p>控制该值的参数为：</p> <p>mapred.job.shuffle.input.buffer.percent，默认0.7，这是一个百分比，意思是reduce的可用内存中拿出70%作为buffer存放数据</p> <p>reduce的可用内存通过mapred.child.java.opts来设置，比如置为-Xmx1024m，该参数是同时设定map和reduce task的可用内存，一般为map buffer大小的两倍左右</p> <p>设置了reduce端的buffer大小，我们同样可以通过一个参数来控制buffer中的数据达到一个阈值的时候开始往磁盘写数据：mapred.job.shuffle.merge.percent，默认为0.66</p> <p>（4）合理设置reduc端的buffer，默认情况下，数据达到一个阈值的时候，buffer中的数据就会写入磁盘，然后reduce会从磁盘中获得所有的数据。也就是说，buffer和reduce是没有直接关联的，中间多个一个写磁盘-&gt;读磁盘的过程，既然有这个弊端，那么就可以通过参数来配置，使得buffer中的一部分数据可以直接输送到reduce，从而减少IO开销：mapred.job.reduce.input.buffer.percent，默认为0.0。当值大于0的时候，会保留指定比例的内存读buffer中的数据直接拿给reduce使用。这样一来，设置buffer需要内存，读取数据需要内存，reduce计算也要内存，所以要根据作业的运行情况进行调整。</p> <h4 id="_4）数据倾斜问题"><a href="#_4）数据倾斜问题" aria-hidden="true" class="header-anchor">#</a> <strong>4</strong>）数据倾斜问题</h4> <p>（1）数据倾斜现象</p> <p>​		数据频率倾斜——某一个区域的数据量要远远大于其他区域。</p> <p>​		数据大小倾斜——部分记录的大小远远大于平均值。</p> <p>（2）如何收集倾斜数据</p> <p>在reduce方法中加入记录map输出键的详细情况的功能。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> MAX_VALUES <span class="token operator">=</span> <span class="token string">&quot;skew.maxvalues&quot;</span><span class="token punctuation">;</span> 
<span class="token keyword">private</span> <span class="token keyword">int</span> maxValueThreshold<span class="token punctuation">;</span> 
 
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span><span class="token class-name">JobConf</span> job<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
     maxValueThreshold <span class="token operator">=</span> job<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span>MAX_VALUES<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reduce</span><span class="token punctuation">(</span><span class="token class-name">Text</span> key<span class="token punctuation">,</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span><span class="token punctuation">&gt;</span></span> values<span class="token punctuation">,</span>
                     <span class="token class-name">OutputCollector</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">&gt;</span></span> output<span class="token punctuation">,</span> 
                     <span class="token class-name">Reporter</span> reporter<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
     <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
     <span class="token keyword">while</span> <span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         values<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         i<span class="token operator">++</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>i <span class="token operator">&gt;</span> maxValueThreshold<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;Received &quot;</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">&quot; values for key &quot;</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>（3）减少数据倾斜的方法</p> <p>方法<strong>1</strong>：抽样和范围分区。可以通过对原始数据进行抽样得到的结果集来预设分区边界值。</p> <p>方法<strong>2</strong>：自定义分区</p> <p>另一个抽样和范围分区的替代方案是基于输出键的背景知识进行自定义分区。例如，如果map输出键的单词来源于一本书。其中大部分必然是省略词（stopword）。那么就可以将自定义分区将这部分省略词发送给固定的一部分reduce实例。而将其他的都发送给剩余的reduce实例。</p> <p>方法<strong>3</strong>：<strong>Combine</strong></p> <p>使用Combine可以大量地减小数据频率倾斜和数据大小倾斜。在可能的情况下，combine的目的就是聚合并精简数据。</p> <p>reduce调优主要参数：</p> <div class="language- extra-class"><pre class="language-text"><code>选项		默认值	描述
mapred.reduce.parallel.copies		5	每个reduce去map中拿数据的并行数
mapred.reduce.copy.backoff		300	获取map数据最大超时时间
mapred.job.shuffle.input.buffer.percent		0.7	buffer大小占reduce可用内存的比例
mapred.child.java.opts		-Xmx1024m  设置reduce可用内存为1g
mapred.job.shuffle.merge.percent		0.66	buffer中的数据达到多少比例开始写入磁盘
mapred.job.reduce.input.buffer.percent		0.0	指定多少比例的内存用来存放buffer中的数据
</code></pre></div><h3 id="hdfs小文件优化"><a href="#hdfs小文件优化" aria-hidden="true" class="header-anchor">#</a> <strong>HDFS</strong>小文件优化</h3> <p>1）HDFS小文件弊端：</p> <p>HDFS上每个文件都要在namenode上建立一个索引，这个索引的大小约为150byte，这样当小文件比较多的时候，就会产生很多的索引文件，一方面会大量占用namenode的内存空间，另一方面就是索引文件过大是的索引速度变慢。</p> <p>2）解决的方式：</p> <p>（1）Hadoop本身提供了一些文件压缩的方案。</p> <p>（2）从系统层面改变现有HDFS存在的问题，其实主要还是小文件的合并，然后建立比较快速的索引。</p> <p>3）Hadoop自带小文件解决方案</p> <p>（1）Hadoop Archive:</p> <p>​     是一个高效地将小文件放入HDFS块中的文件存档工具，它能够将多个小文件打包成一个HAR文件，这样在减少namenode内存使用的同时。</p> <p>（2）Sequence file：</p> <p>​     sequence file由一系列的二进制key/value组成，如果为key小文件名，value为文件内容，则可以将大批小文件合并成一个大文件。</p> <p>（3）CombineFileInputFormat：</p> <p>​     CombineFileInputFormat是一种新的inputformat，用于将多个文件合并成一个单独的split，另外，它会考虑数据的存储位置。</p> <p>4）小文件优化(实战经验)</p> <p>对于大量小文件Job，可以开启JVM重用会减少45%运行时间。</p> <p>JVM重用理解：一个map运行一个jvm，重用的话，在一个map在jvm上运行完毕后，jvm继续运行其他jvm</p> <p>具体设置：mapreduce.job.jvm.numtasks值在10-20之间。</p> <h2 id="面试"><a href="#面试" aria-hidden="true" class="header-anchor">#</a> 面试</h2> <ul><li><p>Map 阶段map数量生成原理</p> <p>取决于文件时和块大小，默认块为128M，将每个文件按照128M切分，算出分区个数</p></li> <li><p>Map阶段map数据读取过程介绍</p></li> <li><p>Map阶段map写数据过程介绍</p></li> <li><p>Reduce阶段shullfe过程介绍</p></li> <li><p>Map阶段可优化参数介绍</p></li> <li><p>Reduce阶段可优化参数介绍</p></li> <li><p>Mapreduce的优点和缺陷</p></li> <li><p>Mapreduce数据倾斜及解决方案</p></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/wiki/hadoop/hadoop-3-hdfs.html" class="prev">
          HDFS
        </a></span> <span class="next"><a href="/wiki/hadoop/hadoop-5-Yarn.html">
          Yarn
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/wiki/assets/js/app.dd178f5a.js" defer></script><script src="/wiki/assets/js/2.9f273a62.js" defer></script><script src="/wiki/assets/js/23.87ecfe73.js" defer></script>
  </body>
</html>
