(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{191:function(e,a,s){"use strict";s.r(a);var t=s(0),r=Object(t.a)({},function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"docker镜像"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker镜像","aria-hidden":"true"}},[e._v("#")]),e._v(" Docker镜像")]),e._v(" "),s("p",[e._v("我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 "),s("code",[e._v("root")]),e._v(" 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 "),s("code",[e._v("root")]),e._v(" 文件系统。比如官方镜像 "),s("code",[e._v("ubuntu:16.04")]),e._v(" 就包含了完整的一套 Ubuntu 16.04 最小系统的 "),s("code",[e._v("root")]),e._v(" 文件系统。")]),e._v(" "),s("p",[e._v("Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。")]),e._v(" "),s("h2",{attrs:{id:"分层存储"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分层存储","aria-hidden":"true"}},[e._v("#")]),e._v(" 分层存储")]),e._v(" "),s("p",[e._v("因为镜像包含操作系统完整的 "),s("code",[e._v("root")]),e._v(" 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 "),s("a",{attrs:{href:"https://en.wikipedia.org/wiki/Union_mount",target:"_blank",rel:"noopener noreferrer"}},[e._v("Union FS"),s("OutboundLink")],1),e._v(" 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。")]),e._v(" "),s("p",[e._v("镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。")]),e._v(" "),s("p",[e._v("分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。")]),e._v(" "),s("h2",{attrs:{id:"使用镜像"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用镜像","aria-hidden":"true"}},[e._v("#")]),e._v(" 使用镜像")]),e._v(" "),s("p",[e._v("Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。")]),e._v(" "),s("h3",{attrs:{id:"获取镜像"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#获取镜像","aria-hidden":"true"}},[e._v("#")]),e._v(" 获取镜像")]),e._v(" "),s("p",[e._v("当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 "),s("code",[e._v("docker pull")]),e._v(" 命令来下载它。")]),e._v(" "),s("p",[e._v("从 Docker 镜像仓库获取镜像的命令是 "),s("code",[e._v("docker pull")]),e._v("。其命令格式为：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("docker pull "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("选项"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("Docker Registry 地址"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v(":端口号"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("/"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("仓库名"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v(":标签"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n")])])]),s("p",[e._v("具体的选项可以通过 "),s("code",[e._v("docker pull --help")]),e._v(" 命令看到，这里我们说一下镜像名称的格式。")]),e._v(" "),s("ul",[s("li",[e._v("Docker 镜像仓库地址：地址的格式一般是 "),s("code",[e._v("<域名/IP>[:端口号]")]),e._v("。默认地址是 Docker Hub。")]),e._v(" "),s("li",[e._v("仓库名：如之前所说，这里的仓库名是两段式名称，即 "),s("code",[e._v("<用户名>/<软件名>")]),e._v("。对于 Docker Hub，如果不给出用户名，则默认为 "),s("code",[e._v("library")]),e._v("，也就是官方镜像。")])]),e._v(" "),s("p",[e._v("比如：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker pull centos:7\nTrying to pull repository docker.io/library/centos\nbf5d46315322: Pull complete\n9f13e0ac480c: Pull complete\ne8988b5b3097: Pull complete\n40af181810e7: Pull complete\ne6f7c7e5c03e: Pull complete\nDigest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe\nStatus: Downloaded newer image "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("for")]),e._v(" centos:7\n")])])]),s("h3",{attrs:{id:"查找镜像"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#查找镜像","aria-hidden":"true"}},[e._v("#")]),e._v(" 查找镜像")]),e._v(" "),s("p",[e._v("我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： "),s("a",{attrs:{href:"https://hub.docker.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://hub.docker.com/\n"),s("OutboundLink")],1)]),e._v(" "),s("p",[e._v("我们也可以使用 "),s("code",[e._v("docker search")]),e._v(" 命令来搜索镜像。比如我们需要一个 "),s("code",[e._v("httpd")]),e._v(" 的镜像来作为我们的 "),s("code",[e._v("web")]),e._v(" 服务。我们可以通过 "),s("code",[e._v("docker search")]),e._v(" 命令搜索 "),s("code",[e._v("httpd")]),e._v(" 来寻找适合我们的镜像。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("docker search httpd\n")])])]),s("p",[e._v("说明：")]),e._v(" "),s("ul",[s("li",[e._v("NAME：镜像仓库源的名称")]),e._v(" "),s("li",[e._v("DESCRIPTION：镜像的描述")]),e._v(" "),s("li",[e._v("OFFICIAL：是否docker官方发布")])]),e._v(" "),s("h3",{attrs:{id:"运行容器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#运行容器","aria-hidden":"true"}},[e._v("#")]),e._v(" 运行容器")]),e._v(" "),s("p",[e._v("有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 "),s("code",[e._v("ubuntu:16.04")]),e._v(" 为例，如果我们打算启动里面的 "),s("code",[e._v("bash")]),e._v(" 并且进行交互式操作的话，可以执行下面的命令。")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker run -it --rm  centos "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("bash")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("root@8a6db8cb5df5 /"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# cat /etc/os-release")]),e._v("\nNAME"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"CentOS Linux"')]),e._v("\nVERSION"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"7 (Core)"')]),e._v("\nID"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"centos"')]),e._v("\nID_LIKE"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"rhel fedora"')]),e._v("\nVERSION_ID"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"7"')]),e._v("\nPRETTY_NAME"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"CentOS Linux 7 (Core)"')]),e._v("\nANSI_COLOR"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"0;31"')]),e._v("\nCPE_NAME"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"cpe:/o:centos:centos:7"')]),e._v("\nHOME_URL"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"https://www.centos.org/"')]),e._v("\nBUG_REPORT_URL"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"https://bugs.centos.org/"')]),e._v("\n\nCENTOS_MANTISBT_PROJECT"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"CentOS-7"')]),e._v("\nCENTOS_MANTISBT_PROJECT_VERSION"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"7"')]),e._v("\nREDHAT_SUPPORT_PRODUCT"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"centos"')]),e._v("\nREDHAT_SUPPORT_PRODUCT_VERSION"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"7"')]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("root@8a6db8cb5df5 /"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# exit")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("exit")]),e._v("\n")])])]),s("p",[s("code",[e._v("docker run")]),e._v(" 就是运行容器的命令，我们这里简要的说明一下上面用到的参数。")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("-it")]),e._v("：这是两个参数，一个是 "),s("code",[e._v("-i")]),e._v("：交互式操作，一个是 "),s("code",[e._v("-t")]),e._v(" 终端。我们这里打算进入 "),s("code",[e._v("bash")]),e._v(" 执行一些命令并查看返回结果，因此我们需要交互式终端。")]),e._v(" "),s("li",[s("code",[e._v("--rm")]),e._v("：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 "),s("code",[e._v("docker rm")]),e._v("。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 "),s("code",[e._v("--rm")]),e._v(" 可以避免浪费空间。")]),e._v(" "),s("li",[s("code",[e._v("centos")]),e._v("：这是指用 "),s("code",[e._v("centos")]),e._v(" 镜像为基础来启动容器。")]),e._v(" "),s("li",[s("code",[e._v("bash")]),e._v("：放在镜像名后的是"),s("strong",[e._v("命令")]),e._v("，这里我们希望有个交互式 Shell，因此用的是 "),s("code",[e._v("bash")]),e._v("。")])]),e._v(" "),s("p",[e._v("进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 "),s("code",[e._v("cat /etc/os-release")]),e._v("，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 "),s("code",[e._v("CentOS-7")]),e._v(" 系统。")]),e._v(" "),s("p",[e._v("最后我们通过 "),s("code",[e._v("exit")]),e._v(" 退出了这个容器。")]),e._v(" "),s("h3",{attrs:{id:"查看镜像"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#查看镜像","aria-hidden":"true"}},[e._v("#")]),e._v(" 查看镜像")]),e._v(" "),s("p",[e._v("要想列出已经下载下来的镜像，可以使用 "),s("code",[e._v("docker image ls")]),e._v(" 命令。")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker image "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v("\nREPOSITORY           TAG                 IMAGE ID            CREATED             SIZE\nredis            latest              3c41ce05add9        5 weeks ago         95 MB\nmysql            5.7                 a1aa4f76fab9        5 weeks ago         373 MB\ngitlab/gitlab-ce latest              fcc1e4187c43        5 weeks ago         1.85 GB\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("none"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("           "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("none"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("              00285df0df87        5 days ago          342 MB\n")])])]),s("p",[e._v("列表包含了 "),s("code",[e._v("仓库名")]),e._v("、"),s("code",[e._v("标签")]),e._v("、"),s("code",[e._v("镜像 ID")]),e._v("、"),s("code",[e._v("创建时间")]),e._v(" 以及 "),s("code",[e._v("所占用的空间")]),e._v("。")]),e._v(" "),s("p",[e._v("其中仓库名、标签在之前的基础概念章节已经介绍过了。"),s("strong",[e._v("镜像 ID")]),e._v(" 则是镜像的唯一标识，一个镜像可以对应多个"),s("strong",[e._v("标签")]),e._v("。")]),e._v(" "),s("h4",{attrs:{id:"镜像体积"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#镜像体积","aria-hidden":"true"}},[e._v("#")]),e._v(" 镜像体积")]),e._v(" "),s("p",[e._v("如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，"),s("code",[e._v("gitlab/gitlab-ce")]),e._v(" 镜像大小，在这里是 "),s("code",[e._v("1.85G")]),e._v("，但是在 "),s("a",{attrs:{href:"https://hub.docker.com/r/library/ubuntu/tags/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Docker Hub"),s("OutboundLink")],1),e._v(" 显示的却不到一个G。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 "),s("code",[e._v("docker image ls")]),e._v(" 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。")]),e._v(" "),s("p",[e._v("另外一个需要注意的问题是，"),s("code",[e._v("docker image ls")]),e._v(" 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。")]),e._v(" "),s("p",[e._v("你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker system "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("df")]),e._v("\nTYPE                TOTAL               ACTIVE              SIZE         RECLAIMABLE\nImages              19                  13                  10.39 GB      6.21 GB "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("59%"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\nContainers          15                  6                   975.9 MB      61.73 MB "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("6%"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\nLocal Volumes       17                  4                   1.199 GB      1.195 GB "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("99%"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),s("h4",{attrs:{id:"虚悬镜像"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚悬镜像","aria-hidden":"true"}},[e._v("#")]),e._v(" 虚悬镜像")]),e._v(" "),s("p",[e._v("上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 "),s("code",[e._v("<none>")]),e._v("：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("none"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("               "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("none"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("              00285df0df87        5 days ago          342 MB\n")])])]),s("p",[e._v("这个镜像原本是有镜像名和标签的，原来为 "),s("code",[e._v("mongo:3.2")]),e._v("，随着官方镜像维护，发布了新版本后，重新 "),s("code",[e._v("docker pull mongo:3.2")]),e._v(" 时，"),s("code",[e._v("mongo:3.2")]),e._v(" 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 "),s("code",[e._v("<none>")]),e._v("。除了 "),s("code",[e._v("docker pull")]),e._v(" 可能导致这种情况，"),s("code",[e._v("docker build")]),e._v(" 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 "),s("code",[e._v("<none>")]),e._v("的镜像。这类无标签镜像也被称为 "),s("strong",[e._v("虚悬镜像(dangling image)")]),e._v(" ，可以用下面的命令专门显示这类镜像：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker image "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v(" -f dangling"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("true\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("none"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("              "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("none"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("              00285df0df87        5 days ago          342 MB\n")])])]),s("p",[e._v("一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker image prune\n")])])]),s("h4",{attrs:{id:"中间层镜像"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#中间层镜像","aria-hidden":"true"}},[e._v("#")]),e._v(" 中间层镜像")]),e._v(" "),s("p",[e._v("为了加速镜像构建、重复利用资源，Docker 会利用 "),s("strong",[e._v("中间层镜像")]),e._v("。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 "),s("code",[e._v("docker image ls")]),e._v(" 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 "),s("code",[e._v("-a")]),e._v(" 参数。")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker image "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v(" -a\n")])])]),s("p",[e._v("这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。")]),e._v(" "),s("h4",{attrs:{id:"列出部分镜像"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#列出部分镜像","aria-hidden":"true"}},[e._v("#")]),e._v(" 列出部分镜像")]),e._v(" "),s("p",[e._v("不加任何参数的情况下，"),s("code",[e._v("docker image ls")]),e._v(" 会列出所有顶级镜像，但是有时候我们只希望列出部分镜像。"),s("code",[e._v("docker image ls")]),e._v(" 有好几个参数可以帮助做到这个事情。")]),e._v(" "),s("p",[e._v("根据仓库名列出镜像")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker image "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v(" centos\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\ndocker.io/centos    7                   9f38484d220f        4 months ago        202 MB\ndocker.io/centos    latest              9f38484d220f        4 months ago        202 MB\n")])])]),s("p",[e._v("列出特定的某个镜像，也就是说指定仓库名和标签")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker image "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v(" centos:7\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\ndocker.io/centos    7                   9f38484d220f        4 months ago        202 MB\n")])])]),s("p",[e._v("除此以外，"),s("code",[e._v("docker image ls")]),e._v(" 还支持强大的过滤器参数 "),s("code",[e._v("--filter")]),e._v("，或者简写 "),s("code",[e._v("-f")]),e._v("。之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 "),s("code",[e._v("mongo:3.2")]),e._v(" 之后建立的镜像，可以用下面的命令：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker image "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v(" -f since"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("centos\nREPOSITORY                          TAG                 IMAGE ID            CREATED             SIZE\ndocker.io/mongo                     latest              785c65f61380        12 days ago         412 MB\ndocker.io/gogs/gogs                 latest              7e516701539f        2 weeks ago         100 MB\n")])])]),s("p",[e._v("想查看某个位置之前的镜像也可以，只需要把 "),s("code",[e._v("since")]),e._v(" 换成 "),s("code",[e._v("before")]),e._v(" 即可。")]),e._v(" "),s("p",[e._v("此外，如果镜像构建时，定义了 "),s("code",[e._v("LABEL")]),e._v("，还可以通过 "),s("code",[e._v("LABEL")]),e._v(" 来过滤。")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker image "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v(" -f label"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("com.example.version"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("0.1\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("..")]),e._v(".\n")])])]),s("h4",{attrs:{id:"以特定格式显示"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#以特定格式显示","aria-hidden":"true"}},[e._v("#")]),e._v(" 以特定格式显示")]),e._v(" "),s("p",[e._v("默认情况下，"),s("code",[e._v("docker image ls")]),e._v(" 会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。比如，刚才删除虚悬镜像的时候，我们需要利用 "),s("code",[e._v("docker image ls")]),e._v(" 把所有的虚悬镜像的 ID 列出来，然后才可以交给 "),s("code",[e._v("docker image rm")]),e._v(" 命令作为参数来删除指定的这些镜像，这个时候就用到了 "),s("code",[e._v("-q")]),e._v(" 参数。")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker image "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v(" -q\n5f515359c7f8\n05a60462f8ba\nfe9198c04d62\n00285df0df87\nf753707788c5\nf753707788c5\n1e0c3dd64ccd\n")])])]),s("p",[s("code",[e._v("--filter")]),e._v(" 配合 "),s("code",[e._v("-q")]),e._v(" 产生出指定范围的 ID 列表，然后送给另一个 "),s("code",[e._v("docker")]),e._v(" 命令作为参数，从而针对这组实体成批的进行某种操作的做法在 Docker 命令行使用过程中非常常见，不仅仅是镜像，将来我们会在各个命令中看到这类搭配以完成很强大的功能。因此每次在文档看到过滤器后，可以多注意一下它们的用法。")]),e._v(" "),s("p",[e._v("另外一些时候，我们可能只是对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 "),s("a",{attrs:{href:"https://gohugo.io/templates/go-templates/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Go 的模板语法"),s("OutboundLink")],1),e._v("。")]),e._v(" "),s("p",[e._v("比如，下面的命令会直接列出镜像结果，并且只包含镜像ID和仓库名：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker image "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v(" --format "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"{{.ID}}: {{.Repository}}"')]),e._v("\n785c65f61380: docker.io/mongo\n7e516701539f: docker.io/gogs/gogs\ndb322a6c3b84: rabbitmq\n3e581a516dcd: kibana\n0efa6a3de177: elasticsearch\n3c41ce05add9: redis\na1aa4f76fab9: mysql\nfcc1e4187c43: gitlab/gitlab-ce\n37d98464f1bc: sonatype/nexus3\n9f38484d220f: docker.io/centos\n")])])]),s("p",[e._v("或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker image "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v(" --format "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"table {{.ID}}\\t{{.Repository}}\\t{{.Tag}}"')]),e._v("\nIMAGE ID            REPOSITORY                          TAG\n785c65f61380        docker.io/mongo                     latest\n7e516701539f        docker.io/gogs/gogs                 latest\ndb322a6c3b84        rabbitmq                            management\n3e581a516dcd        kibana                              7.2.0\n0efa6a3de177        elasticsearch                       7.2.0\n3c41ce05add9        redis                               latest\na1aa4f76fab9        mysql                               5.7\nfcc1e4187c43        gitlab/gitlab-ce                    latest\n37d98464f1bc        sonatype/nexus3                     latest\n9f38484d220f        docker.io/centos                    7\n")])])]),s("h3",{attrs:{id:"创建镜像"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建镜像","aria-hidden":"true"}},[e._v("#")]),e._v(" 创建镜像")]),e._v(" "),s("p",[e._v("当我们从 docker 镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改：")]),e._v(" "),s("ul",[s("li",[e._v("从已经创建的容器中更新镜像，并且提交这个镜像")]),e._v(" "),s("li",[e._v("使用 Dockerfile 指令来创建一个新的镜像")])]),e._v(" "),s("h3",{attrs:{id:"docker-commit更新镜像"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker-commit更新镜像","aria-hidden":"true"}},[e._v("#")]),e._v(" docker commit更新镜像")]),e._v(" "),s("p",[e._v("注意： "),s("code",[e._v("docker commit")]),e._v(" 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 "),s("code",[e._v("docker commit")]),e._v(" 定制镜像，定制镜像应该使用 "),s("code",[e._v("Dockerfile")]),e._v(" 来完成。如果你想要定制镜像请查看下一小节。")]),e._v(" "),s("p",[e._v("镜像是容器的基础，每次执行 "),s("code",[e._v("docker run")]),e._v(" 的时候都会指定哪个镜像作为容器运行的基础。在之前的例子中，我们所使用的都是来自于 Docker Hub 的镜像。直接使用这些镜像是可以满足一定的需求，而当这些镜像无法直接满足需求时，我们就需要定制这些镜像。接下来的几节就将讲解如何定制镜像。")]),e._v(" "),s("p",[e._v("回顾一下之前我们学到的知识，镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。")]),e._v(" "),s("p",[e._v("现在让我们以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker run --name webserver -d -p 80:80 nginx\n")])])]),s("p",[e._v("这条命令会用 "),s("code",[e._v("nginx")]),e._v(" 镜像启动一个容器，命名为 "),s("code",[e._v("webserver")]),e._v("，并且映射了 80 端口，这样我们可以用浏览器去访问这个 "),s("code",[e._v("nginx")]),e._v(" 服务器。")]),e._v(" "),s("p",[e._v("如果是在 Linux 本机运行的 Docker，或者如果使用的是 Docker for Mac、Docker for Windows，那么可以直接访问："),s("a",{attrs:{href:"http://localhost/",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://localhost"),s("OutboundLink")],1),e._v("；如果使用的是 Docker Toolbox，或者是在虚拟机、云服务器上安装的 Docker，则需要将 "),s("code",[e._v("localhost")]),e._v(" 换为虚拟机地址或者实际云服务器地址。")]),e._v(" "),s("p",[e._v("直接用浏览器访问的话，我们会看到默认的 Nginx 欢迎页面。")]),e._v(" "),s("p",[s("img",{attrs:{src:"http://ww4.sinaimg.cn/large/006tNc79gy1g59xaxmuw3j314e0o4abx.jpg",alt:"img"}})]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("exec")]),e._v(" -it webserver "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("bash")]),e._v("\nroot@3729b97e8226:/"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# echo '<h1>Hello, Docker!</h1>' > /usr/share/nginx/html/index.html")]),e._v("\nroot@3729b97e8226:/"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# exit")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("exit")]),e._v("\n")])])]),s("p",[e._v("我们以交互式终端方式进入 "),s("code",[e._v("webserver")]),e._v(" 容器，并执行了 "),s("code",[e._v("bash")]),e._v(" 命令，也就是获得一个可操作的 Shell。")]),e._v(" "),s("p",[e._v("然后，我们用 "),s("code",[e._v("<h1>Hello, Docker!</h1>")]),e._v(" 覆盖了 "),s("code",[e._v("/usr/share/nginx/html/index.html")]),e._v(" 的内容。")]),e._v(" "),s("p",[e._v("现在我们再刷新浏览器的话，会发现内容被改变了。")]),e._v(" "),s("p",[s("img",{attrs:{src:"http://ww4.sinaimg.cn/large/006tNc79gy1g59xayfkdfj314e0o4abx.jpg",alt:"img"}})]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("diff")]),e._v(" webserver\nC /root\nA /root/.bash_history\nC /run\nC /usr\nC /usr/share\nC /usr/share/nginx\nC /usr/share/nginx/html\nC /usr/share/nginx/html/index.html\nC /var\nC /var/cache\nC /var/cache/nginx\nA /var/cache/nginx/client_temp\nA /var/cache/nginx/fastcgi_temp\nA /var/cache/nginx/proxy_temp\nA /var/cache/nginx/scgi_temp\nA /var/cache/nginx/uwsgi_temp\n")])])]),s("p",[e._v("现在我们定制好了变化，我们希望能将其保存下来形成镜像。")]),e._v(" "),s("p",[e._v("要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 "),s("code",[e._v("docker commit")]),e._v(" 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。")]),e._v(" "),s("p",[s("code",[e._v("docker commit")]),e._v(" 的语法格式为：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("docker commit "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("选项"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("容器ID或容器名"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("仓库名"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v(":"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("标签"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n")])])]),s("p",[e._v("我们可以用下面的命令将容器保存为镜像：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker commit \\\n    --author "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"XXX <XXX@gmail.com>"')]),e._v(" \\\n    --message "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"修改了默认网页"')]),e._v(" \\\n    webserver \\\n    nginx:v2\nsha256:07e33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214\n")])])]),s("p",[e._v("其中 "),s("code",[e._v("--author")]),e._v(" 是指定修改的作者，而 "),s("code",[e._v("--message")]),e._v(" 则是记录本次修改的内容。这点和 "),s("code",[e._v("git")]),e._v(" 版本控制相似，不过这里这些信息可以省略留空。")]),e._v(" "),s("p",[e._v("我们可以在 "),s("code",[e._v("docker image ls")]),e._v(" 中看到这个新定制的镜像：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker image "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v(" nginx\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nnginx               v2                  07e334659748        9 seconds ago       181.5 MB\nnginx               1.11                05a60462f8ba        12 days ago         181.5 MB\nnginx               latest              e43d811ce2f4        4 weeks ago         181.5 MB\n")])])]),s("p",[e._v("我们还可以用 "),s("code",[e._v("docker history")]),e._v(" 具体查看镜像内的历史记录，如果比较 "),s("code",[e._v("nginx:latest")]),e._v(" 的历史记录，我们会发现新增了我们刚刚提交的这一层。")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("history")]),e._v(" nginx:v2\nIMAGE               CREATED             CREATED BY                                      SIZE                COMMENT\n07e334659748        54 seconds ago      nginx -g daemon off"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("                            95 B                修改了默认网页\ne43d811ce2f4        4 weeks ago         /bin/sh -c "),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('#(nop)  CMD ["nginx" "-g" "daemon    0 B')]),e._v("\n")])])]),s("p",[e._v("新的镜像定制好后，我们可以来运行这个镜像。")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("docker run --name web2 -d -p 81:80 nginx:v2\n")])])]),s("p",[e._v("这里我们命名为新的服务为 "),s("code",[e._v("web2")]),e._v("，并且映射到 "),s("code",[e._v("81")]),e._v(" 端口。如果是 Docker for Mac/Windows 或 Linux 桌面的话，我们就可以直接访问 "),s("a",{attrs:{href:"http://localhost:81/",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://localhost:81"),s("OutboundLink")],1),e._v(" 看到结果，其内容应该和之前修改后的 "),s("code",[e._v("webserver")]),e._v(" 一样。")]),e._v(" "),s("p",[e._v("至此，我们第一次完成了定制镜像，使用的是 "),s("code",[e._v("docker commit")]),e._v(" 命令，手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储应该有了更直观的感觉。")]),e._v(" "),s("h4",{attrs:{id:"慎用-docker-commit"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#慎用-docker-commit","aria-hidden":"true"}},[e._v("#")]),e._v(" 慎用 "),s("code",[e._v("docker commit")])]),e._v(" "),s("p",[e._v("使用 "),s("code",[e._v("docker commit")]),e._v(" 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。")]),e._v(" "),s("p",[e._v("首先，如果仔细观察之前的 "),s("code",[e._v("docker diff webserver")]),e._v(" 的结果，你会发现除了真正想要修改的 "),s("code",[e._v("/usr/share/nginx/html/index.html")]),e._v(" 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心清理，将会导致镜像极为臃肿。")]),e._v(" "),s("p",[e._v("此外，使用 "),s("code",[e._v("docker commit")]),e._v(" 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为"),s("strong",[e._v("黑箱镜像")]),e._v("，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。虽然 "),s("code",[e._v("docker diff")]),e._v(" 或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。")]),e._v(" "),s("p",[e._v("而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 "),s("code",[e._v("docker commit")]),e._v(" 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。")]),e._v(" "),s("h3",{attrs:{id:"设置镜像标签"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设置镜像标签","aria-hidden":"true"}},[e._v("#")]),e._v(" 设置镜像标签")]),e._v(" "),s("p",[e._v("我们可以使用 "),s("code",[e._v("docker tag")]),e._v(" 命令，为镜像添加一个新的标签。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("docker tag 598a6f110d01 docker.io/redis:dev\n")])])]),s("p",[s("code",[e._v("docker tag 镜像ID")]),e._v("，这里是 "),s("strong",[e._v("598a6f110d01")]),e._v(" ，用户名称、镜像源名(repository name)和新的标签名(tag)。")]),e._v(" "),s("p",[e._v("使用 "),s("code",[e._v("docker images")]),e._v(" 命令可以看到，ID为 "),s("strong",[e._v("598a6f110d01")]),e._v(" 的镜像多了一个标签。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("docker images\nREPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE\ndocker.io/redis                      dev                 598a6f110d01        9 days ago          118 MB\ndocker.io/redis                      latest              598a6f110d01        9 days ago          118 MB\n")])])]),s("h3",{attrs:{id:"删除本地镜像"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#删除本地镜像","aria-hidden":"true"}},[e._v("#")]),e._v(" 删除本地镜像")]),e._v(" "),s("p",[e._v("如果要删除本地的镜像，可以使用 "),s("code",[e._v("docker image rm")]),e._v(" 命令，其格式为：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker image "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("rm")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("选项"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("镜像1"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("镜像2"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("..")]),e._v("."),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n\n")])])]),s("p",[e._v("其中，"),s("code",[e._v("<镜像>")]),e._v(" 可以是 "),s("code",[e._v("镜像短 ID")]),e._v("、"),s("code",[e._v("镜像长 ID")]),e._v("、"),s("code",[e._v("镜像名")]),e._v(" 或者 "),s("code",[e._v("镜像摘要")]),e._v("。")]),e._v(" "),s("p",[e._v("比如我们有这么一些镜像：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker image "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v("\nREPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE\ncentos                      latest              0584b3d2cf6d        3 weeks ago         196.5 MB\nredis                       alpine              501ad78535f0        3 weeks ago         21.03 MB\ndocker                      latest              cf693ec9b5c7        3 weeks ago         105.1 MB\nnginx                       latest              e43d811ce2f4        5 weeks ago         181.5 MB\n\n")])])]),s("p",[e._v("我们可以用镜像的完整 ID，也称为 "),s("code",[e._v("长 ID")]),e._v("，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 "),s("code",[e._v("短 ID")]),e._v(" 来删除镜像。"),s("code",[e._v("docker image ls")]),e._v(" 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。")]),e._v(" "),s("p",[e._v("比如这里，如果我们要删除 "),s("code",[e._v("redis:alpine")]),e._v(" 镜像，可以执行：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker image "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("rm")]),e._v(" 501\nUntagged: redis:alpine\nUntagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86d\nDeleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7\nDeleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899b\nDeleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23\nDeleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2fa\nDeleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3\nDeleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7\n\n")])])]),s("p",[e._v("我们也可以用"),s("code",[e._v("镜像名")]),e._v("，也就是 "),s("code",[e._v("<仓库名>:<标签>")]),e._v("，来删除镜像。")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker image "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("rm")]),e._v(" centos\nUntagged: centos:latest\nUntagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c\nDeleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a\nDeleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38\n\n")])])]),s("p",[e._v("当然，更精确的是使用 "),s("code",[e._v("镜像摘要")]),e._v(" 删除镜像。")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker image "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v(" --digests\nREPOSITORY                  TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE\nnode                        slim                sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228   6e0c4c8e3913        3 weeks ago         214 MB\n\n$ docker image "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("rm")]),e._v(" node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228\nUntagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228\n")])])]),s("h4",{attrs:{id:"untagged-和-deleted"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#untagged-和-deleted","aria-hidden":"true"}},[e._v("#")]),e._v(" Untagged 和 Deleted")]),e._v(" "),s("p",[e._v("如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 "),s("code",[e._v("Untagged")]),e._v("，另一类是 "),s("code",[e._v("Deleted")]),e._v("。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。")]),e._v(" "),s("p",[e._v("因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 "),s("code",[e._v("Untagged")]),e._v(" 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 "),s("code",[e._v("Delete")]),e._v(" 行为就不会发生。所以并非所有的 "),s("code",[e._v("docker image rm")]),e._v(" 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。")]),e._v(" "),s("p",[e._v("当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变动非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 "),s("code",[e._v("docker pull")]),e._v(" 看到的层数不一样的源。")]),e._v(" "),s("p",[e._v("除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。")]),e._v(" "),s("h4",{attrs:{id:"用-docker-image-ls-命令来配合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#用-docker-image-ls-命令来配合","aria-hidden":"true"}},[e._v("#")]),e._v(" 用 docker image ls 命令来配合")]),e._v(" "),s("p",[e._v("像其它可以承接多个实体的命令一样，可以使用 "),s("code",[e._v("docker image ls -q")]),e._v(" 来配合使用 "),s("code",[e._v("docker image rm")]),e._v("，这样可以成批的删除希望删除的镜像。我们在“镜像列表”章节介绍过很多过滤镜像列表的方式都可以拿过来使用。")]),e._v(" "),s("p",[e._v("比如，我们需要删除所有仓库名为 "),s("code",[e._v("redis")]),e._v(" 的镜像：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker image "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("rm")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token variable"}},[s("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$(")]),e._v("docker image "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v(" -q redis"),s("span",{pre:!0,attrs:{class:"token variable"}},[e._v(")")])]),e._v("\n")])])]),s("p",[e._v("或者删除所有在 "),s("code",[e._v("mongo:3.2")]),e._v(" 之前的镜像：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker image "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("rm")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token variable"}},[s("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$(")]),e._v("docker image "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v(" -q -f before"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("mongo:3.2"),s("span",{pre:!0,attrs:{class:"token variable"}},[e._v(")")])]),e._v("\n")])])]),s("p",[e._v("充分利用你的想象力和 Linux 命令行的强大，你可以完成很多非常赞的功能。")]),e._v(" "),s("h4",{attrs:{id:"centos-rhel-的用户需要注意的事项"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#centos-rhel-的用户需要注意的事项","aria-hidden":"true"}},[e._v("#")]),e._v(" CentOS/RHEL 的用户需要注意的事项")]),e._v(" "),s("p",[e._v("在 Ubuntu/Debian 上有 "),s("code",[e._v("UnionFS")]),e._v(" 可以使用，如 "),s("code",[e._v("aufs")]),e._v(" 或者 "),s("code",[e._v("overlay2")]),e._v("，而 CentOS 和 RHEL 的内核中没有相关驱动。因此对于这类系统，一般使用 "),s("code",[e._v("devicemapper")]),e._v(" 驱动利用 LVM 的一些机制来模拟分层存储。这样的做法除了性能比较差外，稳定性一般也不好，而且配置相对复杂。Docker 安装在 CentOS/RHEL 上后，会默认选择 "),s("code",[e._v("devicemapper")]),e._v("，但是为了简化配置，其 "),s("code",[e._v("devicemapper")]),e._v(" 是跑在一个稀疏文件模拟的块设备上，也被称为 "),s("code",[e._v("loop-lvm")]),e._v("。这样的选择是因为不需要额外配置就可以运行 Docker，这是自动配置唯一能做到的事情。但是 "),s("code",[e._v("loop-lvm")]),e._v(" 的做法非常不好，其稳定性、性能更差，无论是日志还是 "),s("code",[e._v("docker info")]),e._v(" 中都会看到警告信息。官方文档有明确的文章讲解了如何配置块设备给 "),s("code",[e._v("devicemapper")]),e._v(" 驱动做存储层的做法，这类做法也被称为配置 "),s("code",[e._v("direct-lvm")]),e._v("。")]),e._v(" "),s("p",[e._v("除了前面说到的问题外，"),s("code",[e._v("devicemapper")]),e._v(" + "),s("code",[e._v("loop-lvm")]),e._v(" 还有一个缺陷，因为它是稀疏文件，所以它会不断增长。用户在使用过程中会注意到 "),s("code",[e._v("/var/lib/docker/devicemapper/devicemapper/data")]),e._v(" 不断增长，而且无法控制。很多人会希望删除镜像或者可以解决这个问题，结果发现效果并不明显。原因就是这个稀疏文件的空间释放后基本不进行垃圾回收的问题。因此往往会出现即使删除了文件内容，空间却无法回收，随着使用这个稀疏文件一直在不断增长。")]),e._v(" "),s("p",[e._v("所以对于 CentOS/RHEL 的用户来说，在没有办法使用 "),s("code",[e._v("UnionFS")]),e._v(" 的情况下，一定要配置 "),s("code",[e._v("direct-lvm")]),e._v("给 "),s("code",[e._v("devicemapper")]),e._v("，无论是为了性能、稳定性还是空间利用率。")]),e._v(" "),s("p",[s("em",[e._v("或许有人注意到了 CentOS 7 中存在被 backports 回来的 overlay 驱动，不过 CentOS 里的这个驱动达不到生产环境使用的稳定程度，所以不推荐使用。")])]),e._v(" "),s("h2",{attrs:{id:"dockerfile定制镜像"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dockerfile定制镜像","aria-hidden":"true"}},[e._v("#")]),e._v(" Dockerfile定制镜像")]),e._v(" "),s("p",[e._v("Dockerfile是一个包含用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。 Docker通过读取Dockerfile中的指令自动生成映像。")]),e._v(" "),s("p",[s("code",[e._v("docker build")]),e._v(" 命令用于从Dockerfile构建映像。可以在 "),s("code",[e._v("docker build")]),e._v(" 命令中使用 "),s("code",[e._v("-f")]),e._v(" 标志指向文件系统中任何位置的Dockerfile。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("docker build -f /path/to/a/Dockerfile\n")])])]),s("p",[e._v("例如：在一个空白目录中，建立一个文本文件，并命名为 "),s("code",[e._v("Dockerfile")]),e._v("：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("mkdir")]),e._v(" mynginx\n$ "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("cd")]),e._v(" mynginx\n$ "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("touch")]),e._v(" Dockerfile\n")])])]),s("p",[e._v("其内容为：")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("FROM")]),e._v(" nginx\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" echo "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'<h1>Hello, Docker!</h1>'")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")]),e._v(" /usr/share/nginx/html/index.html\n")])])]),s("p",[e._v("Dockerfile文件说明：")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("不区分大小写，但必须遵循建议使用大写字母的约定。")])]),e._v(" "),s("li",[s("p",[e._v("Docker 以从上到下的顺序运行 Dockerfile 的指令。为了指定基本映像，第一条指令必须是 "),s("code",[e._v("FROM")]),e._v("。")])]),e._v(" "),s("li",[s("p",[e._v("一个声明以"),s("code",[e._v("＃")]),e._v("字符开头则被视为注释。可以在Docker文件中使用"),s("code",[e._v("RUN")]),e._v("，"),s("code",[e._v("CMD")]),e._v("，"),s("code",[e._v("FROM")]),e._v("，"),s("code",[e._v("EXPOSE")]),e._v("，"),s("code",[e._v("ENV")]),e._v("等指令。")])])]),e._v(" "),s("h3",{attrs:{id:"from-指定基础镜像"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#from-指定基础镜像","aria-hidden":"true"}},[e._v("#")]),e._v(" FROM 指定基础镜像")]),e._v(" "),s("p",[e._v("所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 "),s("code",[e._v("nginx")]),e._v(" 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 "),s("code",[e._v("FROM")]),e._v(" 就是指定"),s("strong",[e._v("基础镜像")]),e._v("，因此一个 "),s("code",[e._v("Dockerfile")]),e._v("中 "),s("code",[e._v("FROM")]),e._v(" 是必备的指令，并且必须是第一条指令。")]),e._v(" "),s("p",[e._v("在 "),s("a",{attrs:{href:"https://store.docker.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Docker Store"),s("OutboundLink")],1),e._v(" 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 "),s("a",{attrs:{href:"https://store.docker.com/images/nginx/",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("nginx")]),s("OutboundLink")],1),e._v("、"),s("a",{attrs:{href:"https://store.docker.com/images/redis/",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("redis")]),s("OutboundLink")],1),e._v("、"),s("a",{attrs:{href:"https://store.docker.com/images/mongo/",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("mongo")]),s("OutboundLink")],1),e._v("、"),s("a",{attrs:{href:"https://store.docker.com/images/mysql/",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("mysql")]),s("OutboundLink")],1),e._v("、"),s("a",{attrs:{href:"https://store.docker.com/images/httpd/",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("httpd")]),s("OutboundLink")],1),e._v("、"),s("a",{attrs:{href:"https://store.docker.com/images/php/",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("php")]),s("OutboundLink")],1),e._v("、"),s("a",{attrs:{href:"https://store.docker.com/images/tomcat/",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("tomcat")]),s("OutboundLink")],1),e._v(" 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 "),s("a",{attrs:{href:"https://store.docker.com/images/node",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("node")]),s("OutboundLink")],1),e._v("、"),s("a",{attrs:{href:"https://store.docker.com/images/openjdk/",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("openjdk")]),s("OutboundLink")],1),e._v("、"),s("a",{attrs:{href:"https://store.docker.com/images/python/",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("python")]),s("OutboundLink")],1),e._v("、"),s("a",{attrs:{href:"https://store.docker.com/images/ruby/",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("ruby")]),s("OutboundLink")],1),e._v("、"),s("a",{attrs:{href:"https://store.docker.com/images/golang/",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("golang")]),s("OutboundLink")],1),e._v(" 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。")]),e._v(" "),s("p",[e._v("如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 "),s("a",{attrs:{href:"https://store.docker.com/images/ubuntu/",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("ubuntu")]),s("OutboundLink")],1),e._v("、"),s("a",{attrs:{href:"https://store.docker.com/images/debian/",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("debian")]),s("OutboundLink")],1),e._v("、"),s("a",{attrs:{href:"https://store.docker.com/images/centos/",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("centos")]),s("OutboundLink")],1),e._v("、"),s("a",{attrs:{href:"https://store.docker.com/images/fedora/",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("fedora")]),s("OutboundLink")],1),e._v("、"),s("a",{attrs:{href:"https://store.docker.com/images/alpine/",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("alpine")]),s("OutboundLink")],1),e._v(" 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。")]),e._v(" "),s("p",[e._v("除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 "),s("code",[e._v("scratch")]),e._v("。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("FROM")]),e._v(" scratch\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("...")]),e._v("\n")])])]),s("p",[e._v("如果你以 "),s("code",[e._v("scratch")]),e._v(" 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。")]),e._v(" "),s("p",[e._v("不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 "),s("a",{attrs:{href:"https://hub.docker.com/_/swarm/",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("swarm")]),s("OutboundLink")],1),e._v("、"),s("a",{attrs:{href:"https://quay.io/repository/coreos/etcd",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("coreos/etcd")]),s("OutboundLink")],1),e._v("。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 "),s("code",[e._v("FROM scratch")]),e._v(" 会让镜像体积更加小巧。使用 "),s("a",{attrs:{href:"https://golang.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Go 语言"),s("OutboundLink")],1),e._v(" 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。")]),e._v(" "),s("h3",{attrs:{id:"run-执行命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#run-执行命令","aria-hidden":"true"}},[e._v("#")]),e._v(" RUN 执行命令")]),e._v(" "),s("p",[s("code",[e._v("RUN")]),e._v(" 指令是用来执行命令行命令的。由于命令行的强大能力，"),s("code",[e._v("RUN")]),e._v(" 指令在定制镜像时是最常用的指令之一。其格式有两种：")]),e._v(" "),s("ul",[s("li",[s("em",[e._v("shell")]),e._v(" 格式："),s("code",[e._v("RUN <命令>")]),e._v("，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 "),s("code",[e._v("RUN")]),e._v(" 指令就是这种格式。")])]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" echo "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'<h1>Hello, Docker!</h1>'")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")]),e._v(" /usr/share/nginx/html/index.html\n")])])]),s("ul",[s("li",[s("em",[e._v("exec")]),e._v(" 格式："),s("code",[e._v('RUN ["可执行文件", "参数1", "参数2"]')]),e._v("，这更像是函数调用中的格式。")])]),e._v(" "),s("p",[e._v("既然 "),s("code",[e._v("RUN")]),e._v(" 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("FROM")]),e._v(" debian"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("jessie\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" apt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("get update\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" apt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("get install "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("y gcc libc6"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("dev make\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" wget "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("O redis.tar.gz "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"http://download.redis.io/releases/redis-3.2.5.tar.gz"')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" mkdir "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("p /usr/src/redis\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" tar "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("xzf redis.tar.gz "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("C /usr/src/redis "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("strip"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("components=1\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" make "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("C /usr/src/redis\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" make "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("C /usr/src/redis install\n")])])]),s("p",[e._v("之前说过，Dockerfile 中每一个指令都会建立一层，"),s("code",[e._v("RUN")]),e._v(" 也不例外。每一个 "),s("code",[e._v("RUN")]),e._v(" 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，"),s("code",[e._v("commit")]),e._v(" 这一层的修改，构成新的镜像。")]),e._v(" "),s("p",[e._v("而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。")]),e._v(" "),s("p",[s("em",[e._v("Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。")])]),e._v(" "),s("p",[e._v("上面的 "),s("code",[e._v("Dockerfile")]),e._v(" 正确的写法应该是这样：")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("FROM")]),e._v(" debian"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("jessie\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" buildDeps="),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'gcc libc6-dev make'")]),e._v(" \\\n    && apt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("get update \\\n    && apt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("get install "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("y $buildDeps \\\n    && wget "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("O redis.tar.gz "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"http://download.redis.io/releases/redis-3.2.5.tar.gz"')]),e._v(" \\\n    && mkdir "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("p /usr/src/redis \\\n    && tar "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("xzf redis.tar.gz "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("C /usr/src/redis "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("strip"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("components=1 \\\n    && make "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("C /usr/src/redis \\\n    && make "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("C /usr/src/redis install \\\n    && rm "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("rf /var/lib/apt/lists/* \\\n    && rm redis.tar.gz \\\n    && rm "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("r /usr/src/redis \\\n    && apt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("get purge "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("y "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("auto"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("remove $buildDeps\n")])])]),s("p",[e._v("首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 "),s("code",[e._v("RUN")]),e._v(" 对一一对应不同的命令，而是仅仅使用一个 "),s("code",[e._v("RUN")]),e._v(" 指令，并使用 "),s("code",[e._v("&&")]),e._v(" 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。")]),e._v(" "),s("p",[e._v("并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 "),s("code",[e._v("\\")]),e._v(" 的命令换行方式，以及行首 "),s("code",[e._v("#")]),e._v(" 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。")]),e._v(" "),s("p",[e._v("此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 "),s("code",[e._v("apt")]),e._v(" 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。")]),e._v(" "),s("p",[e._v("很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。")]),e._v(" "),s("h3",{attrs:{id:"构建镜像"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构建镜像","aria-hidden":"true"}},[e._v("#")]),e._v(" 构建镜像")]),e._v(" "),s("p",[e._v("好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。")]),e._v(" "),s("p",[e._v("在 "),s("code",[e._v("Dockerfile")]),e._v(" 文件所在目录执行：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker build -t nginx:v3 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v(".")]),e._v("\nSending build context to Docker daemon 2.048 kB\nStep 1 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v(":")]),e._v(" FROM nginx\n ---"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" e43d811ce2f4\nStep 2 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v(":")]),e._v(" RUN "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("echo")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'<h1>Hello, Docker!</h1>'")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" /usr/share/nginx/html/index.html\n ---"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" Running "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("in")]),e._v(" 9cdc27646c7b\n ---"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" 44aa4490ce2c\nRemoving intermediate container 9cdc27646c7b\nSuccessfully built 44aa4490ce2c\n")])])]),s("p",[e._v("从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 "),s("code",[e._v("Step 2")]),e._v(" 中，如同我们之前所说的那样，"),s("code",[e._v("RUN")]),e._v(" 指令启动了一个容器 "),s("code",[e._v("9cdc27646c7b")]),e._v("，执行了所要求的命令，并最后提交了这一层 "),s("code",[e._v("44aa4490ce2c")]),e._v("，随后删除了所用到的这个容器 "),s("code",[e._v("9cdc27646c7b")]),e._v("。")]),e._v(" "),s("p",[e._v("这里我们使用了 "),s("code",[e._v("docker build")]),e._v(" 命令进行镜像构建。其格式为：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("docker build "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("选项"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("上下文路径/URL/-"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\n\n")])])]),s("p",[e._v("在这里我们指定了最终镜像的名称 "),s("code",[e._v("-t nginx:v3")]),e._v("，构建成功后，我们可以像之前运行 "),s("code",[e._v("nginx:v2")]),e._v(" 那样来运行这个镜像，其结果会和 "),s("code",[e._v("nginx:v2")]),e._v(" 一样。")]),e._v(" "),s("h3",{attrs:{id:"镜像构建上下文"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#镜像构建上下文","aria-hidden":"true"}},[e._v("#")]),e._v(" 镜像构建上下文")]),e._v(" "),s("p",[e._v("如果注意，会看到 "),s("code",[e._v("docker build")]),e._v(" 命令最后有一个 "),s("code",[e._v(".")]),e._v("。"),s("code",[e._v(".")]),e._v(" 表示当前目录，而 "),s("code",[e._v("Dockerfile")]),e._v(" 就在当前目录，因此不少初学者以为这个路径是在指定 "),s("code",[e._v("Dockerfile")]),e._v(" 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定"),s("strong",[e._v("上下文路径")]),e._v("。那么什么是上下文呢？")]),e._v(" "),s("p",[e._v("首先我们要理解 "),s("code",[e._v("docker build")]),e._v(" 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 "),s("a",{attrs:{href:"https://docs.docker.com/engine/reference/api/docker_remote_api/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Docker Remote API"),s("OutboundLink")],1),e._v("，而如 "),s("code",[e._v("docker")]),e._v(" 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 "),s("code",[e._v("docker")]),e._v(" 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。")]),e._v(" "),s("p",[e._v("当我们进行镜像构建的时候，并非所有定制都会通过 "),s("code",[e._v("RUN")]),e._v(" 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 "),s("code",[e._v("COPY")]),e._v(" 指令、"),s("code",[e._v("ADD")]),e._v(" 指令等。而 "),s("code",[e._v("docker build")]),e._v(" 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？")]),e._v(" "),s("p",[e._v("这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，"),s("code",[e._v("docker build")]),e._v(" 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。")]),e._v(" "),s("p",[e._v("如果在 "),s("code",[e._v("Dockerfile")]),e._v(" 中这么写：")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("COPY")]),e._v(" ./package.json /app/\n")])])]),s("p",[e._v("这并不是要复制执行 "),s("code",[e._v("docker build")]),e._v(" 命令所在的目录下的 "),s("code",[e._v("package.json")]),e._v("，也不是复制 "),s("code",[e._v("Dockerfile")]),e._v("所在目录下的 "),s("code",[e._v("package.json")]),e._v("，而是复制 "),s("strong",[e._v("上下文（context）")]),e._v(" 目录下的 "),s("code",[e._v("package.json")]),e._v("。")]),e._v(" "),s("p",[e._v("因此，"),s("code",[e._v("COPY")]),e._v(" 这类指令中的源文件的路径都是"),s("em",[e._v("相对路径")]),e._v("。这也是初学者经常会问的为什么 "),s("code",[e._v("COPY ../package.json /app")]),e._v(" 或者 "),s("code",[e._v("COPY /opt/xxxx /app")]),e._v(" 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。")]),e._v(" "),s("p",[e._v("现在就可以理解刚才的命令 "),s("code",[e._v("docker build -t nginx:v3 .")]),e._v(" 中的这个 "),s("code",[e._v(".")]),e._v("，实际上是在指定上下文的目录，"),s("code",[e._v("docker build")]),e._v(" 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。")]),e._v(" "),s("p",[e._v("如果观察 "),s("code",[e._v("docker build")]),e._v(" 输出，我们其实已经看到了这个发送上下文的过程：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker build -t nginx:v3 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v(".")]),e._v("\nSending build context to Docker daemon 2.048 kB\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("..")]),e._v(".\n")])])]),s("p",[e._v("理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 "),s("code",[e._v("COPY /opt/xxxx /app")]),e._v(" 不工作后，于是干脆将 "),s("code",[e._v("Dockerfile")]),e._v(" 放到了硬盘根目录去构建，结果发现 "),s("code",[e._v("docker build")]),e._v(" 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 "),s("code",[e._v("docker build")]),e._v(" 打包整个硬盘，这显然是使用错误。")]),e._v(" "),s("p",[e._v("一般来说，应该会将 "),s("code",[e._v("Dockerfile")]),e._v(" 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 "),s("code",[e._v(".gitignore")]),e._v(" 一样的语法写一个 "),s("code",[e._v(".dockerignore")]),e._v("，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。")]),e._v(" "),s("p",[e._v("那么为什么会有人误以为 "),s("code",[e._v(".")]),e._v(" 是指定 "),s("code",[e._v("Dockerfile")]),e._v(" 所在目录呢？这是因为在默认情况下，如果不额外指定 "),s("code",[e._v("Dockerfile")]),e._v(" 的话，会将上下文目录下的名为 "),s("code",[e._v("Dockerfile")]),e._v(" 的文件作为 Dockerfile。")]),e._v(" "),s("p",[e._v("这只是默认行为，实际上 "),s("code",[e._v("Dockerfile")]),e._v(" 的文件名并不要求必须为 "),s("code",[e._v("Dockerfile")]),e._v("，而且并不要求必须位于上下文目录中，比如可以用 "),s("code",[e._v("-f ../Dockerfile.php")]),e._v(" 参数指定某个文件作为 "),s("code",[e._v("Dockerfile")]),e._v("。")]),e._v(" "),s("p",[e._v("当然，一般大家习惯性的会使用默认的文件名 "),s("code",[e._v("Dockerfile")]),e._v("，以及会将其置于镜像构建上下文目录中。")]),e._v(" "),s("h3",{attrs:{id:"其它-docker-build-的用法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#其它-docker-build-的用法","aria-hidden":"true"}},[e._v("#")]),e._v(" 其它 "),s("code",[e._v("docker build")]),e._v(" 的用法")]),e._v(" "),s("h4",{attrs:{id:"直接用-git-repo-进行构建"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#直接用-git-repo-进行构建","aria-hidden":"true"}},[e._v("#")]),e._v(" 直接用 Git repo 进行构建")]),e._v(" "),s("p",[e._v("或许你已经注意到了，"),s("code",[e._v("docker build")]),e._v(" 还支持从 URL 构建，比如可以直接从 Git repo 中构建：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker build https://github.com/twang2218/gitlab-ce-zh.git"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#:8.14")]),e._v("\ndocker build https://github.com/twang2218/gitlab-ce-zh.git\\#:8.14\nSending build context to Docker daemon 2.048 kB\nStep 1 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v(":")]),e._v(" FROM gitlab/gitlab-ce:8.14.0-ce.0\n8.14.0-ce.0: Pulling from gitlab/gitlab-ce\naed15891ba52: Already exists\n773ae8583d14: Already exists\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("..")]),e._v(".\n")])])]),s("p",[e._v("这行命令指定了构建所需的 Git repo，并且指定默认的 "),s("code",[e._v("master")]),e._v(" 分支，构建目录为 "),s("code",[e._v("/8.14/")]),e._v("，然后 Docker 就会自己去 "),s("code",[e._v("git clone")]),e._v(" 这个项目、切换到指定分支、并进入到指定目录后开始构建。")]),e._v(" "),s("h4",{attrs:{id:"用给定的-tar-压缩包构建"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#用给定的-tar-压缩包构建","aria-hidden":"true"}},[e._v("#")]),e._v(" 用给定的 tar 压缩包构建")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker build http://server/context.tar.gz\n")])])]),s("p",[e._v("如果所给出的 URL 不是个 Git repo，而是个 "),s("code",[e._v("tar")]),e._v(" 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。")]),e._v(" "),s("h4",{attrs:{id:"从标准输入中读取-dockerfile-进行构建"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#从标准输入中读取-dockerfile-进行构建","aria-hidden":"true"}},[e._v("#")]),e._v(" 从标准输入中读取 Dockerfile 进行构建")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("docker build - "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v(" Dockerfile\n")])])]),s("p",[e._v("或")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[e._v("cat")]),e._v(" Dockerfile "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v(" docker build -\n")])])]),s("p",[e._v("如果标准输入传入的是文本文件，则将其视为 "),s("code",[e._v("Dockerfile")]),e._v("，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 "),s("code",[e._v("COPY")]),e._v(" 进镜像之类的事情。")]),e._v(" "),s("h4",{attrs:{id:"从标准输入中读取上下文压缩包进行构建"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#从标准输入中读取上下文压缩包进行构建","aria-hidden":"true"}},[e._v("#")]),e._v(" 从标准输入中读取上下文压缩包进行构建")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker build - "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v(" context.tar.gz\n")])])]),s("p",[e._v("如果发现标准输入的文件格式是 "),s("code",[e._v("gzip")]),e._v("、"),s("code",[e._v("bzip2")]),e._v(" 以及 "),s("code",[e._v("xz")]),e._v(" 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。")]),e._v(" "),s("h2",{attrs:{id:"dockerfile指令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dockerfile指令","aria-hidden":"true"}},[e._v("#")]),e._v(" Dockerfile指令")]),e._v(" "),s("p",[e._v("我们已经介绍了 "),s("code",[e._v("FROM")]),e._v("，"),s("code",[e._v("RUN")]),e._v("，还提及了 "),s("code",[e._v("COPY")]),e._v(", "),s("code",[e._v("ADD")]),e._v("，其实 Dockerfile 功能很强大，它提供了十多个指令。下面我们继续讲解其他的指令。")]),e._v(" "),s("h3",{attrs:{id:"copy复制文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#copy复制文件","aria-hidden":"true"}},[e._v("#")]),e._v(" COPY复制文件")]),e._v(" "),s("p",[e._v("格式：")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("COPY <源路径>... <目标路径>")])]),e._v(" "),s("li",[s("code",[e._v('COPY ["<源路径1>",... "<目标路径>"]')])])]),e._v(" "),s("p",[e._v("和 "),s("code",[e._v("RUN")]),e._v(" 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。")]),e._v(" "),s("p",[s("code",[e._v("COPY")]),e._v(" 指令将从构建上下文目录中 "),s("code",[e._v("<源路径>")]),e._v(" 的文件/目录复制到新的一层的镜像内的 "),s("code",[e._v("<目标路径>")]),e._v(" 位置。比如：")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("COPY")]),e._v(" package.json /usr/src/app/\n")])])]),s("p",[s("code",[e._v("<源路径>")]),e._v(" 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 "),s("a",{attrs:{href:"https://golang.org/pkg/path/filepath/#Match",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("filepath.Match")]),s("OutboundLink")],1),e._v(" 规则，如：")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("COPY")]),e._v(" hom* /mydir/\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("COPY")]),e._v(" hom"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("?")]),e._v(".txt /mydir/\n")])])]),s("p",[s("code",[e._v("<目标路径>")]),e._v(" 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 "),s("code",[e._v("WORKDIR")]),e._v(" 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。")]),e._v(" "),s("p",[e._v("此外，还需要注意一点，使用 "),s("code",[e._v("COPY")]),e._v(" 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。")]),e._v(" "),s("h3",{attrs:{id:"add更高级的复制文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#add更高级的复制文件","aria-hidden":"true"}},[e._v("#")]),e._v(" ADD更高级的复制文件")]),e._v(" "),s("p",[s("code",[e._v("ADD")]),e._v(" 指令和 "),s("code",[e._v("COPY")]),e._v(" 的格式和性质基本一致。但是在 "),s("code",[e._v("COPY")]),e._v(" 基础上增加了一些功能。")]),e._v(" "),s("p",[e._v("比如 "),s("code",[e._v("<源路径>")]),e._v(" 可以是一个 "),s("code",[e._v("URL")]),e._v("，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 "),s("code",[e._v("<目标路径>")]),e._v(" 去。下载后的文件权限自动设置为 "),s("code",[e._v("600")]),e._v("，如果这并不是想要的权限，那么还需要增加额外的一层 "),s("code",[e._v("RUN")]),e._v(" 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 "),s("code",[e._v("RUN")]),e._v(" 指令进行解压缩。所以不如直接使用 "),s("code",[e._v("RUN")]),e._v(" 指令，然后使用 "),s("code",[e._v("wget")]),e._v(" 或者 "),s("code",[e._v("curl")]),e._v(" 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。")]),e._v(" "),s("p",[e._v("如果 "),s("code",[e._v("<源路径>")]),e._v(" 为一个 "),s("code",[e._v("tar")]),e._v(" 压缩文件的话，压缩格式为 "),s("code",[e._v("gzip")]),e._v(", "),s("code",[e._v("bzip2")]),e._v(" 以及 "),s("code",[e._v("xz")]),e._v(" 的情况下，"),s("code",[e._v("ADD")]),e._v(" 指令将会自动解压缩这个压缩文件到 "),s("code",[e._v("<目标路径>")]),e._v(" 去。")]),e._v(" "),s("p",[e._v("在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 "),s("code",[e._v("ubuntu")]),e._v(" 中：")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("FROM")]),e._v(" scratch\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("ADD")]),e._v(" ubuntu"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("xenial"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("core"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("cloudimg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("amd64"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("root.tar.gz /\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("...")]),e._v("\n")])])]),s("p",[e._v("但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 "),s("code",[e._v("ADD")]),e._v(" 命令了。")]),e._v(" "),s("p",[e._v("在 Docker 官方的 "),s("code",[e._v("Dockerfile 最佳实践文档")]),e._v(" 中要求，尽可能的使用 "),s("code",[e._v("COPY")]),e._v("，因为 "),s("code",[e._v("COPY")]),e._v(" 的语义很明确，就是复制文件而已，而 "),s("code",[e._v("ADD")]),e._v(" 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 "),s("code",[e._v("ADD")]),e._v(" 的场合，就是所提及的需要自动解压缩的场合。")]),e._v(" "),s("p",[e._v("另外需要注意的是，"),s("code",[e._v("ADD")]),e._v(" 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。")]),e._v(" "),s("p",[e._v("因此在 "),s("code",[e._v("COPY")]),e._v(" 和 "),s("code",[e._v("ADD")]),e._v(" 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 "),s("code",[e._v("COPY")]),e._v(" 指令，仅在需要自动解压缩的场合使用 "),s("code",[e._v("ADD")]),e._v("。")]),e._v(" "),s("h3",{attrs:{id:"cmd容器启动命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cmd容器启动命令","aria-hidden":"true"}},[e._v("#")]),e._v(" CMD容器启动命令")]),e._v(" "),s("p",[s("code",[e._v("CMD")]),e._v(" 指令的格式和 "),s("code",[e._v("RUN")]),e._v(" 相似，也是两种格式：")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("shell")]),e._v(" 格式："),s("code",[e._v("CMD <命令>")])]),e._v(" "),s("li",[s("code",[e._v("exec")]),e._v(" 格式："),s("code",[e._v('CMD ["可执行文件", "参数1", "参数2"...]')])]),e._v(" "),s("li",[e._v("参数列表格式："),s("code",[e._v('CMD ["参数1", "参数2"...]')]),e._v("。在指定了 "),s("code",[e._v("ENTRYPOINT")]),e._v(" 指令后，用 "),s("code",[e._v("CMD")]),e._v(" 指定具体的参数。")])]),e._v(" "),s("p",[e._v("之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。"),s("code",[e._v("CMD")]),e._v(" 指令就是用于指定默认的容器主进程的启动命令的。")]),e._v(" "),s("p",[e._v("在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，"),s("code",[e._v("ubuntu")]),e._v(" 镜像默认的 "),s("code",[e._v("CMD")]),e._v(" 是 "),s("code",[e._v("/bin/bash")]),e._v("，如果我们直接 "),s("code",[e._v("docker run -it centos")]),e._v(" 的话，会直接进入 "),s("code",[e._v("bash")]),e._v("。我们也可以在运行时指定运行别的命令，如 "),s("code",[e._v("docker run -it centos cat /etc/os-release")]),e._v("。这就是用 "),s("code",[e._v("cat /etc/os-release")]),e._v(" 命令替换了默认的 "),s("code",[e._v("/bin/bash")]),e._v(" 命令了，输出了系统版本信息。")]),e._v(" "),s("p",[e._v("在指令格式上，一般推荐使用 "),s("code",[e._v("exec")]),e._v(" 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 "),s("code",[e._v('"')]),e._v("，而不要使用单引号。")]),e._v(" "),s("p",[e._v("如果使用 "),s("code",[e._v("shell")]),e._v(" 格式的话，实际的命令会被包装为 "),s("code",[e._v("sh -c")]),e._v(" 的参数的形式进行执行。比如：")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("CMD")]),e._v(" echo $HOME\n")])])]),s("p",[e._v("在实际执行中，会将其变更为：")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("CMD")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"sh"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"-c"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"echo $HOME"')]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n")])])]),s("p",[e._v("这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。")]),e._v(" "),s("p",[e._v("提到 "),s("code",[e._v("CMD")]),e._v(" 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。")]),e._v(" "),s("p",[e._v("Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。")]),e._v(" "),s("p",[e._v("一些初学者将 "),s("code",[e._v("CMD")]),e._v(" 写为：")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("CMD")]),e._v(" service nginx start\n")])])]),s("p",[e._v("然后发现容器执行后就立即退出了。甚至在容器内去使用 "),s("code",[e._v("systemctl")]),e._v(" 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。")]),e._v(" "),s("p",[e._v("对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。")]),e._v(" "),s("p",[e._v("而使用 "),s("code",[e._v("service nginx start")]),e._v(" 命令，则是希望 upstart 来以后台守护进程形式启动 "),s("code",[e._v("nginx")]),e._v(" 服务。而刚才说了 "),s("code",[e._v("CMD service nginx start")]),e._v(" 会被理解为 "),s("code",[e._v('CMD [ "sh", "-c", "service nginx start"]')]),e._v("，因此主进程实际上是 "),s("code",[e._v("sh")]),e._v("。那么当 "),s("code",[e._v("service nginx start")]),e._v(" 命令结束后，"),s("code",[e._v("sh")]),e._v(" 也就结束了，"),s("code",[e._v("sh")]),e._v(" 作为主进程退出了，自然就会令容器退出。")]),e._v(" "),s("p",[e._v("正确的做法是直接执行 "),s("code",[e._v("nginx")]),e._v(" 可执行文件，并且要求以前台形式运行。比如：")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("CMD")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"nginx"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"-g"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"daemon off;"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n")])])]),s("h3",{attrs:{id:"entrypoint入口点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#entrypoint入口点","aria-hidden":"true"}},[e._v("#")]),e._v(" ENTRYPOINT入口点")]),e._v(" "),s("p",[s("code",[e._v("ENTRYPOINT")]),e._v(" 的格式和 "),s("code",[e._v("RUN")]),e._v(" 指令格式一样，分为 "),s("code",[e._v("exec")]),e._v(" 格式和 "),s("code",[e._v("shell")]),e._v(" 格式。")]),e._v(" "),s("p",[s("code",[e._v("ENTRYPOINT")]),e._v(" 的目的和 "),s("code",[e._v("CMD")]),e._v(" 一样，都是在指定容器启动程序及参数。"),s("code",[e._v("ENTRYPOINT")]),e._v(" 在运行时也可以替代，不过比 "),s("code",[e._v("CMD")]),e._v(" 要略显繁琐，需要通过 "),s("code",[e._v("docker run")]),e._v(" 的参数 "),s("code",[e._v("--entrypoint")]),e._v(" 来指定。")]),e._v(" "),s("p",[e._v("当指定了 "),s("code",[e._v("ENTRYPOINT")]),e._v(" 后，"),s("code",[e._v("CMD")]),e._v(" 的含义就发生了改变，不再是直接的运行其命令，而是将 "),s("code",[e._v("CMD")]),e._v(" 的内容作为参数传给 "),s("code",[e._v("ENTRYPOINT")]),e._v(" 指令，换句话说实际执行时，将变为：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("ENTRYPOINT"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"<CMD>"')]),e._v("\n")])])]),s("p",[e._v("那么有了 "),s("code",[e._v("CMD")]),e._v(" 后，为什么还要有 "),s("code",[e._v("ENTRYPOINT")]),e._v(" 呢？这种 "),s("code",[e._v('<ENTRYPOINT> "<CMD>"')]),e._v(" 有什么好处么？让我们来看几个场景。")]),e._v(" "),s("h4",{attrs:{id:"场景一：让镜像变成像命令一样使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#场景一：让镜像变成像命令一样使用","aria-hidden":"true"}},[e._v("#")]),e._v(" 场景一：让镜像变成像命令一样使用")]),e._v(" "),s("p",[e._v("假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 "),s("code",[e._v("CMD")]),e._v(" 来实现：")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("FROM")]),e._v(" centos\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" yum update \\\n    && yum install "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("y curl \n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("CMD")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"curl"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"-s"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"http://ip.cn"')]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n\n")])])]),s("p",[e._v("假如我们使用 "),s("code",[e._v("docker build -t myip .")]),e._v(" 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker run myip\n当前 IP：61.148.226.66 来自：北京市 联通\n\n")])])]),s("p",[e._v("嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 "),s("code",[e._v("CMD")]),e._v(" 中可以看到实质的命令是 "),s("code",[e._v("curl")]),e._v("，那么如果我们希望显示 HTTP 头信息，就需要加上 "),s("code",[e._v("-i")]),e._v(" 参数。那么我们可以直接加 "),s("code",[e._v("-i")]),e._v(" 参数给 "),s("code",[e._v("docker run myip")]),e._v(" 么？")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker run myip -i\ndocker: Error response from daemon: invalid header field value "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"oci runtime error: container_linux.go:247: starting container process caused \\"exec: \\\\\\"-i\\\\\\": executable file not found in '),s("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$PATH")]),e._v('\\"\\n"')]),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v(".")]),e._v("\n\n")])])]),s("p",[e._v("我们可以看到可执行文件找不到的报错，"),s("code",[e._v("executable file not found")]),e._v("。之前我们说过，跟在镜像名后面的是 "),s("code",[e._v("command")]),e._v("，运行时会替换 "),s("code",[e._v("CMD")]),e._v(" 的默认值。因此这里的 "),s("code",[e._v("-i")]),e._v(" 替换了原来的 "),s("code",[e._v("CMD")]),e._v("，而不是添加在原来的 "),s("code",[e._v("curl -s http://ip.cn")]),e._v(" 后面。而 "),s("code",[e._v("-i")]),e._v(" 根本不是命令，所以自然找不到。")]),e._v(" "),s("p",[e._v("那么如果我们希望加入 "),s("code",[e._v("-i")]),e._v(" 这参数，我们就必须重新完整的输入这个命令：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker run myip "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("curl")]),e._v(" -s http://ip.cn -i\n\n")])])]),s("p",[e._v("这显然不是很好的解决方案，而使用 "),s("code",[e._v("ENTRYPOINT")]),e._v(" 就可以解决这个问题。现在我们重新用 "),s("code",[e._v("ENTRYPOINT")]),e._v("来实现这个镜像：")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("FROM")]),e._v(" centos\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" yum update \\\n    && yum install "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("y curl \n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("ENTRYPOINT")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"curl"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"-s"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"http://ip.cn"')]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n\n")])])]),s("p",[e._v("这次我们再来尝试直接使用 "),s("code",[e._v("docker run myip -i")]),e._v("：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker run myip\n当前 IP：61.148.226.66 来自：北京市 联通\n\n$ docker run myip -i\nHTTP/1.1 200 OK\nServer: nginx/1.8.0\nDate: Tue, 22 Nov 2016 05:12:40 GMT\nContent-Type: text/html"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" charset"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("UTF-8\nVary: Accept-Encoding\nX-Powered-By: PHP/5.6.24-1~dotdeb+7.1\nX-Cache: MISS from cache-2\nX-Cache-Lookup: MISS from cache-2:80\nX-Cache: MISS from proxy-2_6\nTransfer-Encoding: chunked\nVia: 1.1 cache-2:80, 1.1 proxy-2_6:8006\nConnection: keep-alive\n\n当前 IP：61.148.226.66 来自：北京市 联通\n\n")])])]),s("p",[e._v("可以看到，这次成功了。这是因为当存在 "),s("code",[e._v("ENTRYPOINT")]),e._v(" 后，"),s("code",[e._v("CMD")]),e._v(" 的内容将会作为参数传给 "),s("code",[e._v("ENTRYPOINT")]),e._v("，而这里 "),s("code",[e._v("-i")]),e._v(" 就是新的 "),s("code",[e._v("CMD")]),e._v("，因此会作为参数传给 "),s("code",[e._v("curl")]),e._v("，从而达到了我们预期的效果。")]),e._v(" "),s("h4",{attrs:{id:"场景二：应用运行前的准备工作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#场景二：应用运行前的准备工作","aria-hidden":"true"}},[e._v("#")]),e._v(" 场景二：应用运行前的准备工作")]),e._v(" "),s("p",[e._v("启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。")]),e._v(" "),s("p",[e._v("比如 "),s("code",[e._v("mysql")]),e._v(" 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。")]),e._v(" "),s("p",[e._v("此外，可能希望避免使用 "),s("code",[e._v("root")]),e._v(" 用户去启动服务，从而提高安全性，而在启动服务前还需要以 "),s("code",[e._v("root")]),e._v(" 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 "),s("code",[e._v("root")]),e._v(" 身份执行，方便调试等。")]),e._v(" "),s("p",[e._v("这些准备工作是和容器 "),s("code",[e._v("CMD")]),e._v(" 无关的，无论 "),s("code",[e._v("CMD")]),e._v(" 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 "),s("code",[e._v("ENTRYPOINT")]),e._v(" 中去执行，而这个脚本会将接到的参数（也就是 "),s("code",[e._v("<CMD>")]),e._v("）作为命令，在脚本最后执行。比如官方镜像 "),s("code",[e._v("redis")]),e._v(" 中就是这么做的：")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("FROM")]),e._v(" alpine"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("3.4\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("...")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" addgroup "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("S redis && adduser "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("S "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("G redis redis\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("...")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("ENTRYPOINT")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"docker-entrypoint.sh"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("EXPOSE")]),e._v(" 6379\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("CMD")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"redis-server"')]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n")])])]),s("p",[e._v("可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 "),s("code",[e._v("ENTRYPOINT")]),e._v(" 为 "),s("code",[e._v("docker-entrypoint.sh")]),e._v(" 脚本。")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token shebang important"}},[e._v("#!/bin/sh")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("..")]),e._v(".\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# allow the container to be started with `--user`")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("if")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"'),s("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$1")]),e._v('"')]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'redis-server'")]),e._v(" -a "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"'),s("span",{pre:!0,attrs:{class:"token variable"}},[s("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$(")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("id")]),e._v(" -u"),s("span",{pre:!0,attrs:{class:"token variable"}},[e._v(")")])]),e._v('"')]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'0'")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("then")]),e._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("chown")]),e._v(" -R redis "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v(".")]),e._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("exec")]),e._v(" su-exec redis "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"'),s("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$0")]),e._v('"')]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"'),s("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$@")]),e._v('"')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("fi")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("exec")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"'),s("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$@")]),e._v('"')]),e._v("\n")])])]),s("p",[e._v("该脚本的内容就是根据 "),s("code",[e._v("CMD")]),e._v(" 的内容来判断，如果是 "),s("code",[e._v("redis-server")]),e._v(" 的话，则切换到 "),s("code",[e._v("redis")]),e._v(" 用户身份启动服务器，否则依旧使用 "),s("code",[e._v("root")]),e._v(" 身份执行。比如：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker run -it redis "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("id")]),e._v("\nuid"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("0"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" gid"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("0"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" groups"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("0"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),s("h3",{attrs:{id:"env设置环境变量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#env设置环境变量","aria-hidden":"true"}},[e._v("#")]),e._v(" ENV设置环境变量")]),e._v(" "),s("p",[e._v("格式有两种：")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("ENV <key> <value>")])]),e._v(" "),s("li",[s("code",[e._v("ENV <key1>=<value1> <key2>=<value2>...")])])]),e._v(" "),s("p",[e._v("这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 "),s("code",[e._v("RUN")]),e._v("，还是运行时的应用，都可以直接使用这里定义的环境变量。")]),e._v(" "),s("div",{staticClass:"language-text extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('ENV VERSION=1.0 DEBUG=on \\\n    NAME="Happy Feet"\n\n')])])]),s("p",[e._v("这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。")]),e._v(" "),s("p",[e._v("定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 "),s("code",[e._v("node")]),e._v(" 镜像 "),s("code",[e._v("Dockerfile")]),e._v(" 中，就有类似这样的代码：")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("ENV")]),e._v(" NODE_VERSION 7.2.0\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" curl "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("SLO "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz"')]),e._v(" \\\n  && curl "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("SLO "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc"')]),e._v(" \\\n  && gpg "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("batch "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("decrypt "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("output SHASUMS256.txt SHASUMS256.txt.asc \\\n  && grep "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('" node-v$NODE_VERSION-linux-x64.tar.xz\\$"')]),e._v(" SHASUMS256.txt "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" sha256sum "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("c "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v(" \\\n  && tar "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("xJf "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"node-v$NODE_VERSION-linux-x64.tar.xz"')]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("C /usr/local "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("strip"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("components=1 \\\n  && rm "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"node-v$NODE_VERSION-linux-x64.tar.xz"')]),e._v(" SHASUMS256.txt.asc SHASUMS256.txt \\\n  && ln "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("s /usr/local/bin/node /usr/local/bin/nodejs\n\n")])])]),s("p",[e._v("在这里先定义了环境变量 "),s("code",[e._v("NODE_VERSION")]),e._v("，其后的 "),s("code",[e._v("RUN")]),e._v(" 这层里，多次使用 "),s("code",[e._v("$NODE_VERSION")]),e._v(" 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 "),s("code",[e._v("7.2.0")]),e._v(" 即可，"),s("code",[e._v("Dockerfile")]),e._v(" 构建维护变得更轻松了。")]),e._v(" "),s("p",[e._v("下列指令可以支持环境变量展开： "),s("code",[e._v("ADD")]),e._v("、"),s("code",[e._v("COPY")]),e._v("、"),s("code",[e._v("ENV")]),e._v("、"),s("code",[e._v("EXPOSE")]),e._v("、"),s("code",[e._v("LABEL")]),e._v("、"),s("code",[e._v("USER")]),e._v("、"),s("code",[e._v("WORKDIR")]),e._v("、"),s("code",[e._v("VOLUME")]),e._v("、"),s("code",[e._v("STOPSIGNAL")]),e._v("、"),s("code",[e._v("ONBUILD")]),e._v("。")]),e._v(" "),s("p",[e._v("可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 "),s("code",[e._v("Dockerfile")]),e._v(" 制作更多的镜像，只需使用不同的环境变量即可。")]),e._v(" "),s("h3",{attrs:{id:"arg构建参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#arg构建参数","aria-hidden":"true"}},[e._v("#")]),e._v(" ARG构建参数")]),e._v(" "),s("p",[e._v("格式："),s("code",[e._v("ARG <参数名>[=<默认值>]")])]),e._v(" "),s("p",[e._v("构建参数和 "),s("code",[e._v("ENV")]),e._v(" 的效果一样，都是设置环境变量。所不同的是，"),s("code",[e._v("ARG")]),e._v(" 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 "),s("code",[e._v("ARG")]),e._v(" 保存密码之类的信息，因为 "),s("code",[e._v("docker history")]),e._v(" 还是可以看到所有值的。")]),e._v(" "),s("p",[s("code",[e._v("Dockerfile")]),e._v(" 中的 "),s("code",[e._v("ARG")]),e._v(" 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 "),s("code",[e._v("docker build")]),e._v(" 中用 "),s("code",[e._v("--build-arg <参数名>=<值>")]),e._v(" 来覆盖。")]),e._v(" "),s("p",[e._v("在 1.13 之前的版本，要求 "),s("code",[e._v("--build-arg")]),e._v(" 中的参数名，必须在 "),s("code",[e._v("Dockerfile")]),e._v(" 中用 "),s("code",[e._v("ARG")]),e._v(" 定义过了，换句话说，就是 "),s("code",[e._v("--build-arg")]),e._v(" 指定的参数，必须在 "),s("code",[e._v("Dockerfile")]),e._v(" 中使用了。如果对应参数没有被使用，则会报错退出构建。从 1.13 开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用 CI 系统，用同样的构建流程构建不同的 "),s("code",[e._v("Dockerfile")]),e._v(" 的时候比较有帮助，避免构建命令必须根据每个 Dockerfile 的内容修改。")]),e._v(" "),s("h3",{attrs:{id:"volume定义匿名卷"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#volume定义匿名卷","aria-hidden":"true"}},[e._v("#")]),e._v(" VOLUME定义匿名卷")]),e._v(" "),s("p",[e._v("格式为：")]),e._v(" "),s("ul",[s("li",[s("code",[e._v('VOLUME ["<路径1>", "<路径2>"...]')])]),e._v(" "),s("li",[s("code",[e._v("VOLUME <路径>")])])]),e._v(" "),s("p",[e._v("之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 "),s("code",[e._v("Dockerfile")]),e._v(" 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("VOLUME")]),e._v(" /data\n")])])]),s("p",[e._v("这里的 "),s("code",[e._v("/data")]),e._v(" 目录就会在运行时自动挂载为匿名卷，任何向 "),s("code",[e._v("/data")]),e._v(" 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("docker run -d -v mydata:/data xxxx\n")])])]),s("p",[e._v("在这行命令中，就使用了 "),s("code",[e._v("mydata")]),e._v(" 这个命名卷挂载到了 "),s("code",[e._v("/data")]),e._v(" 这个位置，替代了 "),s("code",[e._v("Dockerfile")]),e._v(" 中定义的匿名卷的挂载配置。")]),e._v(" "),s("h3",{attrs:{id:"expose暴露端口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#expose暴露端口","aria-hidden":"true"}},[e._v("#")]),e._v(" EXPOSE暴露端口")]),e._v(" "),s("p",[e._v("格式为 "),s("code",[e._v("EXPOSE <端口1> [<端口2>...]")]),e._v("。")]),e._v(" "),s("p",[s("code",[e._v("EXPOSE")]),e._v(" 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 "),s("code",[e._v("docker run -P")]),e._v(" 时，会自动随机映射 "),s("code",[e._v("EXPOSE")]),e._v(" 的端口。")]),e._v(" "),s("p",[e._v("此外，在早期 Docker 版本中还有一个特殊的用处。以前所有容器都运行于默认桥接网络中，因此所有容器互相之间都可以直接访问，这样存在一定的安全性问题。于是有了一个 Docker 引擎参数 "),s("code",[e._v("--icc=false")]),e._v("，当指定该参数后，容器间将默认无法互访，除非互相间使用了 "),s("code",[e._v("--links")]),e._v(" 参数的容器才可以互通，并且只有镜像中 "),s("code",[e._v("EXPOSE")]),e._v(" 所声明的端口才可以被访问。这个 "),s("code",[e._v("--icc=false")]),e._v(" 的用法，在引入了 "),s("code",[e._v("docker network")]),e._v(" 后已经基本不用了，通过自定义网络可以很轻松的实现容器间的互联与隔离。")]),e._v(" "),s("p",[e._v("要将 "),s("code",[e._v("EXPOSE")]),e._v(" 和在运行时使用 "),s("code",[e._v("-p <宿主端口>:<容器端口>")]),e._v(" 区分开来。"),s("code",[e._v("-p")]),e._v("，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 "),s("code",[e._v("EXPOSE")]),e._v(" 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。")]),e._v(" "),s("h3",{attrs:{id:"workdir指定工作目录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#workdir指定工作目录","aria-hidden":"true"}},[e._v("#")]),e._v(" WORKDIR指定工作目录")]),e._v(" "),s("p",[e._v("格式为 "),s("code",[e._v("WORKDIR <工作目录路径>")]),e._v("。")]),e._v(" "),s("p",[e._v("使用 "),s("code",[e._v("WORKDIR")]),e._v(" 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，"),s("code",[e._v("WORKDIR")]),e._v(" 会帮你建立目录。")]),e._v(" "),s("p",[e._v("之前提到一些初学者常犯的错误是把 "),s("code",[e._v("Dockerfile")]),e._v(" 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：")]),e._v(" "),s("div",{staticClass:"language-docker extra-class"},[s("pre",{pre:!0,attrs:{class:"language-docker"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" cd /app\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" echo "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"hello"')]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")]),e._v(" world.txt\n")])])]),s("p",[e._v("如果将这个 "),s("code",[e._v("Dockerfile")]),e._v(" 进行构建镜像运行后，会发现找不到 "),s("code",[e._v("/app/world.txt")]),e._v(" 文件，或者其内容不是 "),s("code",[e._v("hello")]),e._v("。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 "),s("code",[e._v("Dockerfile")]),e._v(" 中，这两行 "),s("code",[e._v("RUN")]),e._v(" 命令的执行环境根本不同，是两个完全不同的容器。这就是对 "),s("code",[e._v("Dockerfile")]),e._v(" 构建分层存储的概念不了解所导致的错误。")]),e._v(" "),s("p",[e._v("之前说过每一个 "),s("code",[e._v("RUN")]),e._v(" 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 "),s("code",[e._v("RUN cd /app")]),e._v("的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。")]),e._v(" "),s("p",[e._v("因此如果需要改变以后各层的工作目录的位置，那么应该使用 "),s("code",[e._v("WORKDIR")]),e._v(" 指令。")]),e._v(" "),s("h3",{attrs:{id:"user-指定当前用户"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#user-指定当前用户","aria-hidden":"true"}},[e._v("#")]),e._v(" USER 指定当前用户")]),e._v(" "),s("p",[e._v("格式："),s("code",[e._v("USER <用户名>")])]),e._v(" "),s("p",[s("code",[e._v("USER")]),e._v(" 指令和 "),s("code",[e._v("WORKDIR")]),e._v(" 相似，都是改变环境状态并影响以后的层。"),s("code",[e._v("WORKDIR")]),e._v(" 是改变工作目录，"),s("code",[e._v("USER")]),e._v(" 则是改变之后层的执行 "),s("code",[e._v("RUN")]),e._v(", "),s("code",[e._v("CMD")]),e._v(" 以及 "),s("code",[e._v("ENTRYPOINT")]),e._v(" 这类命令的身份。")]),e._v(" "),s("p",[e._v("当然，和 "),s("code",[e._v("WORKDIR")]),e._v(" 一样，"),s("code",[e._v("USER")]),e._v(" 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。")]),e._v(" "),s("div",{staticClass:"language-text extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('RUN groupadd -r redis && useradd -r -g redis redis\nUSER redis\nRUN [ "redis-server" ]\n')])])]),s("p",[e._v("如果以 "),s("code",[e._v("root")]),e._v(" 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 "),s("code",[e._v("su")]),e._v(" 或者 "),s("code",[e._v("sudo")]),e._v("，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 "),s("a",{attrs:{href:"https://github.com/tianon/gosu",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("gosu")]),s("OutboundLink")],1),e._v("。")]),e._v(" "),s("div",{staticClass:"language-text extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('# 建立 redis 用户，并使用 gosu 换另一个用户执行命令\nRUN groupadd -r redis && useradd -r -g redis redis\n# 下载 gosu\nRUN wget -O /usr/local/bin/gosu "https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64" \\\n    && chmod +x /usr/local/bin/gosu \\\n    && gosu nobody true\n# 设置 CMD，并以另外的用户执行\nCMD [ "exec", "gosu", "redis", "redis-server" ]\n')])])]),s("h3",{attrs:{id:"healthcheck-健康检查"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#healthcheck-健康检查","aria-hidden":"true"}},[e._v("#")]),e._v(" HEALTHCHECK 健康检查")]),e._v(" "),s("p",[e._v("格式：")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("HEALTHCHECK [选项] CMD <命令>")]),e._v("：设置检查容器健康状况的命令")]),e._v(" "),s("li",[s("code",[e._v("HEALTHCHECK NONE")]),e._v("：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令")])]),e._v(" "),s("p",[s("code",[e._v("HEALTHCHECK")]),e._v(" 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。")]),e._v(" "),s("p",[e._v("在没有 "),s("code",[e._v("HEALTHCHECK")]),e._v(" 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。")]),e._v(" "),s("p",[e._v("而自 1.12 之后，Docker 提供了 "),s("code",[e._v("HEALTHCHECK")]),e._v(" 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。")]),e._v(" "),s("p",[e._v("当在一个镜像指定了 "),s("code",[e._v("HEALTHCHECK")]),e._v(" 指令后，用其启动容器，初始状态会为 "),s("code",[e._v("starting")]),e._v("，在 "),s("code",[e._v("HEALTHCHECK")]),e._v(" 指令检查成功后变为 "),s("code",[e._v("healthy")]),e._v("，如果连续一定次数失败，则会变为 "),s("code",[e._v("unhealthy")]),e._v("。")]),e._v(" "),s("p",[s("code",[e._v("HEALTHCHECK")]),e._v(" 支持下列选项：")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("--interval=<间隔>")]),e._v("：两次健康检查的间隔，默认为 30 秒；")]),e._v(" "),s("li",[s("code",[e._v("--timeout=<时长>")]),e._v("：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；")]),e._v(" "),s("li",[s("code",[e._v("--retries=<次数>")]),e._v("：当连续失败指定次数后，则将容器状态视为 "),s("code",[e._v("unhealthy")]),e._v("，默认 3 次。")])]),e._v(" "),s("p",[e._v("和 "),s("code",[e._v("CMD")]),e._v(", "),s("code",[e._v("ENTRYPOINT")]),e._v(" 一样，"),s("code",[e._v("HEALTHCHECK")]),e._v(" 只可以出现一次，如果写了多个，只有最后一个生效。")]),e._v(" "),s("p",[e._v("在 "),s("code",[e._v("HEALTHCHECK [选项] CMD")]),e._v(" 后面的命令，格式和 "),s("code",[e._v("ENTRYPOINT")]),e._v(" 一样，分为 "),s("code",[e._v("shell")]),e._v(" 格式，和 "),s("code",[e._v("exec")]),e._v("格式。命令的返回值决定了该次健康检查的成功与否："),s("code",[e._v("0")]),e._v("：成功；"),s("code",[e._v("1")]),e._v("：失败；"),s("code",[e._v("2")]),e._v("：保留，不要使用这个值。")]),e._v(" "),s("p",[e._v("假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 "),s("code",[e._v("curl")]),e._v(" 来帮助判断，其 "),s("code",[e._v("Dockerfile")]),e._v(" 的 "),s("code",[e._v("HEALTHCHECK")]),e._v(" 可以这么写：")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("FROM")]),e._v(" nginx\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" apt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("get update && apt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("get install "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("y curl && rm "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("rf /var/lib/apt/lists/*\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("HEALTHCHECK")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("interval=5s "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("timeout=3s \\\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("CMD")]),e._v(" curl "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("fs http"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("//localhost/ "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" exit 1\n")])])]),s("p",[e._v("这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 "),s("code",[e._v("curl -fs http://localhost/ || exit 1")]),e._v(" 作为健康检查命令。")]),e._v(" "),s("p",[e._v("使用 "),s("code",[e._v("docker build")]),e._v(" 来构建这个镜像：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker build -t myweb:v1 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v(".")]),e._v("\n")])])]),s("p",[e._v("构建好了后，我们启动一个容器：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker run -d --name web -p 80:80 myweb:v1\n")])])]),s("p",[e._v("当运行该镜像后，可以通过 "),s("code",[e._v("docker container ls")]),e._v(" 看到最初的状态为 "),s("code",[e._v("(health: starting)")]),e._v("：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker container "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v("\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                            PORTS               NAMES\n03e28eb00bd0        myweb:v1            "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"nginx -g \'daemon off"')]),e._v("   3 seconds ago       Up 2 seconds "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("health: starting"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("   80/tcp, 443/tcp     web\n")])])]),s("p",[e._v("在等待几秒钟后，再次 "),s("code",[e._v("docker container ls")]),e._v("，就会看到健康状态变化为了 "),s("code",[e._v("(healthy)")]),e._v("：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker container "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v("\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                    PORTS               NAMES\n03e28eb00bd0        myweb:v1            "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"nginx -g \'daemon off"')]),e._v("   18 seconds ago      Up 16 seconds "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("healthy"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("   80/tcp, 443/tcp     web\n")])])]),s("p",[e._v("如果健康检查连续失败超过了重试次数，状态就会变为 "),s("code",[e._v("(unhealthy)")]),e._v("。")]),e._v(" "),s("p",[e._v("为了帮助排障，健康检查命令的输出（包括 "),s("code",[e._v("stdout")]),e._v(" 以及 "),s("code",[e._v("stderr")]),e._v("）都会被存储于健康状态里，可以用 "),s("code",[e._v("docker inspect")]),e._v(" 来查看。")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker inspect --format "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'{{json .State.Health}}'")]),e._v(" web "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v(" python -m json.tool\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"FailingStreak"')]),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v(":")]),e._v(" 0,\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Log"')]),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n            "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"End"')]),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"2016-11-25T14:35:37.940957051Z"')]),e._v(",\n            "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"ExitCode"')]),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v(":")]),e._v(" 0,\n            "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Output"')]),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"<!DOCTYPE html>\\n<html>\\n<head>\\n<title>Welcome to nginx!</title>\\n<style>\\n    body {\\n        width: 35em;\\n        margin: 0 auto;\\n        font-family: Tahoma, Verdana, Arial, sans-serif;\\n    }\\n</style>\\n</head>\\n<body>\\n<h1>Welcome to nginx!</h1>\\n<p>If you see this page, the nginx web server is successfully installed and\\nworking. Further configuration is required.</p>\\n\\n<p>For online documentation and support please refer to\\n<a href=\\"http://nginx.org/\\">nginx.org</a>.<br/>\\nCommercial support is available at\\n<a href=\\"http://nginx.com/\\">nginx.com</a>.</p>\\n\\n<p><em>Thank you for using nginx.</em></p>\\n</body>\\n</html>\\n"')]),e._v(",\n            "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Start"')]),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"2016-11-25T14:35:37.780192565Z"')]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(",\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Status"')]),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"healthy"')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),s("h3",{attrs:{id:"onbuild-为他人作嫁衣"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#onbuild-为他人作嫁衣","aria-hidden":"true"}},[e._v("#")]),e._v(" ONBUILD 为他人作嫁衣")]),e._v(" "),s("p",[e._v("格式："),s("code",[e._v("ONBUILD <其它指令>")]),e._v("。")]),e._v(" "),s("p",[s("code",[e._v("ONBUILD")]),e._v(" 是一个特殊的指令，它后面跟的是其它指令，比如 "),s("code",[e._v("RUN")]),e._v(", "),s("code",[e._v("COPY")]),e._v(" 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。")]),e._v(" "),s("p",[s("code",[e._v("Dockerfile")]),e._v(" 中的其它指令都是为了定制当前镜像而准备的，唯有 "),s("code",[e._v("ONBUILD")]),e._v(" 是为了帮助别人定制自己而准备的。")]),e._v(" "),s("p",[e._v("假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 "),s("code",[e._v("npm")]),e._v(" 进行包管理，所有依赖、配置、启动信息等会放到 "),s("code",[e._v("package.json")]),e._v(" 文件里。在拿到程序代码后，需要先进行 "),s("code",[e._v("npm install")]),e._v(" 才可以获得所有需要的依赖。然后就可以通过 "),s("code",[e._v("npm start")]),e._v(" 来启动应用。因此，一般来说会这样写 "),s("code",[e._v("Dockerfile")]),e._v("：")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("FROM")]),e._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("slim\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" mkdir /app\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("WORKDIR")]),e._v(" /app\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("COPY")]),e._v(" ./package.json /app\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"npm"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"install"')]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("COPY")]),e._v(" . /app/\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("CMD")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"npm"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"start"')]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n")])])]),s("p",[e._v("把这个 "),s("code",[e._v("Dockerfile")]),e._v(" 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 "),s("code",[e._v("Dockerfile")]),e._v(" 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。")]),e._v(" "),s("p",[e._v("如果第一个 Node.js 项目在开发过程中，发现这个 "),s("code",[e._v("Dockerfile")]),e._v(" 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 "),s("code",[e._v("Dockerfile")]),e._v("，再次构建，问题解决。\b第一个项目没问题了，但是第二个项目呢？虽然最初 "),s("code",[e._v("Dockerfile")]),e._v(" 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 "),s("code",[e._v("Dockerfile")]),e._v("，而第二个项目的 "),s("code",[e._v("Dockerfile")]),e._v(" 就会被自动修复。")]),e._v(" "),s("p",[e._v("那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 "),s("code",[e._v("Dockerfile")]),e._v(" 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 "),s("code",[e._v("Dockerfile")]),e._v(" 就会变为：")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("FROM")]),e._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("slim\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" mkdir /app\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("WORKDIR")]),e._v(" /app\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("CMD")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"npm"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"start"')]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n")])])]),s("p",[e._v("这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 "),s("code",[e._v("my-node")]),e._v(" 的话，各个项目内的自己的 "),s("code",[e._v("Dockerfile")]),e._v(" 就变为：")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("FROM")]),e._v(" my"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("node\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("COPY")]),e._v(" ./package.json /app\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"npm"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"install"')]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("COPY")]),e._v(" . /app/\n")])])]),s("p",[e._v("基础镜像变化后，各个项目都用这个 "),s("code",[e._v("Dockerfile")]),e._v(" 重新构建镜像，会继承基础镜像的更新。")]),e._v(" "),s("p",[e._v("那么，问题解决了么？没有。准确说，只解决了一半。如果这个 "),s("code",[e._v("Dockerfile")]),e._v(" 里面有些东西需要调整呢？比如 "),s("code",[e._v("npm install")]),e._v(" 都需要加一些参数，那怎么办？这一行 "),s("code",[e._v("RUN")]),e._v(" 是不可能放入基础镜像的，因为涉及到了当前项目的 "),s("code",[e._v("./package.json")]),e._v("，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 "),s("code",[e._v("Dockerfile")]),e._v(" 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。")]),e._v(" "),s("p",[s("code",[e._v("ONBUILD")]),e._v(" 可以解决这个问题。让我们用 "),s("code",[e._v("ONBUILD")]),e._v(" 重新写一下基础镜像的 "),s("code",[e._v("Dockerfile")]),e._v(":")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("FROM")]),e._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("slim\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" mkdir /app\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("WORKDIR")]),e._v(" /app\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("ONBUILD")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("COPY")]),e._v(" ./package.json /app\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("ONBUILD")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"npm"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"install"')]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("ONBUILD")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("COPY")]),e._v(" . /app/\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("CMD")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"npm"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"start"')]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n")])])]),s("p",[e._v("这次我们回到原始的 "),s("code",[e._v("Dockerfile")]),e._v("，但是这次将项目相关的指令加上 "),s("code",[e._v("ONBUILD")]),e._v("，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 "),s("code",[e._v("Dockerfile")]),e._v(" 就变成了简单地：")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("FROM")]),e._v(" my"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("node\n")])])]),s("p",[e._v("是的，只有这么一行。当在各个项目目录中，用这个只有一行的 "),s("code",[e._v("Dockerfile")]),e._v(" 构建镜像时，之前基础镜像的那三行 "),s("code",[e._v("ONBUILD")]),e._v(" 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 "),s("code",[e._v("npm install")]),e._v("，生成应用镜像。")]),e._v(" "),s("h2",{attrs:{id:"dockerfile-多阶段构建"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dockerfile-多阶段构建","aria-hidden":"true"}},[e._v("#")]),e._v(" Dockerfile 多阶段构建")]),e._v(" "),s("h3",{attrs:{id:"之前的做法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#之前的做法","aria-hidden":"true"}},[e._v("#")]),e._v(" 之前的做法")]),e._v(" "),s("p",[e._v("在 Docker 17.05 版本之前，我们构建 Docker 镜像时，通常会采用两种方式：")]),e._v(" "),s("h4",{attrs:{id:"全部放入一个-dockerfile"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#全部放入一个-dockerfile","aria-hidden":"true"}},[e._v("#")]),e._v(" 全部放入一个 Dockerfile")]),e._v(" "),s("p",[e._v("一种方式是将所有的构建过程编包含在一个 "),s("code",[e._v("Dockerfile")]),e._v(" 中，包括项目及其依赖库的编译、测试、打包等流程，这里可能会带来的一些问题：")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("Dockerfile")]),e._v(" 特别长，可维护性降低")]),e._v(" "),s("li",[e._v("镜像层次多，镜像体积较大，部署时间变长")]),e._v(" "),s("li",[e._v("源代码存在泄露的风险")])]),e._v(" "),s("p",[e._v("例如")]),e._v(" "),s("p",[e._v("编写 "),s("code",[e._v("app.go")]),e._v(" 文件，该程序输出 "),s("code",[e._v("Hello World!")])]),e._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("package")]),e._v(" main  \n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("import")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"fmt"')]),e._v("  \n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("func")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("  \n    fmt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("Printf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Hello World!"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),s("p",[e._v("编写 "),s("code",[e._v("Dockerfile.one")]),e._v(" 文件")]),e._v(" "),s("div",{staticClass:"language-docker extra-class"},[s("pre",{pre:!0,attrs:{class:"language-docker"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("FROM")]),e._v(" golang"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("1.9"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("alpine\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" apk "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("no"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("cache add git ca"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("certificates\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("WORKDIR")]),e._v(" /go/src/github.com/go/helloworld/\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("COPY")]),e._v(" app.go .\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" go get "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("d "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("v github.com/go"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("sql"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("driver/mysql \\\n  && CGO_ENABLED=0 GOOS=linux go build "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("a "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("installsuffix cgo "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("o app . \\\n  && cp /go/src/github.com/go/helloworld/app /root\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("WORKDIR")]),e._v(" /root/\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("CMD")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"./app"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n")])])]),s("p",[e._v("构建镜像")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker build -t go/helloworld:1 -f Dockerfile.one "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v(".")]),e._v("\n")])])]),s("h4",{attrs:{id:"分散到多个-dockerfile"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分散到多个-dockerfile","aria-hidden":"true"}},[e._v("#")]),e._v(" 分散到多个 Dockerfile")]),e._v(" "),s("p",[e._v("另一种方式，就是我们事先在一个 "),s("code",[e._v("Dockerfile")]),e._v(" 将项目及其依赖库编译测试打包好后，再将其拷贝到运行环境中，这种方式需要我们编写两个 "),s("code",[e._v("Dockerfile")]),e._v(" 和一些编译脚本才能将其两个阶段自动整合起来，这种方式虽然可以很好地规避第一种方式存在的风险，但明显部署过程较复杂。")]),e._v(" "),s("p",[e._v("例如")]),e._v(" "),s("p",[e._v("编写 "),s("code",[e._v("Dockerfile.build")]),e._v(" 文件")]),e._v(" "),s("div",{staticClass:"language-docker extra-class"},[s("pre",{pre:!0,attrs:{class:"language-docker"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("FROM")]),e._v(" golang"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("1.9"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("alpine\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" apk "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("no"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("cache add git\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("WORKDIR")]),e._v(" /go/src/github.com/go/helloworld\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("COPY")]),e._v(" app.go .\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" go get "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("d "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("v github.com/go"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("sql"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("driver/mysql \\\n  && CGO_ENABLED=0 GOOS=linux go build "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("a "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("installsuffix cgo "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("o app .\n")])])]),s("p",[e._v("编写 "),s("code",[e._v("Dockerfile.copy")]),e._v(" 文件")]),e._v(" "),s("div",{staticClass:"language-docker extra-class"},[s("pre",{pre:!0,attrs:{class:"language-docker"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("FROM")]),e._v(" alpine"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("latest\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" apk "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("no"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("cache add ca"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("certificates\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("WORKDIR")]),e._v(" /root/\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("COPY")]),e._v(" app .\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("CMD")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"./app"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n")])])]),s("p",[e._v("新建 "),s("code",[e._v("build.sh")])]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token shebang important"}},[e._v("#!/bin/sh")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("echo")]),e._v(" Building go/helloworld:build\n\ndocker build -t go/helloworld:build "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v(".")]),e._v(" -f Dockerfile.build\n\ndocker create --name extract go/helloworld:build\ndocker "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("cp")]),e._v(" extract:/go/src/github.com/go/helloworld/app ./app\ndocker "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("rm")]),e._v(" -f extract\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("echo")]),e._v(" Building go/helloworld:2\n\ndocker build --no-cache -t go/helloworld:2 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v(".")]),e._v(" -f Dockerfile.copy\n"),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("rm")]),e._v(" ./app\n")])])]),s("p",[e._v("现在运行脚本即可构建镜像")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("chmod")]),e._v(" +x build.sh\n\n$ ./build.sh\n")])])]),s("p",[e._v("对比两种方式生成的镜像大小")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker image "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v("\n\nREPOSITORY      TAG    IMAGE ID        CREATED         SIZE\ngo/helloworld   2      f7cf3465432c    22 seconds ago  6.47MB\ngo/helloworld   1      f55d3e16affc    2 minutes ago   295MB\n")])])]),s("h3",{attrs:{id:"使用多阶段构建"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用多阶段构建","aria-hidden":"true"}},[e._v("#")]),e._v(" 使用多阶段构建")]),e._v(" "),s("p",[e._v("为解决以上问题，Docker v17.05 开始支持多阶段构建 ("),s("code",[e._v("multistage builds")]),e._v(")。使用多阶段构建我们就可以很容易解决前面提到的问题，并且只需要编写一个 "),s("code",[e._v("Dockerfile")]),e._v("：")]),e._v(" "),s("p",[e._v("例如")]),e._v(" "),s("p",[e._v("编写 "),s("code",[e._v("Dockerfile")]),e._v(" 文件")]),e._v(" "),s("div",{staticClass:"language-docker extra-class"},[s("pre",{pre:!0,attrs:{class:"language-docker"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("FROM")]),e._v(" golang"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("1.9"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("alpine as builder\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" apk "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("no"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("cache add git\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("WORKDIR")]),e._v(" /go/src/github.com/go/helloworld/\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" go get "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("d "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("v github.com/go"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("sql"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("driver/mysql\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("COPY")]),e._v(" app.go .\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" CGO_ENABLED=0 GOOS=linux go build "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("a "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("installsuffix cgo "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("o app .\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("FROM")]),e._v(" alpine"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("latest as prod\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RUN")]),e._v(" apk "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("no"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("cache add ca"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("certificates\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("WORKDIR")]),e._v(" /root/\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("COPY")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("from=0 /go/src/github.com/go/helloworld/app .\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("CMD")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"./app"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("  \n")])])]),s("p",[e._v("构建镜像")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker build -t go/helloworld:3 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v(".")]),e._v("\n")])])]),s("p",[e._v("对比三个镜像大小")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker image "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v("\n\nREPOSITORY        TAG   IMAGE ID         CREATED            SIZE\ngo/helloworld     3     d6911ed9c846     7 seconds ago      6.47MB\ngo/helloworld     2     f7cf3465432c     22 seconds ago     6.47MB\ngo/helloworld     1     f55d3e16affc     2 minutes ago      295MB\n")])])]),s("p",[e._v("很明显使用多阶段构建的镜像体积小，同时也完美解决了上边提到的问题。")]),e._v(" "),s("h4",{attrs:{id:"只构建某一阶段的镜像"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#只构建某一阶段的镜像","aria-hidden":"true"}},[e._v("#")]),e._v(" 只构建某一阶段的镜像")]),e._v(" "),s("p",[e._v("我们可以使用 "),s("code",[e._v("as")]),e._v(" 来为某一阶段命名，例如")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("FROM")]),e._v(" golang"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("1.9"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("alpine as builder\n")])])]),s("p",[e._v("例如当我们只想构建 "),s("code",[e._v("builder")]),e._v(" 阶段的镜像时，我们可以在使用 "),s("code",[e._v("docker build")]),e._v(" 命令时加上 "),s("code",[e._v("--target")]),e._v("参数即可")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker build --target builder -t username/imagename:tag "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v(".")]),e._v("\n")])])]),s("h4",{attrs:{id:"构建时从其他镜像复制文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构建时从其他镜像复制文件","aria-hidden":"true"}},[e._v("#")]),e._v(" 构建时从其他镜像复制文件")]),e._v(" "),s("p",[e._v("上面例子中我们使用 "),s("code",[e._v("COPY --from=0 /go/src/github.com/go/helloworld/app .")]),e._v(" 从上一阶段的镜像中复制文件，我们也可以复制任意镜像中的文件。")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[e._v("$ COPY "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("from=nginx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("latest /etc/nginx/nginx.conf /nginx.conf\n")])])]),s("h2",{attrs:{id:"其它制作镜像的方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#其它制作镜像的方式","aria-hidden":"true"}},[e._v("#")]),e._v(" 其它制作镜像的方式")]),e._v(" "),s("p",[e._v("除了标准的使用 "),s("code",[e._v("Dockerfile")]),e._v(" 生成镜像的方法外，由于各种特殊需求和历史原因，还提供了一些其它方法用以生成镜像。")]),e._v(" "),s("h3",{attrs:{id:"从-rootfs-压缩包导入"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#从-rootfs-压缩包导入","aria-hidden":"true"}},[e._v("#")]),e._v(" 从 rootfs 压缩包导入")]),e._v(" "),s("p",[e._v("格式："),s("code",[e._v("docker import [选项] <文件>|<URL>|- [<仓库名>[:<标签>]]")])]),e._v(" "),s("p",[e._v("压缩包可以是本地文件、远程 Web 文件，甚至是从标准输入中得到。压缩包将会在镜像 "),s("code",[e._v("/")]),e._v(" 目录展开，并直接作为镜像第一层提交。")]),e._v(" "),s("p",[e._v("比如我们想要创建一个 "),s("a",{attrs:{href:"https://openvz.org/Main_Page",target:"_blank",rel:"noopener noreferrer"}},[e._v("OpenVZ"),s("OutboundLink")],1),e._v(" 的 Ubuntu 14.04 "),s("a",{attrs:{href:"https://openvz.org/Download/template/precreated",target:"_blank",rel:"noopener noreferrer"}},[e._v("模板"),s("OutboundLink")],1),e._v("的镜像：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("import")]),e._v(" \\\n    http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz \\\n    openvz/ubuntu:14.04\nDownloading from http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz\nsha256:f477a6e18e989839d25223f301ef738b69621c4877600ae6467c4e5289822a79B/78.42 MB\n")])])]),s("p",[e._v("这条命令自动下载了 "),s("code",[e._v("ubuntu-14.04-x86_64-minimal.tar.gz")]),e._v(" 文件，并且作为根文件系统展开导入，并保存为镜像 "),s("code",[e._v("openvz/ubuntu:14.04")]),e._v("。")]),e._v(" "),s("p",[e._v("导入成功后，我们可以用 "),s("code",[e._v("docker image ls")]),e._v(" 看到这个导入的镜像：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker image "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v(" openvz/ubuntu\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nopenvz/ubuntu       14.04               f477a6e18e98        55 seconds ago      214.9 MB\n")])])]),s("p",[e._v("如果我们查看其历史的话，会看到描述中有导入的文件链接：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("history")]),e._v(" openvz/ubuntu:14.04\nIMAGE               CREATED              CREATED BY          SIZE                COMMENT\nf477a6e18e98        About a minute ago                       214.9 MB            Imported from http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz\n")])])]),s("h3",{attrs:{id:"docker-save-和-docker-load"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker-save-和-docker-load","aria-hidden":"true"}},[e._v("#")]),e._v(" "),s("code",[e._v("docker save")]),e._v(" 和 "),s("code",[e._v("docker load")])]),e._v(" "),s("p",[e._v("Docker 还提供了 "),s("code",[e._v("docker load")]),e._v(" 和 "),s("code",[e._v("docker save")]),e._v(" 命令，用以将镜像保存为一个 "),s("code",[e._v("tar")]),e._v(" 文件，然后传输到另一个位置上，再加载进来。这是在没有 Docker Registry 时的做法，现在已经不推荐，镜像迁移应该直接使用 Docker Registry，无论是直接使用 Docker Hub 还是使用内网私有 Registry 都可以。")]),e._v(" "),s("p",[e._v("使用 "),s("code",[e._v("docker save")]),e._v(" 命令可以将镜像保存为归档文件。")]),e._v(" "),s("p",[e._v("比如我们希望保存这个 "),s("code",[e._v("alpine")]),e._v(" 镜像。")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker image "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v(" alpine\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nalpine              latest              baa5d63471ea        5 weeks ago         4.803 MB\n")])])]),s("p",[e._v("保存镜像的命令为：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker save alpine "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("gzip")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" alpine-latest.tar.gz\n")])])]),s("p",[e._v("然后我们将 "),s("code",[e._v("alpine-latest.tar.gz")]),e._v(" 文件复制到了到了另一个机器上，可以用下面这个命令加载镜像：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker load -i alpine-latest.tar.gz\nLoaded image: alpine:latest\n")])])]),s("p",[e._v("如果我们结合这两个命令以及 "),s("code",[e._v("ssh")]),e._v(" 甚至 "),s("code",[e._v("pv")]),e._v(" 的话，利用 Linux 强大的管道，我们可以写一个命令完成从一个机器将镜像迁移到另一个机器，并且带进度条的功能：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("docker save "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("镜像名"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("bzip2")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("pv")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("ssh")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("用户名"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("@"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("主机名"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'cat | docker load'")]),e._v("\n")])])])])},[],!1,null,null,null);a.default=r.exports}}]);