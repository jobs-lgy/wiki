(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{206:function(a,e,t){"use strict";t.r(e);var r=t(0),s=Object(r.a)({},function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"yarn"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#yarn","aria-hidden":"true"}},[a._v("#")]),a._v(" Yarn")]),a._v(" "),t("h2",{attrs:{id:"yarn概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#yarn概述","aria-hidden":"true"}},[a._v("#")]),a._v(" Yarn概述")]),a._v(" "),t("p",[a._v("Yarn是一个资源调度平台，负责为运算程序提供服务器运算资源，相当于一个分布式的操作系统平台，而MapReduce等运算程序则相当于运行于操作程序上的应用程序。")]),a._v(" "),t("p",[a._v("YARN是Hadoop 2.0中的资源管理系统，它的基本设计思想是将MRv1（即Hadoop 1.0）中的JobTracker拆分成了两个独立的服务：一个全局的资源管理器ResourceManager和每个应用程序特有的ApplicationMaster。")]),a._v(" "),t("p",[a._v("其中ResourceManager负责整个系统的资源管理和分配，具体的资源调整算法策略采用热插拔的形式自由配置，而ApplicationMaster负责单个应用程序的管理、包括自由申请、分配、container 的启停等。")]),a._v(" "),t("p",[a._v("YARN总体上仍然是Master/Slave结构，在整个资源管理框架中，ResourceManager为Master，NodeManager为Slave， ResourceManager负责对各个NodeManager上的资源进行统一管理和调度。当用户提交一个应用程序时，需要提供一个用以跟踪和管理这个程序的ApplicationMaster，它负责向ResourceManager申请资源，并要求NodeManger启动可以占用一定资源的任务。由于不同的ApplicationMaster被分布到不同的节点上，因此它们之间不会相互影响。")]),a._v(" "),t("p",[a._v("YARN的基本组成结构，YARN主要由ResourceManager、NodeManager、ApplicationMaster(无论mapreduce/hive、spark、storm)和Container等几个组件构成。")]),a._v(" "),t("p",[a._v("ResourceManager是Master上一个独立运行的进程，负责集群统一的资源管理、调度、分配等等；NodeManager是Slave上一个独立运行的进程，负责上报节点的状态；App Master和Container是运行在Slave上的组件，Container是yarn中分配资源的一个单位，包括内存、CPU等等资源，yarn以Container为单位分配资源。Client向ResourceManager提交的每一个应用程序都必须有一个Application Master，它经过ResourceManager分配资源后，运行于某一个Slave节点的Container中，具体做事情的Task，同样也运行与某一个Slave节点的Container中。RM，NM，AM乃至普通的Container之间的通信，都是用RPC机制。")]),a._v(" "),t("h2",{attrs:{id:"yarn架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#yarn架构","aria-hidden":"true"}},[a._v("#")]),a._v(" Yarn架构")]),a._v(" "),t("p",[a._v("Yarn主要由ResourceManager、NodeManager、ApplicationMater和Container等组件构成")]),a._v(" "),t("p",[t("img",{attrs:{src:"http://ww2.sinaimg.cn/large/006tNc79gy1g5aauyif7nj31oy0u0tmx.jpg",alt:"img"}})]),a._v(" "),t("p",[t("strong",[a._v("Resourcemanager")])]),a._v(" "),t("p",[a._v("RM是一个全局的资源管理器，集群只有一个，负责整个系统的资源管理和分配，包括处理客户端请求、启动/监控APP master、监控nodemanager、资源的分配与调度。它主要由两个组件构成：调度器（Scheduler）和应用程序管理器（Applications Manager，ASM）。")]),a._v(" "),t("p",[t("strong",[a._v("调度器")])]),a._v(" "),t("p",[a._v("调度器根据容量、队列等限制条件（如每个队列分配一定的资源，最多执行一定数量的作业等），将系统中的资源分配给各个正在运行的应用程序。需要注意的是，该调度器是一个“纯调度器”，它不再从事任何与具体应用程序相关的工作，比如不负责监控或者跟踪应用的执行状态等，也不负责重新启动因应用执行失败或者硬件故障而产生的失败任务，这些均交由应用程序相关的ApplicationMaster完成。调度器仅根据各个应用程序的资源需求进行资源分配，而资源分配单位用一个抽象概念“资源容器”（Resource Container，简称Container）表示，Container是一个动态资源分配单位，它将内存、CPU、磁盘、网络等资源封装在一起，从而限定每个任务使用的资源量。此外，该调度器是一个可插拔的组件，用户可根据自己的需要设计新的调度器，YARN提供了多种直接可用的调度器，比如Fair Scheduler和Capacity Scheduler等。")]),a._v(" "),t("p",[t("strong",[a._v("应用程序管理器")])]),a._v(" "),t("p",[a._v("应用程序管理器负责管理整个系统中所有应用程序，包括应用程序提交、与调度器协商资源以启动ApplicationMaster、监控ApplicationMaster运行状态并在失败时重新启动它等。")]),a._v(" "),t("p",[t("strong",[a._v("ApplicationMaster（AM）")])]),a._v(" "),t("p",[a._v("管理YARN内运行的应用程序的每个实例。")]),a._v(" "),t("p",[a._v("功能：")]),a._v(" "),t("p",[a._v("1.数据切分")]),a._v(" "),t("p",[a._v("2.为应用程序申请资源并进一步分配给内部任务。")]),a._v(" "),t("p",[a._v("3.任务监控与容错")]),a._v(" "),t("p",[a._v("4.负责协调来自resourcemanager的资源，并通过nodemanager监视容易的执行和资源使用情况。")]),a._v(" "),t("p",[t("strong",[a._v("NodeManager（NM）")])]),a._v(" "),t("p",[a._v("Nodemanager整个集群有多个，负责每个节点上的资源和使用。")]),a._v(" "),t("p",[a._v("功能：")]),a._v(" "),t("p",[a._v("1.单个节点上的资源管理和任务。")]),a._v(" "),t("p",[a._v("2.处理来自于resourcemanager的命令。")]),a._v(" "),t("p",[a._v("3.处理来自域app master的命令。")]),a._v(" "),t("p",[a._v("4.Nodemanager管理着抽象容器，这些抽象容器代表着一些特定程序使用针对每个节点的资源。")]),a._v(" "),t("p",[a._v("5.Nodemanager定时地向RM汇报本节点上的资源使用情况和各个Container的运行状态（cpu和内存等资源）")]),a._v(" "),t("p",[t("strong",[a._v("Container")])]),a._v(" "),t("p",[a._v("Container是YARN中的资源抽象，它封装了某个节点上的多维度资源，如内存、CPU、磁盘、网络等，当AM向RM申请资源时，RM为AM返回的资源便是用Container表示的。YARN会为每个任务分配一个Container，且该任务只能使用该Container中描述的资源。需要注意的是，Container不同于MRv1中的slot，它是一个动态资源划分单位，是根据应用程序的需求动态生成的。目前为止，YARN仅支持CPU和内存两种资源，且使用了轻量级资源隔离机制Cgroups进行资源隔离。")]),a._v(" "),t("h2",{attrs:{id:"工作机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工作机制","aria-hidden":"true"}},[a._v("#")]),a._v(" 工作机制")]),a._v(" "),t("p",[t("img",{attrs:{src:"http://ww1.sinaimg.cn/large/006tNc79gy1g5aav41f12j31oe0u0dup.jpg",alt:"img"}})]),a._v(" "),t("p",[a._v("MapReduce程序提交到客户端所在的节点")]),a._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[a._v("客户端YarnRunner代码向ResourceMananger申请一个Application")]),a._v(" "),t("li",[a._v("ResourceManager将该应用程序的资源路径返回给YarnRunner。")]),a._v(" "),t("li",[a._v("该程序将运行所需资源提交到HDFS上。")]),a._v(" "),t("li",[a._v("程序资源提交完毕后，申请运行MRAppmaster")]),a._v(" "),t("li",[a._v("ResourceManager将用户的请求初始化成一个Task。")]),a._v(" "),t("li",[a._v("其中一个NodeManager领取到Task任务。")]),a._v(" "),t("li",[a._v("该NodeManager创建容器Container，并产生MRAppmaster。")]),a._v(" "),t("li",[a._v("Container从HDFS上拷贝资源到本地")]),a._v(" "),t("li",[a._v("MRAppmaster向ResourceManager申请运行MapTask资源。")]),a._v(" "),t("li",[a._v("ResourceManager将运行MapTask任务分配给另外两个NodeManager，另外两个NodeManager分别领取任务并创建容器。")]),a._v(" "),t("li",[a._v("MRAppmaster向两个接收到任务的NodeManager发送程序启动脚本，这两个NodeManager分别启动MapTask，MapTask对数据分区排序。")]),a._v(" "),t("li",[a._v("MrAppMaster等待所有MapTask运行完毕，向ResourceManager申请容器，运行reduceTask。")]),a._v(" "),t("li",[a._v("ReducerTask向MapTask获取相应分区的数据")]),a._v(" "),t("li",[a._v("程序运行完毕后，MapReduce会向ResourceManager申请注销自己")])]),a._v(" "),t("h2",{attrs:{id:"资源调度和隔离"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#资源调度和隔离","aria-hidden":"true"}},[a._v("#")]),a._v(" 资源调度和隔离")]),a._v(" "),t("p",[a._v("资源调度和隔离是yarn作为一个资源管理系统，最重要且最基础的两个功能。资源调度由resourcemanager完成，而资源隔离由各个nodemanager实现。")]),a._v(" "),t("p",[a._v("Resourcemanager将某个nodemanager上资源分配给任务（这就是所谓的“资源调度”）后，nodemanager需按照要求为任务提供相应的资源，甚至保证这些资源应具有独占性，为任务运行提供基础和保证，这就是所谓的资源隔离。")]),a._v(" "),t("p",[a._v("我们通常指内存、cpu、io三种资源。Hadoop yarn目前为止仅支持cpu和内存两种资源管理和调度。")]),a._v(" "),t("p",[a._v("内存资源多少决定任务的生死，如果内存不够，任务可能运行失败；相比之下，cpu资源则不同，它只会决定任务的快慢，不会对任务的生死产生影响。")]),a._v(" "),t("h3",{attrs:{id:"资源的内存管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#资源的内存管理","aria-hidden":"true"}},[a._v("#")]),a._v(" 资源的内存管理")]),a._v(" "),t("p",[a._v("yarn允许用户配置每个节点上可用的物理内存资源，注意，这里是“可用的”，因为一个节点上内存会被若干个服务贡享，比如一部分给了yarn，一部分给了hdfs，一部分给了hbase等，yarn配置的只是自己可用的，配置参数如下：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("yarn.nodemanager.resource.memory-mb\n")])])]),t("p",[a._v("表示该节点上yarn可以使用的物理内存总量，默认是8192m，注意，如果你的节点内存资源不够8g，则需要调减这个值，yarn不会智能的探测节点物理内存总量。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("yarn.nodemanager.vmem-pmem-ratio\n")])])]),t("p",[a._v("任务使用1m物理内存最多可以使用虚拟内存量，默认是2.1")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("yarn.nodemanager.pmem-check-enabled\n")])])]),t("p",[a._v("是否启用一个线程检查每个任务证使用的物理内存量，如果任务超出了分配值，则直接将其kill，默认是true。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("yarn.nodemanager.vmem-check-enabled\n")])])]),t("p",[a._v("是否启用一个线程检查每个任务证使用的虚拟内存量，如果任务超出了分配值，则直接将其kill，默认是true。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("yarn.scheduler.minimum-allocation-mb\n")])])]),t("p",[a._v("单个任务可以使用最小物理内存量，默认1024m，如果一个任务申请物理内存量少于该值，则该对应值改为这个数。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("yarn.scheduler.maximum-allocation-mb\n")])])]),t("p",[a._v("单个任务可以申请的最多的内存量，默认8192m")]),a._v(" "),t("h3",{attrs:{id:"资源的cpu管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#资源的cpu管理","aria-hidden":"true"}},[a._v("#")]),a._v(" 资源的cpu管理")]),a._v(" "),t("p",[a._v("目前cpu被划分为虚拟cpu，这里的虚拟cpu是yarn自己引入的概念，初衷是考虑到不同节点cpu性能可能不同，每个cpu具有计算能力也是不一样的，比如，某个物理cpu计算能力可能是另外一个物理cpu的2倍，这时候，你可以通过为第一个物理cpu多配置几个虚拟cpu弥补这种差异。用户提交作业时，可以指定每个任务需要的虚拟cpu个数。在yarn中，cpu相关配置参数如下：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("yarn.nodemanager.resource.cpu-vcores\n")])])]),t("p",[a._v("表示该节点上yarn可使用的虚拟cpu个数，默认是8个，注意，目前推荐将该值为与物理cpu核数相同。如果你的节点cpu合数不够8个，则需要调减小这个值，而yarn不会智能的探测节点物理cpu总数。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("yarn.scheduler.minimum-allocation-vcores\n")])])]),t("p",[a._v("单个任务可申请最小cpu个数，默认1，如果一个任务申请的cpu个数少于该数，则该对应值被修改为这个数")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("yarn.scheduler.maximum-allocation-vcores\n")])])]),t("p",[a._v("单个任务可以申请最多虚拟cpu个数，默认是32.")]),a._v(" "),t("h2",{attrs:{id:"资源调度器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#资源调度器","aria-hidden":"true"}},[a._v("#")]),a._v(" 资源调度器")]),a._v(" "),t("p",[a._v("在Yarn中有三种调度器可以选择：FIFO Scheduler ，Capacity Scheduler，FairS cheduler。Hadoop2.7.2默认的资源调度器是Capacity Scheduler。")]),a._v(" "),t("h3",{attrs:{id:"fifo-scheduler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fifo-scheduler","aria-hidden":"true"}},[a._v("#")]),a._v(" FIFO Scheduler")]),a._v(" "),t("p",[a._v("FIFO Scheduler把应用按提交的顺序排成一个队列，这是一个先进先出队列，在进行资源分配的时候，先给队列中最头上的应用进行分配资源，待最头上的应用需求满足后再给下一个分配，以此类推。")]),a._v(" "),t("p",[t("img",{attrs:{src:"http://ww1.sinaimg.cn/large/006tNc79gy1g5aav7tkjwj31tl0u0aff.jpg",alt:"img"}})]),a._v(" "),t("p",[a._v("FIFO Scheduler是最简单也是最容易理解的调度器，也不需要任何配置，但它并不适用于共享集群。大的应用可能会占用所有集群资源，这就导致其它应用被阻塞。在共享集群中，更适合采用Capacity Scheduler或Fair Scheduler，这两个调度器都允许大任务和小任务在提交的同时获得一定的系统资源。")]),a._v(" "),t("p",[a._v("下面“Yarn调度器对比图”展示了这几个调度器的区别，从图中可以看出，在FIFO 调度器中，小任务会被大任务阻塞。")]),a._v(" "),t("h3",{attrs:{id:"capacity-scheduler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#capacity-scheduler","aria-hidden":"true"}},[a._v("#")]),a._v(" Capacity Scheduler")]),a._v(" "),t("p",[a._v("而对于Capacity调度器，有一个专门的队列用来运行小任务，但是为小任务专门设置一个队列会预先占用一定的集群资源，这就导致大任务的执行时间会落后于使用FIFO调度器时的时间。")]),a._v(" "),t("p",[t("img",{attrs:{src:"http://ww4.sinaimg.cn/large/006tNc79gy1g5aav9l34sj316j0f60z4.jpg",alt:"img"}})]),a._v(" "),t("ol",[t("li",[a._v("支持多个队列，每个队列可配置一定的资源量，每个队列采取FIFO调度策略。")]),a._v(" "),t("li",[a._v("为了防止同一个用户的工作独占队列中的资源，该调度器会对同一用户提交的作业所占资源量进行限定")]),a._v(" "),t("li",[a._v("首先，计算每个队列中正在运行的任务数与其应该分的资源之间的比值，选择一个比值最小的队列")]),a._v(" "),t("li",[a._v("其次，按照作业优先级和提交时间顺序，同时考虑用户资源量限制和内存限制对队列内任务排序")]),a._v(" "),t("li",[a._v("三个队列同时按照任务的先后顺序依次执行。")])]),a._v(" "),t("p",[a._v("配置：")]),a._v(" "),t("p",[a._v("Capacity 调度器允许多个组织共享整个集群，每个组织可以获得集群的一部分计算能力。通过为每个组织分配专门的队列，然后再为每个队列分配一定的集群资源，这样整个集群就可以通过设置多个队列的方式给多个组织提供服务了。除此之外，队列内部又可以垂直划分，这样一个组织内部的多个成员就可以共享这个队列资源了，在一个队列内部，资源的调度是采用的是先进先出(FIFO)策略。")]),a._v(" "),t("p",[a._v("通过上面那幅图，我们已经知道一个job可能使用不了整个队列的资源。然而如果这个队列中运行多个job，如果这个队列的资源够用，那么就分配给这些job，如果这个队列的资源不够用了呢？其实Capacity调度器仍可能分配额外的资源给这个队列，这就是“弹性队列”(queue elasticity)的概念。")]),a._v(" "),t("p",[a._v("在正常的操作中，Capacity调度器不会强制释放Container，当一个队列资源不够用时，这个队列只能获得其它队列释放后的Container资源。当然，我们可以为队列设置一个最大资源使用量，以免这个队列过多的占用空闲资源，导致其它队列无法使用这些空闲资源，这就是”弹性队列”需要权衡的地方。")]),a._v(" "),t("p",[a._v("容器调度的配置")]),a._v(" "),t("p",[a._v("假设我们有如下层次的队列：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("root\n├── prod\n└── dev\n   ├── eng\n   └── science\n")])])]),t("p",[a._v("下面是一个简单的Capacity调度器的配置文件，文件名为capacity-scheduler.xml。在这个配置中，在root队列下面定义了两个子队列prod和dev，分别占40%和60%的容量。需要注意，一个队列的配置是通过属性"),t("code",[a._v("yarn.sheduler.capacity.<queue-path>.<sub-property>")]),a._v("指定的，"),t("code",[a._v("<queue-path>")]),a._v("代表的是队列的继承树，如"),t("code",[a._v("root.prod")]),a._v("队列，"),t("code",[a._v("<sub-property>")]),a._v("一般指capacity和maximum-capacity。")]),a._v(" "),t("p",[a._v("我们可以看到，dev队列又被分成了eng和science两个相同容量的子队列。dev的maximum-capacity属性被设置成了75%，所以即使prod队列完全空闲dev也不会占用全部集群资源，也就是说，prod队列仍有25%的可用资源用来应急。我们注意到，eng和science两个队列没有设置maximum-capacity属性，也就是说eng或science队列中的job可能会用到整个dev队列的所有资源（最多为集群的75%）。而类似的，prod由于没有设置maximum-capacity属性，它有可能会占用集群全部资源。")]),a._v(" "),t("p",[a._v("Capacity容器除了可以配置队列及其容量外，我们还可以配置一个用户或应用可以分配的最大资源数量、可以同时运行多少应用、队列的ACL认证等。")]),a._v(" "),t("h3",{attrs:{id:"fairs-cheduler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fairs-cheduler","aria-hidden":"true"}},[a._v("#")]),a._v(" FairS cheduler")]),a._v(" "),t("p",[a._v("在Fair调度器中，我们不需要预先占用一定的系统资源，Fair调度器会为所有运行的job动态的调整系统资源。如下图所示，当第一个大job提交时，只有这一个job在运行，此时它获得了所有集群资源；当第二个小任务提交后，Fair调度器会分配一半资源给这个小任务，让这两个任务公平的共享集群资源。")]),a._v(" "),t("p",[t("img",{attrs:{src:"http://ww4.sinaimg.cn/large/006tNc79gy1g5aavbxg76j31iy0j90vv.jpg",alt:"img"}})]),a._v(" "),t("p",[a._v("支持多队列多用户，每个队列中的资源量可以配置，同一队列中的工作公平共享队列中所有资源。")]),a._v(" "),t("p",[a._v("比如有三个队列：queueA，queueB，queueC，每个队列中的job按照优先级分配资源，优先级越高分配到的资源越多，但是每个job都会分配到资源以保证公平。在资源有限的情况下，每个job理想勤快下获取的计算资源与实际获取的计算资源存在一种差值，这个差距就叫做缺额。在同一个队列中，job的资源缺额越大，越先获得资源越优先执行。作业是按照缺额的高低来先后执行的。")]),a._v(" "),t("p",[t("strong",[a._v("配置：")])]),a._v(" "),t("p",[a._v("Fair调度器的设计目标是为所有的应用分配公平的资源（对公平的定义可以通过参数来设置）。在上面的“Yarn调度器对比图”展示了一个队列中两个应用的公平调度；当然，公平调度在也可以在多个队列间工作。举个例子，假设有两个用户A和B，他们分别拥有一个队列。当A启动一个job而B没有任务时，A会获得全部集群资源；当B启动一个job后，A的job会继续运行，不过一会儿之后两个任务会各自获得一半的集群资源。如果此时B再启动第二个job并且其它job还在运行，则它将会和B的第一个job共享B这个队列的资源，也就是B的两个job会用于四分之一的集群资源，而A的job仍然用于集群一半的资源，结果就是资源最终在两个用户之间平等的共享。过程如下图所示：")]),a._v(" "),t("p",[a._v("1、启用Fair Scheduler")]),a._v(" "),t("p",[a._v("调度器的使用是通过yarn-site.xml配置文件中的"),t("code",[a._v("yarn.resourcemanager.scheduler.class")]),a._v("参数进行配置的，默认采用Capacity Scheduler调度器。如果我们要使用Fair调度器，需要在这个参数上配置FairScheduler类的全限定名： "),t("code",[a._v("org.apache.hadoop.yarn.server.resourcemanager.scheduler.fair.FairScheduler")]),a._v("。")]),a._v(" "),t("p",[a._v("2、队列的配置")]),a._v(" "),t("p",[a._v("Fair调度器的配置文件位于类路径下的fair-scheduler.xml文件中，这个路径可以通过yarn.scheduler.fair.allocation.file属性进行修改。若没有这个配置文件，Fair调度器采用的分配策略，这个策略和3.1节介绍的类似：调度器会在用户提交第一个应用时为其自动创建一个队列，队列的名字就是用户名，所有的应用都会被分配到相应的用户队列中。")]),a._v(" "),t("p",[a._v("队列的层次是通过嵌套"),t("code",[a._v("<queue>")]),a._v("元素实现的。所有的队列都是root队列的孩子，即使我们没有配到"),t("code",[a._v("<root>")]),a._v("元素里。在这个配置中，我们把dev队列有分成了eng和science两个队列。")]),a._v(" "),t("p",[a._v("Fair调度器中的队列有一个权重属性（这个权重就是对公平的定义），并把这个属性作为公平调度的依据。在这个例子中，当调度器分配集群40:60资源给prod和dev时便视作公平，eng和science队列没有定义权重，则会被平均分配。这里的权重并不是百分比，我们把上面的40和60分别替换成2和3，效果也是一样的。注意，对于在没有配置文件时按用户自动创建的队列，它们仍有权重并且权重值为1。")]),a._v(" "),t("p",[a._v("尽管上面的配置中没有展示，每个队列仍可配置最大、最小资源占用数和最大可运行的应用的数量。")]),a._v(" "),t("h3",{attrs:{id:"调度器对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#调度器对比","aria-hidden":"true"}},[a._v("#")]),a._v(" 调度器对比")]),a._v(" "),t("p",[t("img",{attrs:{src:"http://ww3.sinaimg.cn/large/006tNc79gy1g5aave41jcj307m0k0mxz.jpg",alt:"pastedGraphic.png"}})]),a._v(" "),t("h2",{attrs:{id:"任务的推测执行"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#任务的推测执行","aria-hidden":"true"}},[a._v("#")]),a._v(" 任务的推测执行")]),a._v(" "),t("p",[a._v("1.作业完成时间取决于最慢的任务完成时间")]),a._v(" "),t("p",[a._v("一个作业由若干个Map任务和Reduce任务构成。因硬件老化、软件bug等，某些任务可能运行的非常慢。")]),a._v(" "),t("p",[a._v("2.推测执行机制")]),a._v(" "),t("p",[a._v("发现拖后腿的任务，比如某个任务运行速度远慢于任务平均速度。为拖后腿任务启动一个备份任务，同时运行。谁先运行完，则采用谁的结果。")]),a._v(" "),t("p",[a._v("3.执行推测任务的条件")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("每个Task只能有一个备份任务")])]),a._v(" "),t("li",[t("p",[a._v("当前job已完成的Task必须不小于5%")])])]),a._v(" "),t("p",[a._v("开启推测执行参数设置。")]),a._v(" "),t("div",{staticClass:"language-xml extra-class"},[t("pre",{pre:!0,attrs:{class:"language-xml"}},[t("code",[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("property")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("name")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("mapreduce.map.sprculative"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("name")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("value")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("true"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("value")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("property")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("property")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("name")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("mapreduce.reduce.speculative"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("name")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("value")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("true"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("value")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("property")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n")])])]),t("p",[a._v("4.不能启用推测执行机制的情况")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("任务存在严重的数据倾斜")])]),a._v(" "),t("li",[t("p",[a._v("特殊任务，比如任务向数据库中写入数据")])])]),a._v(" "),t("p",[a._v("5.算法原理")]),a._v(" "),t("p",[t("img",{attrs:{src:"http://ww3.sinaimg.cn/large/006tNc79gy1g5aavjy7yyj31uf0lpdmm.jpg",alt:"img"}})]),a._v(" "),t("ol",[t("li",[a._v("MR总是选择（estimateEndTime-estimateEndTime`）差值最大的任务，并且为之启动备份任务")]),a._v(" "),t("li",[a._v("为了防止大量任务同时启动备份任务造成的资源浪费，MR为每个作业设置了同时启动的备份任务数量上限。")]),a._v(" "),t("li",[a._v("推测执行机制实际上采用了经典的优化算法：以空间换时间，它同时启动多个相同任务处理相同数据，并让这些任务竞争以缩短数据处理时间。这种方法需要占用跟多的计算资源。在集群资源紧张的情况下，应合理使用该机制，争取在多用少量资源的情况下，减少作业的计算时间。")])]),a._v(" "),t("h2",{attrs:{id:"参数配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参数配置","aria-hidden":"true"}},[a._v("#")]),a._v(" 参数配置")]),a._v(" "),t("h3",{attrs:{id:"资源相关参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#资源相关参数","aria-hidden":"true"}},[a._v("#")]),a._v(" 资源相关参数")]),a._v(" "),t("p",[a._v("1）以下参数是在用户自己的mr应用程序中配置就可以生效（mapred-default.xml）")]),a._v(" "),t("table",[t("thead",[t("tr",[t("th",[a._v("配置参数")]),a._v(" "),t("th",[a._v("参数说明")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[a._v("mapreduce.map.memory.mb")]),a._v(" "),t("td",[a._v("一个Map Task可使用的资源上限（单位:MB），默认为1024。如果Map Task实际使用的资源量超过该值，则会被强制杀死。")])]),a._v(" "),t("tr",[t("td",[a._v("mapreduce.reduce.memory.mb")]),a._v(" "),t("td",[a._v("一个Reduce Task可使用的资源上限（单位:MB），默认为1024。如果Reduce Task实际使用的资源量超过该值，则会被强制杀死。")])]),a._v(" "),t("tr",[t("td",[a._v("mapreduce.map.cpu.vcores")]),a._v(" "),t("td",[a._v("每个Map task可使用的最多cpu core数目，默认值: 1")])]),a._v(" "),t("tr",[t("td",[a._v("mapreduce.reduce.cpu.vcores")]),a._v(" "),t("td",[a._v("每个Reduce task可使用的最多cpu core数目，默认值: 1")])])])]),a._v(" "),t("p",[a._v("2）应该在yarn启动之前就配置在服务器的配置文件中才能生效（yarn-default.xml）")]),a._v(" "),t("table",[t("thead",[t("tr",[t("th",[a._v("配置参数")]),a._v(" "),t("th",[a._v("参数说明")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[a._v("yarn.scheduler.minimum-allocation-mb\t  1024")]),a._v(" "),t("td",[a._v("给应用程序container分配的最小内存")])]),a._v(" "),t("tr",[t("td",[a._v("yarn.scheduler.maximum-allocation-mb\t  8192")]),a._v(" "),t("td",[a._v("给应用程序container分配的最大内存")])]),a._v(" "),t("tr",[t("td",[a._v("yarn.scheduler.minimum-allocation-vcores\t1")]),a._v(" "),t("td",[a._v("每个container申请的最小CPU核数")])]),a._v(" "),t("tr",[t("td",[a._v("yarn.scheduler.maximum-allocation-vcores\t32")]),a._v(" "),t("td",[a._v("每个container申请的最大CPU核数")])]),a._v(" "),t("tr",[t("td",[a._v("yarn.nodemanager.resource.memory-mb   8192")]),a._v(" "),t("td",[a._v("给containers分配的最大物理内存")])])])]),a._v(" "),t("p",[a._v("3）shuffle性能优化的关键参数，应在yarn启动之前就配置好（mapred-default.xml）")]),a._v(" "),t("table",[t("thead",[t("tr",[t("th",[a._v("配置参数")]),a._v(" "),t("th",[a._v("参数说明")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[a._v("mapreduce.task.io.sort.mb   100")]),a._v(" "),t("td",[a._v("shuffle的环形缓冲区大小，默认100m")])]),a._v(" "),t("tr",[t("td",[a._v("mapreduce.map.sort.spill.percent   0.8")]),a._v(" "),t("td",[a._v("环形缓冲区溢出的阈值，默认80%")])])])]),a._v(" "),t("h3",{attrs:{id:"容错相关参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#容错相关参数","aria-hidden":"true"}},[a._v("#")]),a._v(" 容错相关参数")]),a._v(" "),t("table",[t("thead",[t("tr",[t("th",[a._v("配置参数")]),a._v(" "),t("th",[a._v("参数说明")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[a._v("mapreduce.map.maxattempts")]),a._v(" "),t("td",[a._v("每个Map Task最大重试次数，一旦重试参数超过该值，则认为Map Task运行失败，默认值：4。")])]),a._v(" "),t("tr",[t("td",[a._v("mapreduce.reduce.maxattempts")]),a._v(" "),t("td",[a._v("每个Reduce Task最大重试次数，一旦重试参数超过该值，则认为Map Task运行失败，默认值：4。")])]),a._v(" "),t("tr",[t("td",[a._v("mapreduce.task.timeout")]),a._v(" "),t("td",[a._v("Task超时时间，经常需要设置的一个参数，")])])])]),a._v(" "),t("p",[a._v("mapreduce.task.timeout 该参数表达的意思为：如果一个task在一定时间内没有任何进入，即不会读取新的数据，也没有输出数据，则认为该task处于block状态，可能是卡住了，也许永远会卡主，为了防止因为用户程序永远block住不退出，则强制设置了一个该超时时间（单位毫秒），默认是600000。如果你的程序对每条输入数据的处理时间过长（比如会访问数据库，通过网络拉取数据等），建议将该参数调大，该参数过小常出现的错误提示是")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("“AttemptID:attempt_14267829456721_123456_m_000224_0 Timed out after 300 secsContainer killed by the ApplicationMaster.”。\n")])])])])},[],!1,null,null,null);e.default=s.exports}}]);