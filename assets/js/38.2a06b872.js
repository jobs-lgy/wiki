(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{221:function(t,a,s){"use strict";s.r(a);var n=s(0),e=Object(n.a)({},function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"面试题目"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题目","aria-hidden":"true"}},[t._v("#")]),t._v(" 面试题目")]),t._v(" "),s("h2",{attrs:{id:"java基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java基础","aria-hidden":"true"}},[t._v("#")]),t._v(" Java基础")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("Java")]),t._v(" 虚拟机的运行时数据区有几块?线 程私有和线程共享区域有哪些?")]),t._v(" "),s("p",[t._v("1、程序计数器：线程私有，当前县城执行的字节码的行号指示器。")]),t._v(" "),s("p",[t._v("2、虚拟机栈：线程私有，存放基本数据类型、对象引用和 returnAddress 类型。")]),t._v(" "),s("p",[t._v("3、本地方法栈：为虚拟机使用到的 Native 方法服务。")]),t._v(" "),s("p",[t._v("4、Java 堆：线程共享，存放对象的实例，也是 GC 回收器管理的主要 区域。")]),t._v(" "),s("p",[t._v("5、方法区：线程共享，存放已被虚拟机加载的类信息、常量、静态变 量、即时编译后的代码等数据。")]),t._v(" "),s("p",[t._v("6、运行时常量池：方法区的一部分，存放编译期生成的各种字面量和 符号引用。")]),t._v(" "),s("p",[t._v("7、直接内存：不是虚拟机运行时数据区的一部分，也不是 Java 虚拟 机规范中定义的内存区域，容易引起 OOM 异常，NIO 会调用，不受 Java 堆大小的限制。")])]),t._v(" "),s("li",[s("p",[t._v("Java的平台无关性如何体现出来的")]),t._v(" "),s("p",[t._v("传统的编程中，源代码编译为可执行的代码后，只能针对特定的平台（操作系统），换句话说，针对Windows编写和编译的代码，只能在Windows上运行")]),t._v(" "),s("p",[t._v("java程序则编译为字节码。字节码本身不能运行，因为它不是原生代码。字节码只能够在Java虚拟机（JVM）上运行。JVM是一个原生应用程序，它负责解释字节码。通过使用JVM可用在众多的平台上运行程序。")]),t._v(" "),s("p",[t._v("简单来说：java源文件(.java)通过编译器生成字节码文件（.class），字节码文件（.class）通过JVM（Java虚拟机）中的解释器再翻译成特定机器上的机器码，然后在特定的机器上运行。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。")])]),t._v(" "),s("li",[s("p",[t._v("面向对象的特征：继承、封装和多态")]),t._v(" "),s("p",[t._v("面向对象编程有四个特征：抽象，封装，继承，多态。")]),t._v(" "),s("p",[t._v("多态有四种体现形式：")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("接口和接口的继承。")])]),t._v(" "),s("li",[s("p",[t._v("类和类的继承。")])]),t._v(" "),s("li",[s("p",[t._v("重载。")])]),t._v(" "),s("li",[s("p",[t._v("重写。")])])]),t._v(" "),s("p",[t._v("其中重载和重写为核心。")]),t._v(" "),s("p",[t._v("重载：重载发生在同一个类中，在该类中如果存在多个同名方法，但是方法的参数类型和个数不一样，那么说明该方法被重载了。")]),t._v(" "),s("p",[t._v("重写：重写发生在子类继承父类的关系中，父类中的方法被子类继承，方法名，返回值类型，参数完全一样，但是方法体不一样，那么说明父类中的该方法被子类重写了。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("Static")]),t._v("加载顺序")]),t._v(" "),s("p",[t._v("父类的静态代码块，子类的静态代码块，调用子类的main方法中的方法，父类的构造代码块，父类的构造器，子类的构造代码块，子类的构造器")]),t._v(" "),s("p",[t._v("注意：静态代码块是在类加载时加载的")])]),t._v(" "),s("li",[s("p",[t._v("final, finally, finalize 的区别")]),t._v(" "),s("p",[t._v("Final是一个修饰符：")]),t._v(" "),s("p",[t._v("当final修饰一个变量的时候，变量变成一个常量，它不能被二次赋值")]),t._v(" "),s("p",[t._v("当final修饰的变量为静态变量（即由static修饰）时，必须在声明这个变\t量的时候给它赋值")]),t._v(" "),s("p",[t._v("当final修饰方法时，该方法不能被重写")]),t._v(" "),s("p",[t._v("当final修饰类时，该类不能被继承")]),t._v(" "),s("p",[t._v("Final不能修饰抽象类，因为抽象类中会有需要子类实现的抽\t象方法，（抽\t象类中可以有抽象方法，也可以有普通方法，当一个抽象类中没有抽象方\t法时，这个抽象类也就没有了它存在的必要）")]),t._v(" "),s("p",[t._v("Final不能修饰接口，因为接口中有需要其实现类来实现的方法")]),t._v(" "),s("p",[t._v("Finally：")]),t._v(" "),s("p",[t._v("Finally只能与try/catch语句结合使用，finally语句块中的语句一定会执行，并且会在return，continue，break关键字之前执行")]),t._v(" "),s("p",[t._v("finalize：")]),t._v(" "),s("p",[t._v("Finalize是一个方法，属于java.lang.Object类，finalize()方法是GC\t（garbage \tcollector垃圾回收）运行机制的一部分，finalize()方法是在\tGC清理它所从\t属的对象时被调用的")])]),t._v(" "),s("li",[s("p",[t._v("Exception、Error、运行时异常与一般异常有何异同")]),t._v(" "),s("p",[t._v("java 异常是程序运行过程中出现的错误。Java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类。在Java API中定义了许多异常类,分为两大类，错误Error和异常Exception。其中异常类Exception又分为运行时异常(RuntimeException)和非运行时异常(非runtimeException)，也称之为不检查异常（Unchecked Exception）和检查异常（Checked Exception）。")]),t._v(" "),s("p",[t._v("1、Error与Exception")]),t._v(" "),s("p",[t._v("​\tError是程序无法处理的错误，比如OutOfMemoryError、ThreadDeath等。")]),t._v(" "),s("p",[t._v("​\t这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。")]),t._v(" "),s("p",[t._v("​")]),t._v(" "),s("p",[t._v("​\tException是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。程序中应当尽可能去处理这些异常。")]),t._v(" "),s("p",[t._v("2、运行时异常和非运行时异常")]),t._v(" "),s("p",[t._v("​\t\t运行时异常：都是RuntimeException类及其子类异常：")]),t._v(" "),s("p",[t._v("​\t   \t IndexOutOfBoundsException 索引越界异常")]),t._v(" "),s("p",[t._v("​\t\t\tArithmeticException：数学计算异常")]),t._v(" "),s("p",[t._v("​\t\t\tNullPointerException：空指针异常")]),t._v(" "),s("p",[t._v("​\t\t\tArrayOutOfBoundsException：数组索引越界异常")]),t._v(" "),s("p",[t._v("​\t\t\tClassNotFoundException：类文件未找到异常")]),t._v(" "),s("p",[t._v("​\t\t\tClassCastException：造型异常（类型转换异常）")]),t._v(" "),s("p",[t._v("​")]),t._v(" "),s("p",[t._v("​\t这些异常是不检查异常（Unchecked Exception），程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的。")]),t._v(" "),s("p",[t._v("​")]),t._v(" "),s("p",[t._v("​\t非运行时异常：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如：")]),t._v(" "),s("p",[t._v("​\t\t\tIOException、文件读写异常")]),t._v(" "),s("p",[t._v("​\t\t\tFileNotFoundException：文件未找到异常")]),t._v(" "),s("p",[t._v("​\t\t    EOFException：读写文件尾异常")]),t._v(" "),s("p",[t._v("​\t\t\tMalformedURLException：URL格式错误异常")]),t._v(" "),s("p",[t._v("​\t\t\tSocketException：Socket异常")]),t._v(" "),s("p",[t._v("​\t\t\tSQLException：SQL数据库异常")])]),t._v(" "),s("li",[s("p",[t._v("int 和 Integer 有什么区别，Integer的值缓存范围")]),t._v(" "),s("p",[t._v("int 是基本数据类型，直接存数值，进行初始化时 int 类的变量初始值为 0 ；\nInteger 是对象，用一个引用指向这个对象，Integer 的变量初始化值为 null 。")])]),t._v(" "),s("li",[s("p",[t._v("包装类，装箱和拆箱")]),t._v(" "),s("p",[t._v("包装类：是对基本类型的一种包装，主要是为了将这些基本数据类型当成对象操作。")]),t._v(" "),s("h5",{attrs:{id:"自动装箱：将基本数据类重新转换为对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自动装箱：将基本数据类重新转换为对象","aria-hidden":"true"}},[t._v("#")]),t._v(" 自动装箱：将基本数据类重新转换为对象")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Test")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 声明一个Integer 对象")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),t._v(" num "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 以上的声明就是用到了自动的装箱：")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//解析为 Integer num = Integer.valueOf(10); ")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//valueOf(参数)方法其实调用的是 new Integer(10);")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h5",{attrs:{id:"自动拆箱：将对象重新转换为基本数据类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自动拆箱：将对象重新转换为基本数据类型","aria-hidden":"true"}},[t._v("#")]),t._v(" 自动拆箱：将对象重新转换为基本数据类型")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Test")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 声明一个Integer 对象")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),t._v("  a  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n         "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 下面进行计算时隐含的有自动拆箱")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("因为对象时不能直接进行运算的，而是要转化为基本数据类型才能够加减乘除。")])]),t._v(" "),s("li",[s("p",[t._v("String、StringBuilder、StringBuffer")]),t._v(" "),s("p",[t._v("String       字符串常量   不可变  使用字符串拼接时是不同的2个空间")]),t._v(" "),s("p",[t._v("StringBuffer  字符串变量   可变   线程安全  字符串拼接直接在字符串后追加")]),t._v(" "),s("p",[t._v("StringBuilder 字符串变量   可变   非线程安全  字符串拼接直接在字符串后追加")]),t._v(" "),s("p",[t._v("1、StringBuilder执行效率高于StringBuffer高于String。")]),t._v(" "),s("p",[t._v("2、String是一个常量，是不可变的，所以对于每一次+=赋值都会创建一个新的对象，StringBuffer和StringBuilder都是可变的，当进行字符串拼接时采用append方法，在原来的基础上进行追加，所以性能比String要高，又因为StringBuffer是线程安全的而StringBuilder是线程非安全的，所以StringBuilder的效率高于StringBuffer.")]),t._v(" "),s("p",[t._v("3、对于大数据量的字符串的拼接，采用StringBuffer、StringBuilder。")])]),t._v(" "),s("li",[s("p",[t._v("重载和重写的区别")]),t._v(" "),s("p",[t._v("重载发生在本类，方法名相同，参数列表不同，与返回值无关，只和方法名、参数列表、参数的类型有关。")]),t._v(" "),s("p",[t._v("（1）方法名必须相同")]),t._v(" "),s("p",[t._v("（2）方法的参数列表一定不一样。")]),t._v(" "),s("p",[t._v("（3）访问修饰符和返回值类型可以相同也可以不同。")]),t._v(" "),s("p",[t._v("其实简单而言：重载就是对于不同的情况写不同的方法。 比如，同一个类中，写不同的构造函数用于初始化不同的参数。")]),t._v(" "),s("p",[t._v("重写发生在父类子类之间，比如所有类都是继承与Object类的，Object类中本身就有equals、hashcode、toString方法等。在任意子类中定义了重名和同样的参数列表就构成方法重写。")]),t._v(" "),s("p",[t._v("重写：一般都是表示子类和父类之间的关系，其主要的特征是：方法名相同，参数相同，但是具体的实现不同。")]),t._v(" "),s("p",[t._v("（1）方法名必须相同，返回值类型必须相同")]),t._v(" "),s("p",[t._v("（2）参数列表必须相同")]),t._v(" "),s("p",[t._v("（3）访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。")]),t._v(" "),s("p",[t._v("（4）子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。")]),t._v(" "),s("p",[t._v("（5）构造方法不能被重写")]),t._v(" "),s("p",[t._v("简单而言：就是具体的实现类对于父类的该方法实现不满意，需要自己在写一个满足于自己要求的方法。")])]),t._v(" "),s("li",[s("p",[t._v("抽象类和接口有什么区别")]),t._v(" "),s("p",[t._v("1、抽象类里可以有构造方法，而接口内不能有构造方法。")]),t._v(" "),s("p",[t._v("2、抽象类中可以有普通成员变量，而接口中不能有普通成员变量。")]),t._v(" "),s("p",[t._v("3、抽象类中可以包含非抽象的普通方法，而接口中所有的方法必须是 抽象的，不能有非抽象的普通方法。")]),t._v(" "),s("p",[t._v("4、抽象类中的抽象方法的访问类型可以是 public ，protected 和默认 类型，但接口中的抽象方法只有 public 和默认类型。")]),t._v(" "),s("p",[t._v("5、抽象类中可以包含静态方法，接口内不能包含静态方法。")]),t._v(" "),s("p",[t._v("6、抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变 量的访问类型可以任意，但接口中定义的变量只能是 public static 类 型，并且默认为 public static 类型。")]),t._v(" "),s("p",[t._v("7、一个类可以实现多个接口，但只能继承一个抽象类。")]),t._v(" "),s("p",[t._v("8、接口更多的是在系统框架设计方法发挥作用，主要定义模块之间的 通信，而抽象类在代码实现方面发挥作用，可以实现代码的重用。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("Java")]),t._v(" 反射")]),t._v(" "),s("p",[t._v("反射机制指的是程序在运行时能够获取自身的信息。 为什么要用反射机制?直接创建对象不就可以了吗，这就涉及到了动 态与静态的概念，")]),t._v(" "),s("p",[t._v("静态编译：在编译时确定类型，绑定对象,即通过。")]),t._v(" "),s("p",[t._v("动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥 了 java 的灵活性，体现了多态的应用，有以降低类之间的藕合性。")]),t._v(" "),s("p",[t._v("一句话，反射机制的优点就是可以实现动态创建对象和编译，体现出很大的灵活性，特别是在 J2EE 的开发中 它的灵活性就表现的十分明显。")]),t._v(" "),s("p",[t._v("作用：")]),t._v(" "),s("p",[t._v("1、首先得根据传入的类的全名来创建 Class 对象。")]),t._v(" "),s("p",[t._v("2、获得类方 法的方法。")]),t._v(" "),s("p",[t._v("3、获得类中属性的方法。")]),t._v(" "),s("p",[t._v("缺点：")]),t._v(" "),s("p",[t._v("1、性能第一：反射包括了一些动态类型，所以 JVM 无法对这些 代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。 我们应该避免在经常被 执行的代码或对性能要求很高的程序中使用 反射。")]),t._v(" "),s("p",[t._v("2、安全限制：使用反射技术要求程序必须在一个没有安全限制 的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet。")]),t._v(" "),s("p",[t._v("3、内部暴露：由于反射允许代码执行一些在正常情况下不被 允许的操作(比如访问私有的属性和方法)，所以使用反射可能会导 致意料之外的副作用--代码有功能上的错误，降低可移植性。反射 代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可 能也随着变化。")])]),t._v(" "),s("li",[s("p",[t._v("equals与==的区别")]),t._v(" "),s("p",[t._v("== 比较基本类型，比较的时基本类型的值；比较引用类型则比较的是地址值。")]),t._v(" "),s("p",[t._v("equals是Object类里的方法，只能比较引用类型，也是比较地址。实际开发中往往重写equals方法。如String，arrays，Integer都重写了。重写类的equals方法时，也要重写hashCode方法")])]),t._v(" "),s("li",[s("p",[t._v("hashCode和equals方法的区别与联系")]),t._v(" "),s("p",[t._v("两个对象 equals的时候，hashCode必须相等，但hashCode相等，对象不一定equals。")]),t._v(" "),s("p",[t._v("如果没有重写 hashcode方法，使用Object自带的hashCode，无法保证两个对象equals的时候 hashCode 必须相等的条件。")]),t._v(" "),s("p",[t._v("在Java中，重写equals()方法之后，是否需要重写hashCode()方法，那要看分情况来说明。有些情况下，是建议；有些情况下，是必须重写。")]),t._v(" "),s("ul",[s("li",[t._v("首先说建议的情况：比如你的对象想放到Set集合或者是想作为Map的key时，那么你必须重写equals()方法，这样才能保证唯一性。当然，在这种情况下，你不想重写hashCode()方法，也没有错。但是，对于良好的编程风格而言，你应该在重写equals()方法的同时，也重写hashCode()方法。")]),t._v(" "),s("li",[t._v("必须重写hashCode()的情况：如果你的对象想放进散列存储的集合中（比如：HashSet,LinkedHashSet）或者想作为散列Map（例如：HashMap,LinkedHashMap等等）的Key时，在重写equals()方法的同时，必须重写hashCode()方法。")])]),t._v(" "),s("p",[t._v("最后明白两点就行了：\n1、hashCode()方法存在的主要目的就是提高效率。")]),t._v(" "),s("p",[t._v("2、在集合中判断两个对象相等的条件，其实无论是往集合中存数据，还是从集合中取数据，包括如果控制唯一性等，都是用这个条件判断的，条件如下：")]),t._v(" "),s("p",[t._v("首先判断两个对象的hashCode是否相等，如果不相等，就认为这两个对象不相等，就完成了。如果相等，才会判断两个对象的equals()是否相等，如果不相等，就认为这两个对象不相等，如果相等，那就认为这两个对象相等。")]),t._v(" "),s("p",[t._v("上面的条件对于任何集合都是如此，只要理解上面的条件，你就明白了，为什么在有些情况下建议重写hashCode().有些情况下，是必须要重写的，只有一个目的，就是提高效率，你想想，如果你重写了hashCode(),只要不满足第一个条件，那就直接可以判断两个对象是不等的，也就不用花费时间再去比较equals了。")])]),t._v(" "),s("li",[s("p",[t._v("toString()方法什么情况下需要重写；")]),t._v(" "),s("p",[t._v("如果不重写，直接调用Object类的toString()方法，打印的是该对象的内存地址（类名@哈希码值）。")]),t._v(" "),s("p",[t._v("一般在编写代码，POJO类必须重写toString方法。如果继承了另一个POJO类，注意在前面加一下super.toString")])]),t._v(" "),s("li",[s("p",[t._v("Object的hashcode()是怎么计算的？")]),t._v(" "),s("p",[t._v("Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，是通过该对象的内存地址（物理地址）进行hash计算(目前只知道hash计算取余的方法)，最后返回hashcode")])]),t._v(" "),s("li",[s("p",[t._v("String中hashcode是怎么实现的；")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("hashCode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" h "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" hash"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("h "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" val"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            h "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("31")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" h "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" val"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        hash "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" h"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" h"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])]),t._v(" "),s("li",[s("p",[t._v("若hashcode方法永远返回1或者一个常量会产生什么结果？")]),t._v(" "),s("p",[t._v("当hashCode()返回常量时，所有对象都出现hash冲突，而hashCode()本身的性能也会降级。\n做hash的key的时候效率会极度变低，变量比较也会变慢")])]),t._v(" "),s("li",[s("p",[t._v("什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable 接口的作用")]),t._v(" "),s("p",[t._v("序列化：将那些实现了Serializable接口的对象转换成一个字节序列，并且能够在以后将这个字节序列完全恢复为原来的对象，序列化可以弥补不同操作系统之间的差异。")]),t._v(" "),s("p",[t._v("反序列化：将这个字节序列完全恢复为原来的对象")]),t._v(" "),s("p",[t._v("实现序列化的方法")]),t._v(" "),s("p",[t._v("1、实现Serializable接口")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("该接口是一个可序列化的标志，并没有包含实际的属性和方法。")])]),t._v(" "),s("li",[s("p",[t._v("如果不在该方法中添加readObject()和writeObject()方法，则采取默认的序列化机制。如果添加了这两个方法之后还想利用Java默认的序列化机制，则在这两个方法中分别调用defaultReadObject()和defaultWriteObject()两个方法。")])]),t._v(" "),s("li",[s("p",[t._v("为了保证安全性，可以使用transient关键字进行修饰不必序列化的属性。因为在反序列化时，private修饰的属性也能被查看到。")])])]),t._v(" "),s("p",[t._v("2、实现ExternalSerializeable方法")]),t._v(" "),s("p",[t._v("自己对要序列化的内容进行控制，控制哪些属性能被序列化，哪些不能被序列化。")]),t._v(" "),s("p",[t._v("反序列化的方法：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("实现Serializable接口对象在反序列化时不需要调用对象所在类的构造方法，完全基于字节。")])]),t._v(" "),s("li",[s("p",[t._v("实现externalSerializable接口的方法在反序列化时会调用构造方法。")])])]),t._v(" "),s("p",[t._v("注意事项：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("被static修饰的属性不会被序列化")])]),t._v(" "),s("li",[s("p",[t._v("对象的类名、属性名都会被序列化，方法不会被序列化。")])]),t._v(" "),s("li",[s("p",[t._v("要保证序列化对象所在类的属性也是可以被序列化的。")])]),t._v(" "),s("li",[s("p",[t._v("当通过网络、文件进行序列化时，必须按照写入的顺序读取对象。")])]),t._v(" "),s("li",[s("p",[t._v("反序列化时必须有序列化对象时的class文件。")])]),t._v(" "),s("li",[s("p",[t._v("最好显示地声明serializableID，因为在不同的JVM之间，默认生成serializeableID可能不同,会造成反序列化失败。")])])])])]),t._v(" "),s("p",[t._v("实现java.io.Serializable 接口的类是可序列化的，是可以转换为字节序列，这些字节序列可以被完全存储以备以后重新生成原来的对象。")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("Java 8有哪些新特性")]),t._v(" "),s("p",[s("strong",[t._v("Lambda表达式")])]),t._v(" "),s("p",[s("strong",[t._v("接口的默认方法与静态方法")]),t._v("：我们可以在接口中定义默认方法，使用default关键字，并提供默认的实现。所有实现这个接口的类都会接受默认方法的实现，除非子类提供的自己的实现。")]),t._v(" "),s("p",[s("strong",[t._v("方法引用")]),t._v("：通常与Lambda表达式联合使用，可以直接引用已有Java类或对象的方法。")]),t._v(" "),s("p",[s("strong",[t._v("重复注解")])]),t._v(" "),s("p",[s("strong",[t._v("扩展注解的支持")]),t._v("：Java 8扩展了注解的上下文，几乎可以为任何东西添加注解，包括局部变量、泛型类、父类与接口的实现，连方法的异常也能添加注解")]),t._v(" "),s("p",[s("strong",[t._v("Optional")]),t._v("：Java 8引入Optional类来防止空指针异常")]),t._v(" "),s("p",[s("strong",[t._v("Stream")]),t._v("：Stream API是把真正的函数式编程风格引入到Java中。其实简单来说可以把Stream理解为MapReduce")]),t._v(" "),s("p",[s("strong",[t._v("Date/Time API (JSR 310)")])]),t._v(" "),s("p",[s("strong",[t._v("JavaScript引擎Nashorn")])]),t._v(" "),s("p",[s("strong",[t._v("Base64")])])]),t._v(" "),s("li",[s("p",[t._v("浅拷贝和深拷贝的区别；")]),t._v(" "),s("p",[t._v("浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化")]),t._v(" "),s("p",[t._v("深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变")]),t._v(" "),s("p",[t._v("深拷贝的实现方法主要有两种：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("通过重写clone方法来实现深拷贝")])]),t._v(" "),s("li",[s("p",[t._v("通过对象序列化实现深拷贝")])])])]),t._v(" "),s("li",[s("p",[t._v("String s=”abc”和String s=new String(“abc”)区别；")]),t._v(" "),s("p",[t._v('String a="abc"，这行代码被执行的时候，JAVA虚拟机首先在字符串池中查找是否已经存在了值为"abc"的这么一个对象，它的判断依据是String类equals(Object obj)方法的返回值。如果有，则不再创建新的对象，将使用串池里原来的那个内存，直接返回已存在对象的引用，而不会重新分配内存；如果没有，则先创建这个对象，然后把它加入到字符串池中，再将它的引用返回。')]),t._v(" "),s("p",[t._v('而如果用String s=new String("abc")，不管串池里有没有"abc"，它都会在堆中重新分配一块内存，定义一个新的对象。')]),t._v(" "),s("p",[t._v("再看下个例子：")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" s"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"java"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"blog"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//直接将javablog对象放入字符串池中。")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"javablog"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//结果是true;")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" str1"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"java"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//指向字符串池")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" str2"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"blog"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//指向字符串池")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" s "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" str1"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("str2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n")])])]),s("p",[t._v('+运算符会在堆中建立起两个String对象，这两个对象的值分别是“java”,"blog",也就是说从字符串常量池中复制这两个值，然后再堆中创建两个对象。然后再建立对象s, 然后将“javablog”的堆地址赋给s. 这句话共创建了3个String对象。')]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"javablog"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//因为内存地址不同，结果是false;")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" s"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("str1"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"blog"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//不放在字符串池中，而是在堆中分分配。")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"javablog"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//结果是false;")]),t._v("\n")])])]),s("p",[t._v("JVM对形如"),s("code",[t._v('String str="java"+"blog";')]),t._v('根据编译器合并已知量的优化功能，在池中开辟一块空间，存放合并后的String常量"javablog"。而'),s("code",[t._v("String s=str1+str2;")]),t._v("是在运行时候才能知道的，也就是说str1+str2是在堆里创建的所以结果为false了。")]),t._v(" "),s("p",[t._v('总之，创建字符串有两种方式：两种内存区域(pool,heap)\n1、""创建的字符串在字符串池中。\n2、new 创建字符串时，首先查看池中是否有相同的字符串，如果有则拷贝一份放到堆中，然后返回堆中的地址；如果池中没有则在堆中创建一份，然后返回堆中的地址，')]),t._v(" "),s("p",[t._v("3、在对字符串赋值时，如果右操作数含有一个或一个以上的字符串引用时，则在堆中再建立一个字符串对象，返回引用。如："),s("code",[t._v('String s= str1+"blog"')]),t._v(";")])])]),t._v(" "),s("h2",{attrs:{id:"集合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#集合","aria-hidden":"true"}},[t._v("#")]),t._v(" 集合")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("HashMap")]),t._v(" 和 "),s("strong",[t._v("HashTable")]),t._v(" 区别?")]),t._v(" "),s("p",[t._v("1、Hashtable 是基于陈旧的 Dictionary 类的，HashMap 是 Java 1.2 引 进的 Map 接口的一个实现")]),t._v(" "),s("p",[t._v("2、Hashtable 的方法是同步的，而 HashMap 的方法不是，因此")]),t._v(" "),s("p",[t._v("HashTable 是线程安全的，但是代码的执行效率上要慢于 HashMap。")]),t._v(" "),s("p",[t._v("3、HashMap 允许空值和空键，但是 HashTable 不可以。")]),t._v(" "),s("p",[t._v("4、HashMap 非同步实现 Map 接口，是一个“链表数组”的数据结构， 最大承载量是 16，可以自动变长，由 Entry[]控制(key，value，next)， hashCode()判断 key 是否重复。")]),t._v(" "),s("p",[t._v("5、建议需要做同步，使用 ConcurrentHashMap，降低了锁的粒度。在 hashMap 的基础上，ConcurrentHashMap 将数据分为多个 segment， 默认 16 个(concurrency level)，然后每次操作对一个 segment 加锁， 避免多线程锁得几率，提高并发效率。这里在并发读取时，除了 key 对应的 value 为 null 之外，并没有使用锁。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("ArrayList")]),t._v(" 和 "),s("strong",[t._v("LinkedList")]),t._v(" 区别?")]),t._v(" "),s("p",[t._v("ArrayList 基于数组实现，LinkedList 基于链表实现，ArrayList 增加和 删除比 LinkedList 慢，但是 LinkedList 在查找的时需要递归查找，效 率比 ArrayList 慢。")]),t._v(" "),s("p",[t._v("关于多线程方面，如果要求线程安全的，有一个 Vector，不过比较多的使用的是 CopyOnWriteArrayList 替代 ArrayList， CopyOnWriteArrayList 适合使用在读操作远远大于写操作的场景里， 比如缓存。发生修改时候做 copy，新老版本分离，保证读的高性能， 适用于以读为主的情况。")]),t._v(" "),s("p",[t._v("Arraylist与LinkedList默认空间是多少；")]),t._v(" "),s("p",[t._v("ArrayList和LinkList的删除一个元素的时间复杂度；（ArrayList是O(N)，LinkList是O(1)）；")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("Set")]),t._v(" 接口")]),t._v(" "),s("p",[t._v("1、HashSet 是 Set 接口的典型实现，HashSet 按 hash 算法来存储元 素，因此具有很好的存取和查找性能。")]),t._v(" "),s("p",[t._v("特点：不能保证元素的排列顺 序，顺序有可能发生变化;HashSet 是异步的;集合元素值可以是 null; 当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode()方法来得到该对象的 hashCode 值，然后根据该 HashCode 值来确定该对象在 HashSet 中存储的位置。HashSet 还有 一个子类LinkedHashSet，其集合也是根据元素 hashCode 值来决定 元素的存储位置，但它同时用链表来维护元素的次序，这样使得元素 看起来是以插入的顺序保存的，也就是说，当遍历 LinkedHashSet 集 合元素时，它将会按元素的添加顺序来访问集合里的元素。所以 LinkedHashSet 的性能略低于 HashSet，但在迭代访问全部元素时将 有很好的性能，因为它以链表来维护内部顺序。")]),t._v(" "),s("p",[t._v("2、TreeSet 是 SortSet 接口的唯一实现，TreeSet 可以确保集合元素处 于排序状态。TreeSet 不是根据元素插入顺序进行排序的，而是根据 元素的值来排序的。TreeSet 支持两种排序方法:自然排序和定制排 序。")]),t._v(" "),s("p",[t._v("3、EnumSet 中所有值都必须是指定枚举类型的值，它的元素也是有序 的，以枚举值在枚举类的定义顺序来决定集合元素的顺序。EnumSet 集合不允许加入 null 元素，否则会抛出 NullPointerException 异常。 EnumSet 类没有暴露任何构造器来创建该类的实例，程序应该通过它提供的 static 方法来创建 EnumSet 对象。")]),t._v(" "),s("p",[t._v("4、总结:\nA、HashSet 的性能比 Treeset 好，因为 TreeSet 需要额外的红黑树算 法来维护集合元素的次序，只有当需要一个保持排序的 Set 时，才会 用 TreeSet。\nB、EnumSet 是性能最好的，但它只能保存枚举值。")]),t._v(" "),s("p",[t._v("C、它们都是线程不安全的。")]),t._v(" "),s("p",[t._v("注：Set 是一种不包含重复的元素的 Collection，即任意的两个元素 e1 和 e2 都有 e1.equals(e2)=false，Set 最多有一个 null 元素。")]),t._v(" "),s("p",[t._v("关于 HashSet，条目数和容量之和来讲，迭代是线性的。因此，如果 迭代性能很重要，那就应该慎重选择一个适当的初始容量。容量选得 太大，既浪费空间，也浪费时间。默认的初试容量是 101，一般来讲， 它比你所需要的要多。可以使用 int 构造函数来指定初始容量。要分 配 HashSet 的初始容量为 17:")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("Set s=new HashSet(17);\n")])])]),s("p",[t._v('HashSet 另有一个称作装载因数(load factor)的"调整参数(tuning parameter)"。')]),t._v(" "),s("p",[t._v("区别:")]),t._v(" "),s("p",[t._v("1、HashSet 是通过 HashMap 实现的，TreeSet 是通过 TreeMap 实现 的，只不过 Set 用的只是 Map 的 key。")]),t._v(" "),s("p",[t._v("2、Map 的 key 和 Set 都有一个共同的特性就是集合的唯一 性。TreeMap 更是多了一个排序的功能。")]),t._v(" "),s("p",[t._v("3、hashCode 和 equal()是 HashMap 用的，因为无需排序所以只需要关注定位和唯一性即可。\na. hashCode 是用来计算 hash 值的，hash 值是用来确定 hash 表索引的。\nb. hash 表中的一个索引处存放的是一张链表， 所以还要通过 equal 方法循环比较链上的每一个对象才可以真正定位到键值对应的 Entry。")]),t._v(" "),s("p",[t._v("c. put时，如果hash表中没定位到,就在链表前加一个Entry，如果 定位到了,则更换 Entry 中的 value,并返回旧 value。")]),t._v(" "),s("p",[t._v("4、由于 TreeMap 需要排序，所以需要一个 Comparator 为键值进行 大小比较。当然也是用 Comparator 定位的.。")]),t._v(" "),s("p",[t._v("a. Comparator 可以在创建 TreeMap 时指定")]),t._v(" "),s("p",[t._v("b. 如果创建时没有确定，那么就会使用 key.compareTo()方法，这就要求 key 必须实现 Comparable 接口。\nTreeMap 是使用 Tree 数据结构实现的,所以使用 compare 接口就可 以完成定位了。")])]),t._v(" "),s("li",[s("p",[t._v("List 和 Set 区别")])]),t._v(" "),s("li",[s("p",[t._v("Set和hashCode以及equals方法的联系")])]),t._v(" "),s("li",[s("p",[t._v("Set内存放的元素为什么不可以重复，内部是如何保证和实现的？")])]),t._v(" "),s("li",[s("p",[t._v("List 和 Map 区别")])]),t._v(" "),s("li",[s("p",[t._v("ArrayList 与 Vector 区别")])])]),t._v(" "),s("p",[t._v("首先看这两类都实现List接口，而List接口一共有三个实现类，分别是ArrayList、Vector和LinkedList。List用于存放多个元素，能够维护元素的次序，并且允许元素的重复。3个具体实现类的相关区别如下：")]),t._v(" "),s("p",[t._v("ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。")]),t._v(" "),s("p",[t._v("Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。")]),t._v(" "),s("p",[t._v("LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。")]),t._v(" "),s("p",[t._v("vector是线程（Thread）同步（Synchronized）的，所以它也是线程安全的，而Arraylist是线程异步（ASynchronized）的，是不安全的。如果不考虑到线程的安全因素，一般用Arraylist效率比较高。")]),t._v(" "),s("p",[t._v("如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度")]),t._v(" "),s("p",[t._v("的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。")]),t._v(" "),s("p",[t._v("如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，都是0(1),这个时候使用vector和arraylist都可以。而")]),t._v(" "),s("p",[t._v("如果移动一个指定位置的数据花费的时间为0(n-i)n为总长度，这个时候就应该考虑到使用Linkedlist,因为它移动一个指定位置的数据")]),t._v(" "),s("p",[t._v("所花费的时间为0(1),而查询一个指定位置的数据时花费的时间为0(i)。")]),t._v(" "),s("p",[t._v("ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，")]),t._v(" "),s("p",[t._v("都允许直接序号索引元素，但是插入数据要设计到数组元素移动 等内存操作，所以索引数据快插入数据慢，")]),t._v(" "),s("p",[t._v("Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差")]),t._v(" "),s("p",[t._v("LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快！")]),t._v(" "),s("p",[t._v("笼统来说：")]),t._v(" "),s("p",[t._v("​\t\tLinkedList：增删改快")]),t._v(" "),s("p",[t._v("​        ArrayList：查询快（有索引的存在）")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("HashSet 和 HashMap 区别")])]),t._v(" "),s("li",[s("p",[t._v("HashMap 和 ConcurrentHashMap 的区别")])]),t._v(" "),s("li",[s("p",[t._v("HashMap 的工作原理及代码实现，什么时候用到红黑树")])]),t._v(" "),s("li",[s("p",[t._v("多线程情况下HashMap死循环的问题")])]),t._v(" "),s("li",[s("p",[t._v("HashMap出现Hash DOS攻击的问题")])]),t._v(" "),s("li",[s("p",[t._v("ConcurrentHashMap 的工作原理及代码实现，如何统计所有的元素个数")])]),t._v(" "),s("li",[s("p",[t._v("谈谈HashMap，哈希表解决hash冲突的方法；")]),t._v(" "),s("p",[t._v("开放地址法、链地址法、再哈希法、建立公共溢出区等）")])]),t._v(" "),s("li",[s("p",[t._v("Java Collections和Arrays的sort方法默认的排序方法是什么；")])]),t._v(" "),s("li",[s("p",[t._v("说一下TreeMap的实现原理？红黑树的性质？红黑树遍历方式有哪些？如果key冲突如何解决？setColor()方法在什么时候用？什么时候会进行旋转和颜色转换？")])])]),t._v(" "),s("h2",{attrs:{id:"线程和并发"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线程和并发","aria-hidden":"true"}},[t._v("#")]),t._v(" 线程和并发")]),t._v(" "),s("ul",[s("li",[t._v("Lock与synchronized 的区别")])]),t._v(" "),s("p",[t._v("1、ReentrantLock 拥有Synchronized相同的并发性和内存语义，此外还多了 锁投票，定时锁等候和中断锁等候")]),t._v(" "),s("p",[t._v("线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定，")]),t._v(" "),s("p",[t._v("如果使用 synchronized ，如果A不释放，B将一直等下去，不能被中断")]),t._v(" "),s("p",[t._v("如果 使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情")]),t._v(" "),s("p",[t._v("ReentrantLock获取锁定与三种方式：")]),t._v(" "),s("p",[t._v("a) lock(), 如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁")]),t._v(" "),s("p",[t._v("b) tryLock(), 如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false；")]),t._v(" "),s("p",[t._v("c)tryLock(long timeout,TimeUnit unit)， 如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；")]),t._v(" "),s("p",[t._v("d) lockInterruptibly:如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断")]),t._v(" "),s("p",[t._v("2、synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定，但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到finally{}中")]),t._v(" "),s("p",[t._v("3、在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态；")]),t._v(" "),s("p",[t._v("5.0的多线程任务包对于同步的性能方面有了很大的改进，在原有synchronized关键字的基础上，又增加了ReentrantLock，以及各种Atomic类。了解其性能的优劣程度，有助与我们在特定的情形下做出正确的选择。")]),t._v(" "),s("p",[t._v("总体的结论先摆出来：")]),t._v(" "),s("p",[t._v("synchronized：")]),t._v(" "),s("p",[t._v("在资源竞争不是很激烈的情况下，偶尔会有同步的情形下，synchronized是很合适的。原因在于，编译程序通常会尽可能的进行优化synchronize，另外可读性非常好，不管用没用过5.0多线程包的程序员都能理解。")]),t._v(" "),s("p",[t._v("ReentrantLock:")]),t._v(" "),s("p",[t._v("ReentrantLock提供了多样化的同步，比如有时间限制的同步，可以被Interrupt的同步（synchronized的同步是不能Interrupt的）等。在资源竞争不激烈的情形下，性能稍微比synchronized差点点。但是当同步非常激烈的时候，synchronized的性能一下子能下降好几十倍。而ReentrantLock确还能维持常态。")]),t._v(" "),s("p",[t._v("Atomic:")]),t._v(" "),s("p",[t._v("和上面的类似，不激烈情况下，性能比synchronized略逊，而激烈的时候，也能维持常态。激烈的时候，Atomic的性能会优于ReentrantLock一倍左右。但是其有一个缺点，就是只能同步一个值，一段代码中只能出现一个Atomic的变量，多于一个同步无效。因为他不能在多个Atomic之间同步。")]),t._v(" "),s("p",[t._v("所以，我们写同步的时候，优先考虑synchronized，如果有特殊需要，再进一步优化。ReentrantLock和Atomic如果用的不好，不仅不能提高性能，还可能带来灾难。")]),t._v(" "),s("ul",[s("li",[t._v("线程和进程的概念、并行和并发的概念")])]),t._v(" "),s("p",[t._v("并发：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("创建线程的方式及实现")]),t._v(" "),s("p",[t._v("创建线程有 4 方式:继承 Thread+实现 Runnable+实现 Callable+线程池获得")])]),t._v(" "),s("li",[s("p",[t._v("进程间通信的方式")])])]),t._v(" "),s("p",[t._v("信号、文件、信号量、管道、共享内存、消息、socket")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("说说 CountDownLatch、CyclicBarrier 原理和区别")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("CountDownLatch")]),t._v(" "),s("th",[t._v("CyclicBarrier")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("减计数方式")]),t._v(" "),s("td",[t._v("加计数方式")])]),t._v(" "),s("tr",[s("td",[t._v("计数为0时，无法重置")]),t._v(" "),s("td",[t._v("计数达到指定值时，计数置为0重新开始")])]),t._v(" "),s("tr",[s("td",[t._v("不可重复利用")]),t._v(" "),s("td",[t._v("可重复利用")])])])])]),t._v(" "),s("li",[s("p",[t._v("说说 Semaphore 原理")])])]),t._v(" "),s("p",[t._v("Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，保证合理的使用公共资源。线程可以通过acquire()方法来获取信号量的许可，当信号量中没有可用的许可的时候，线程阻塞，直到有可用的许可为止。线程可以通过release()方法释放它持有的信号量的许可。")]),t._v(" "),s("ul",[s("li",[t._v("说说 Exchanger 原理")])]),t._v(" "),s("p",[t._v("jdk1.5提供的，Exchanger提供的是一个交换服务，允许原子性的交换两个（多个）对象，但同时只有一对才会成功。")]),t._v(" "),s("ul",[s("li",[t._v("ThreadLocal 原理分析，ThreadLocal为什么会出现OOM，出现的深层次原理")])]),t._v(" "),s("p",[t._v("可以私有化存储线程的变量值，每个Thread线程维护着一个ThreadLocalMap，而ThreadLocalMap中的一个键即是一个ThreadLocal，value是我们通过set方法传进去的参数。")]),t._v(" "),s("p",[t._v("ThreadLocal，它作为一个key用的是弱引用")]),t._v(" "),s("p",[t._v("内存泄漏归根结底是由于ThreadLocalMap的生命周期跟Thread一样长。如果没有手动删除为null的key就会导致内存泄漏。")]),t._v(" "),s("ul",[s("li",[t._v("讲讲线程池的实现原理")])]),t._v(" "),s("p",[t._v("就是一个线程集合workerSet和一个阻塞队列workQueue。当用户向线程池提交一个任务(也就是线程)时，线程池会先将任务放入workQueue中。workerSet中的线程会不断的从workQueue中获取线程然后执行。当workQueue中没有任务的时候，worker就会阻塞，直到队列中有任务了就取出来继续执行。")]),t._v(" "),s("ul",[s("li",[t._v("线程池的几种实现方式？任务拒接策略有哪几种？")])]),t._v(" "),s("p",[t._v("Java通过Executors提供四种线程池，分别为：\nnewCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。")]),t._v(" "),s("p",[t._v("newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。")]),t._v(" "),s("p",[t._v("newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。")]),t._v(" "),s("p",[t._v("newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。")]),t._v(" "),s("ul",[s("li",[t._v("线程的生命周期，状态是如何转移的")])]),t._v(" "),s("p",[t._v("（1）新建状态——（2）就绪状态—（3）运行状态——（4）阻塞状态——（5）死亡状态")]),t._v(" "),s("p",[s("img",{attrs:{src:"http://ww4.sinaimg.cn/large/006tNc79gy1g5eu7ehr61j30ht0chjuk.jpg",alt:"img"}})]),t._v(" "),s("ul",[s("li",[s("p",[t._v("一个线程连着调用start两次会出现什么情况？")]),t._v(" "),s("p",[t._v("由于状态只有就绪、阻塞、执行，状态是无法由执行转化为执行的，所以会报不合法的状态！")]),t._v(" "),s("p",[t._v("Java的线程是不允许启动两次的，第二次调用必然会抛出IllegalThreadStateException，这是一种运行时异常，多次调用start被认为是编程错误。")])]),t._v(" "),s("li",[s("p",[t._v("wait方法能不能被重写，wait能不能被中断？")]),t._v(" "),s("p",[t._v("wait是final类型的，不可以被重写，不仅如此，notify和notifyall都是final类型的。可以被中断")])]),t._v(" "),s("li",[s("p",[t._v("Object类中常见的方法，为什么wait notify会放在Object里边？")]),t._v(" "),s("p",[t._v("JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。")])]),t._v(" "),s("li",[s("p",[t._v("线程池，如何根据CPU的核数来设计线程大小，如果是计算机密集型的呢，如果是IO密集型的呢？")])]),t._v(" "),s("li",[s("p",[t._v("多个线程同时读写，读线程的数量远远⼤于写线程，你认为应该如何解决并发的问题？你会选择加什么样的锁？")]),t._v(" "),s("p",[t._v("（ReentrantReadWriteLock）读写锁最适用于对数据结构的读操作次数多于写操作的场合，因为，读模式锁定时可以共享，而写模式锁定时只能某个线程独占资源(解释为读模式可以共享 所以不用创建线程 多个线程共享个资源, 二写模式由单个线程独占,所以要写更多的内容则需要创建更多的线程)，因而，读写锁也可以叫做个共享-独占锁。")])]),t._v(" "),s("li",[s("p",[t._v("线程池内的线程如果全部忙，提交⼀个新的任务，会发⽣什么？队列全部塞满了之后，还是忙，再提交会发⽣什么？")]),t._v(" "),s("p",[t._v("将任务存进任务队列中 . ThreadPoolExecutor's中的submit()方法会抛出一个RejectedExecutionException异常")])]),t._v(" "),s("li",[s("p",[t._v("synchronized关键字锁住的是什么东西？在字节码中是怎么表示的？在内存中的对象上表现为什么？")]),t._v(" "),s("p",[t._v("对象，monitor.enter() monitor.exit() 标记对象头信息")])]),t._v(" "),s("li",[s("p",[t._v("wait/notify/notifyAll⽅法需不需要被包含在synchronized块中？这是为什么？")]),t._v(" "),s("p",[t._v("wait() 方法执行默认释放对象锁 所以为了同步 需要在synchronized块中")])])]),t._v(" "),s("h2",{attrs:{id:"算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#算法","aria-hidden":"true"}},[t._v("#")]),t._v(" 算法")]),t._v(" "),s("p",[t._v("不稳定的排序算法有：希尔排序，快速排序，选择排序，堆排序")]),t._v(" "),s("p",[t._v("稳定的有：插入排序，冒泡排序")]),t._v(" "),s("p",[t._v("快希选堆不稳，选堆归基不变")]),t._v(" "),s("p",[t._v("冒择路（入）兮（希）快归堆")]),t._v(" "),s("p",[t._v("冒泡：")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("bubbleSort")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" temp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用来交换的临时数")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 要遍历的次数")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 从后向前依次的比较相邻两个数的大小，遍历一次后，把数组中第i小的数放在第i个位置上")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" j"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 比较相邻的元素，如果前面的数大于后面的数，则交换")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                temp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" temp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("对冒泡排序常见的改进方法是加入标志性变量exchange，用于标志某一趟排序过程中是否有数据交换。")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对 bubbleSort 的优化算法")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("bubbleSort_2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" temp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用来交换的临时数")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" bChange "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 交换标志")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 要遍历的次数")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        bChange "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 从后向前依次的比较相邻两个数的大小，遍历一次后，把数组中第i小的数放在第i个位置上")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" j"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 比较相邻的元素，如果前面的数大于后面的数，则交换")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                temp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" temp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                bChange "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果标志为false，说明本轮遍历没有交换，已经是有序数列，可以结束排序")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" bChange"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("快速排序：")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("QuickSort")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("quickSort")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" pivot"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n         pivot"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("partition")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n         "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("quickSort")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("pivot"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n         "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("quickSort")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("pivot"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("partition")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" key"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n         "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("right "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            right"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n         "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n         arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n         "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("right "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            left"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n         "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n         arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n      arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])])},[],!1,null,null,null);a.default=e.exports}}]);