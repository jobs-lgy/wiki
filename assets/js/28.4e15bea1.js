(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{209:function(a,t,s){"use strict";s.r(t);var v=s(0),n=Object(v.a)({},function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"java基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java基础","aria-hidden":"true"}},[a._v("#")]),a._v(" Java基础")]),a._v(" "),s("h2",{attrs:{id:"java概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java概述","aria-hidden":"true"}},[a._v("#")]),a._v(" Java概述")]),a._v(" "),s("p",[s("img",{attrs:{src:"http://ww3.sinaimg.cn/large/006tNc79gy1g5e80w4efbj30l40es7em.jpg",alt:"img"}})]),a._v(" "),s("p",[a._v("JDK：Java程序开发工具包，包括JRE和开发人员使用的工具")]),a._v(" "),s("p",[a._v("JRE：Java程序运行时环境，包括JVM和运行时所需要的类库")]),a._v(" "),s("p",[a._v("JVM：Java运行程序的虚拟机")]),a._v(" "),s("p",[s("img",{attrs:{src:"http://ww1.sinaimg.cn/large/006tNc79gy1g5e824ifwcj30gf0bmn1d.jpg",alt:"img"}})]),a._v(" "),s("p",[a._v("区别：")]),a._v(" "),s("ul",[s("li",[a._v("运行一个已有程序用JRE")]),a._v(" "),s("li",[a._v("开发一个全新程序用JDK")])]),a._v(" "),s("p",[s("img",{attrs:{src:"http://ww4.sinaimg.cn/large/006tNc79gy1g5e8181cxej30cx08swff.jpg",alt:"img"}})]),a._v(" "),s("p",[a._v("代码编译过程")]),a._v(" "),s("ul",[s("li",[a._v("javac： javac -d . HelloWorld.java －－＞生成HelloWorld.class类文件")]),a._v(" "),s("li",[a._v("java：启动虚拟机(java)，运行类文件。如：java com.work.core.HelloWorld")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("源文件－－－＞编译器（javac.exe）－－－＞中间码( .class)－－－＞虚拟机（java.exe）－－－＞机器指令－－－＞CPU\n")])])]),s("h2",{attrs:{id:"变量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#变量","aria-hidden":"true"}},[a._v("#")]),a._v(" 变量")]),a._v(" "),s("p",[a._v("变量：在程序运行过程中固定不变的量")]),a._v(" "),s("p",[a._v("常量：")]),a._v(" "),s("ul",[s("li",[a._v("final来定义常量")]),a._v(" "),s("li",[a._v("常量一旦初始化后就无法再改动")]),a._v(" "),s("li",[a._v("常量名称通常使用大写字母")]),a._v(" "),s("li",[a._v("必须要在常量声明的时候就对其进行初始化，否则会出现编译错误")])]),a._v(" "),s("p",[a._v("常量分类：")]),a._v(" "),s("ul",[s("li",[a._v("字符串常量")]),a._v(" "),s("li",[a._v("整数常量")]),a._v(" "),s("li",[a._v("浮点数常量")]),a._v(" "),s("li",[a._v("字符常量")]),a._v(" "),s("li",[a._v("布尔常量")]),a._v(" "),s("li",[a._v("空常量")]),a._v(" "),s("li",[a._v("null")])]),a._v(" "),s("p",[a._v("变量声明：")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("给变量起名，是给变量选择一种数据类型。如：int age；")])]),a._v(" "),s("li",[s("p",[a._v("不同的变量：")]),a._v(" "),s("ul",[s("li",[a._v("1）参与的运算是不同的，")]),a._v(" "),s("li",[a._v("2）存储的值是不同的，")]),a._v(" "),s("li",[a._v("3）需要的存储空间的大小也不同")])])])]),a._v(" "),s("p",[a._v("变量：")]),a._v(" "),s("ul",[s("li",[a._v("成员变量")]),a._v(" "),s("li",[a._v("局部变量")])]),a._v(" "),s("p",[a._v("实例变量和局部变量的区别：")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("1，位置：局部变量定义在方法里面。实例变量定义在类以内方法之外。")])]),a._v(" "),s("li",[s("p",[a._v("2，使用的范围：局部变量只能在定义他的方法里面使用，直接调用变量名就可以了。")])])]),a._v(" "),s("p",[a._v("​\t实例变量至少可以在定义他的整个类内使用，使用时必须用对象去调用。只有跟对象一起实例变量才有意义。")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("3，局部变量使用之前必须初始化。实例变量不需要赋初值，系统会给默认的初值。")])]),a._v(" "),s("li",[s("p",[a._v("4，局部变量在同一方法里不能重名。局部变量和实例变量可以重名，在方法里采用就近原则。")])])]),a._v(" "),s("h2",{attrs:{id:"数据类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 数据类型")]),a._v(" "),s("h3",{attrs:{id:"分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分类","aria-hidden":"true"}},[a._v("#")]),a._v(" 分类")]),a._v(" "),s("p",[a._v("基本数据类型：")]),a._v(" "),s("ul",[s("li",[a._v("整数类型\n"),s("ul",[s("li",[a._v("byte：8位，最大存储数据量是255，数据范围是-128~127")]),a._v(" "),s("li",[a._v("int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1")]),a._v(" "),s("li",[a._v("short：16位，最大数据存储量是65536，数据范围是-32768~32767之间")]),a._v(" "),s("li",[a._v("long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1")])])]),a._v(" "),s("li",[a._v("浮点数类型\n"),s("ul",[s("li",[a._v("float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F(1个符号，8个指数，23个尾数)")]),a._v(" "),s("li",[a._v("double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加(1个符号，11个指数，52个尾数)")])])]),a._v(" "),s("li",[a._v("字符类型\n"),s("ul",[s("li",[a._v("char：16位，存储Unicode码，用单引号赋值，char(一个字符＝2个字节)，只能表示一个字。  如：char c='中'; c存的是‘中‘这个字的编码。")])])]),a._v(" "),s("li",[a._v("布尔类型\n"),s("ul",[s("li",[a._v("boolean：只有true和false两个取值")])])])]),a._v(" "),s("p",[a._v("说明：")]),a._v(" "),s("ul",[s("li",[a._v("字符串不是基本类型，而是引用类型")]),a._v(" "),s("li",[a._v("浮点类型可能只是一个近视值，不是精确值")]),a._v(" "),s("li",[a._v("数据范围与字节数不一定相关，例如float范围比long更广，但是float长度为4，long长度为8")]),a._v(" "),s("li",[a._v("浮点数类型默认为double，整数类型模式为int")])]),a._v(" "),s("p",[s("strong",[a._v("引用数据类型：")])]),a._v(" "),s("ul",[s("li",[a._v("字符串")]),a._v(" "),s("li",[a._v("数组")]),a._v(" "),s("li",[a._v("类")]),a._v(" "),s("li",[a._v("接口")]),a._v(" "),s("li",[a._v("集合")]),a._v(" "),s("li",[a._v("Lambda")])]),a._v(" "),s("h3",{attrs:{id:"类型转换"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类型转换","aria-hidden":"true"}},[a._v("#")]),a._v(" 类型转换")]),a._v(" "),s("p",[a._v("自动类型转换：")]),a._v(" "),s("ul",[s("li",[a._v("不需要特殊编码，自动完成")]),a._v(" "),s("li",[a._v("数据范围从小到大")]),a._v(" "),s("li",[a._v("char--\x3ebyte--\x3eshort--\x3eint--\x3elong--\x3efloat--\x3edouble")])]),a._v(" "),s("p",[a._v("强制转换：")]),a._v(" "),s("ul",[s("li",[a._v("需要编码")]),a._v(" "),s("li",[a._v("范围大的转换为范围小的")]),a._v(" "),s("li",[a._v("损失精度，产生误差，小数点以后的数字全部舍弃")]),a._v(" "),s("li",[a._v("容易超过取值范围")])]),a._v(" "),s("h3",{attrs:{id:"封装类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#封装类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 封装类型")]),a._v(" "),s("ul",[s("li",[a._v("基本类型只能按值传递，而对应封装类是按引用传递的")]),a._v(" "),s("li",[a._v("基本类型是在堆栈上创建的，而所有的对象类型都是在堆上创建的。")]),a._v(" "),s("li",[a._v("默认值不同")]),a._v(" "),s("li",[a._v("封装类的出现，是为了更方便的使用一些基本类型不具备的方法，比如valueOf()，toString()等等")]),a._v(" "),s("li",[a._v("装箱时基本类型会自动封装成封装类型，拆箱时反之")])]),a._v(" "),s("h2",{attrs:{id:"类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类","aria-hidden":"true"}},[a._v("#")]),a._v(" 类")]),a._v(" "),s("h3",{attrs:{id:"对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对象","aria-hidden":"true"}},[a._v("#")]),a._v(" 对象")]),a._v(" "),s("p",[a._v("对象是用来描述客观存在的事物的一个实体，它是构成复杂系统的一个基本单位。一个对象由一组属性和对这组属性进行操作的一组服务组成。")]),a._v(" "),s("p",[a._v("面向过程：是代码的容器。")]),a._v(" "),s("p",[a._v("面向对象：对象所共有的功能和属性进行抽像，成为了类，是客观事物在人脑中的主观反映。在程序里类是创建对象的模板。")]),a._v(" "),s("h3",{attrs:{id:"方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#方法","aria-hidden":"true"}},[a._v("#")]),a._v(" 方法")]),a._v(" "),s("p",[a._v("什么是方法？")]),a._v(" "),s("ul",[s("li",[a._v("方法是解决一类问题的步骤的有序组合")]),a._v(" "),s("li",[a._v("方法包含于类或对象中")]),a._v(" "),s("li",[a._v("方法在程序中被创建，在其他地方被引用")])]),a._v(" "),s("p",[a._v("方法的优点：")]),a._v(" "),s("ul",[s("li",[a._v("使程序变得更简短而清晰")]),a._v(" "),s("li",[a._v("有利于程序维护")]),a._v(" "),s("li",[a._v("可以提高程序开发的效率")]),a._v(" "),s("li",[a._v("提高了代码的重用性")])]),a._v(" "),s("p",[a._v("方法的定义：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("修饰符 返回值类型 方法名(参数类型 参数名){\n    ...\n    方法体\n    ...\n    return 返回值;\n}\n")])])]),s("ul",[s("li",[a._v("修饰符：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。")]),a._v(" "),s("li",[a._v("返回值类型 ：方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字void。")]),a._v(" "),s("li",[a._v("方法名：是方法的实际名称。方法名和参数表共同构成方法签名。方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头写，不使用连接符。例如：addPerson")]),a._v(" "),s("li",[a._v("参数类型：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。")]),a._v(" "),s("li",[a._v("方法体：方法体包含具体的语句，定义该方法的功能。")])]),a._v(" "),s("p",[a._v("变量作用域")]),a._v(" "),s("ul",[s("li",[a._v("方法内定义的变量被称为局部变量。")]),a._v(" "),s("li",[a._v("局部变量的作用范围从声明开始，直到包含它的块结束。")]),a._v(" "),s("li",[a._v("局部变量必须声明才可以使用。")]),a._v(" "),s("li",[a._v("方法的参数范围涵盖整个方法。参数实际上是一个局部变量。")])]),a._v(" "),s("h4",{attrs:{id:"修饰符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#修饰符","aria-hidden":"true"}},[a._v("#")]),a._v(" 修饰符")]),a._v(" "),s("p",[a._v("访问修饰符：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("\t修饰符 \t当前类 \t同一包内 \t子孙类 \t其他包\n\tpublic \t\t\tY \tY \tY \tY\n\tprotected \tY \tY \tY \tN\n\tdefault \t\tY \tY \tN \tN\n\tprivate \t\tY \tN \tN \tN\n")])])]),s("p",[a._v("访问控制和继承：")]),a._v(" "),s("ul",[s("li",[a._v("父类中声明为 public 的方法在子类中也必须为 public。")]),a._v(" "),s("li",[a._v("父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private")]),a._v(" "),s("li",[a._v("父类中声明为 private 的方法，不能够被继承")])]),a._v(" "),s("p",[a._v("非访问修饰符：")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("static修饰符")]),a._v("，用来修饰类方法和类变量。\n"),s("ul",[s("li",[a._v("静态变量：static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。")]),a._v(" "),s("li",[a._v("静态方法：static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。")])])]),a._v(" "),s("li",[s("strong",[a._v("final修饰符")]),a._v("，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。\n"),s("ul",[s("li",[a._v("final 变量：final 变量能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。\n"),s("ul",[s("li",[a._v("final 修饰符通常和 static 修饰符一起使用来创建类常量。")])])]),a._v(" "),s("li",[a._v("final 方法：类中的 final 方法可以被子类继承，但是不能被子类修改。\n声明 final 方法的主要目的是防止该方法的内容被修改。")]),a._v(" "),s("li",[a._v("final 类：final 类不能被继承，没有类能够继承 final 类的任何特性。")])])]),a._v(" "),s("li",[s("strong",[a._v("abstract 修饰符")]),a._v("，用来创建抽象类和抽象方法")]),a._v(" "),s("li",[s("strong",[a._v("synchronized 和 volatile 修饰符")]),a._v("，主要用于线程的编程")])]),a._v(" "),s("h4",{attrs:{id:"构造方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构造方法","aria-hidden":"true"}},[a._v("#")]),a._v(" 构造方法")]),a._v(" "),s("p",[a._v("构造方法：")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("没有返回类型，方法名必须和类同名。")])]),a._v(" "),s("li",[s("p",[a._v("构造方法不能手动调用，它只用在创建对象在时候，只出现在new之后。")])])]),a._v(" "),s("p",[a._v("​\t只要构造方法被调用运行，就一定有对象产生。")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("在一个对象的生命周期里，构造方法只能被调用一次。")])]),a._v(" "),s("li",[s("p",[a._v("类写好后一定有构造方法，")])])]),a._v(" "),s("p",[a._v("​\t如果程序没有显示的提供构造方法，JVM会提供一个默认的构造方法，public classname(){}")]),a._v(" "),s("p",[a._v("​\t如果程序显示提供，系统不再提供默认的")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("同一个类的多个构造方法一定重载。")])]),a._v(" "),s("li",[s("p",[a._v("创建对象的同时构造方法的代码块里还可以写需要运行的代码，还可以给属性（实例变量）赋值。")])])]),a._v(" "),s("p",[a._v("引用类型的属性赋值就是用new创建对象，然后调用构造方法。如：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Student")]),a._v(" stu"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Student")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("p",[a._v("用new创建对象时JVM做的三件事：")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("1，申请空间；（把值放到空间里，再把空间的地址给引用变量。）－－－－创建父类对象")])]),a._v(" "),s("li",[s("p",[a._v("2，初始化实例变量；没显示声明值的话就用默认值。")])]),a._v(" "),s("li",[s("p",[a._v("3，执行构造方法，")])])]),a._v(" "),s("p",[a._v("因为实例变量在创建对象的过程中被初始化，所以使用实例变量前必须创建对象（要用对象去调用），否则实例变量根本不存在。")]),a._v(" "),s("h4",{attrs:{id:"方法重载"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#方法重载","aria-hidden":"true"}},[a._v("#")]),a._v(" 方法重载")]),a._v(" "),s("p",[a._v("方法重载（overloading）：编译时多态。")]),a._v(" "),s("p",[s("strong",[a._v("在一个类的内部，方法名相同形参数不同的方法，对返回类型不要求")]),a._v("，这种现象称之为重载；")]),a._v(" "),s("p",[a._v("编译器会自动选择使用的方法。体现了一个"),s("strong",[a._v("编译时多态")]),a._v("。")]),a._v(" "),s("p",[a._v("好处：对使用者屏蔽因为参数不同造成方法间的差异。")]),a._v(" "),s("p",[a._v("找方法时如果没有合适的，采取自动向上扩展原则。")]),a._v(" "),s("p",[a._v("调用时形参之间的区别一定要明确。")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("形参的个数不同")])]),a._v(" "),s("li",[s("p",[a._v("形参的类型不同")])]),a._v(" "),s("li",[s("p",[a._v("形参的顺序不同")])]),a._v(" "),s("li",[s("p",[a._v("形参的名字相同")])])]),a._v(" "),s("h4",{attrs:{id:"方法覆盖"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#方法覆盖","aria-hidden":"true"}},[a._v("#")]),a._v(" 方法覆盖")]),a._v(" "),s("p",[a._v("方法覆盖（override）："),s("strong",[a._v("运行时多态")]),a._v("。")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("1，发生在父类和子类之间")])]),a._v(" "),s("li",[s("p",[a._v("2，方法名相同，参数相同，返回类型相同")])]),a._v(" "),s("li",[s("p",[a._v("3，子类方法的访问权限不能更严格，只能等于或更加宽松。")])])]),a._v(" "),s("h4",{attrs:{id:"this"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this","aria-hidden":"true"}},[a._v("#")]),a._v(" this")]),a._v(" "),s("p",[a._v("1，在普通方法里，指代当前对象引用（哪个对象调用该方法，this就指向该对象）")]),a._v(" "),s("p",[a._v("2，this不能出现在静态方法里。")]),a._v(" "),s("p",[a._v("3，在构造方法里，this用来指代本类的其他构造方法。在本类构造方法之间互相调用。如：this(形参);")]),a._v(" "),s("p",[a._v("​\t使用时放在构造方法里的第一行。")]),a._v(" "),s("p",[a._v("4，不能写成死循环（不能递归调用）")]),a._v(" "),s("h4",{attrs:{id:"参数传递"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参数传递","aria-hidden":"true"}},[a._v("#")]),a._v(" 参数传递")]),a._v(" "),s("p",[a._v("基本类型数据传递的是本身的值，引用类型数据传递的是引用（地址，对象变量本身的值）")]),a._v(" "),s("h3",{attrs:{id:"面向对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面向对象","aria-hidden":"true"}},[a._v("#")]),a._v(" 面向对象")]),a._v(" "),s("h4",{attrs:{id:"封装"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#封装","aria-hidden":"true"}},[a._v("#")]),a._v(" 封装")]),a._v(" "),s("p",[a._v("封装（Encapsulation）就是隐藏所有属性和方法的实现细节，公开方法的功能。")]),a._v(" "),s("p",[a._v("访问控制修饰符：public（公开的），protected（受保护的，1，本包内可见；2，其他包的子类可见）")]),a._v(" "),s("p",[a._v("​\t\t\t\t default（默认，本包内可见），private（私有的，类内部可见）")]),a._v(" "),s("h4",{attrs:{id:"继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#继承","aria-hidden":"true"}},[a._v("#")]),a._v(" 继承")]),a._v(" "),s("p",[a._v("继承（inheritance）：抽象出不变性。从一般到特殊的关系，可以设计成继承")]),a._v(" "),s("p",[s("strong",[a._v("对于父类里的属性和方法，子类有权访问的，我们称为可以继承")]),a._v("。")]),a._v(" "),s("p",[a._v("特点：")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("共性写在父类里面，特性写在子类")])]),a._v(" "),s("li",[s("p",[a._v("所有类的总父类是\tObject (Object是类的祖先)")])]),a._v(" "),s("li",[s("p",[a._v("父类里写的是共性，子类里写的是特性。")])]),a._v(" "),s("li",[s("p",[a._v("父类中用private修饰的属性和方法不能被子类继承；")])]),a._v(" "),s("li",[s("p",[a._v("但是父类里的属性子类都有，如果子类有特殊属性的话，就要在子类里定义，且在创建该子类对象的时候初始化属性（包括父类所有属性和该子类所有属性）；")])])]),a._v(" "),s("p",[a._v("用new创建子类对象，JVM执行的过程：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Dog")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("extends")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Animal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("    \n\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Dog")]),a._v(" d"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Dog")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" \n")])])]),s("ul",[s("li",[s("p",[a._v("（1）申请空间；（把值放到空间里，再把空间的地址给引用变量。）")])]),a._v(" "),s("li",[s("p",[a._v("（2）看本类构造方法的第一句")])]),a._v(" "),s("li",[s("p",[a._v("（3）默认的创建父类对象：")])])]),a._v(" "),s("p",[a._v("​\t执行顺序：子类（2）－－－＞  父类（2－－＞3－－＞4－－＞5）－－－＞   子类（4－－＞5），")]),a._v(" "),s("p",[a._v("​\t新建一个对象空间只申请一次（该空间存放所有父类和子类）。）")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("（4）初始化本类的实例变量（该类的所有属性）；")])]),a._v(" "),s("li",[s("p",[a._v("（5）执行本类的构造方法，（构造方法只会在创建一个对象的时候被执行一次）")])])]),a._v(" "),s("p",[a._v("用super调用父类被子类覆盖的普通方法和遮盖的属性，指代的是在创建子类对象过程中，由JVM自动创建的那个父类，如："),s("code",[a._v("super.方法名（）")])]),a._v(" "),s("p",[a._v("用super调用父类的构造方法；必须出现在子类构造方法的第一句。如："),s("code",[a._v("super(形参);")])]),a._v(" "),s("ul",[s("li",[a._v("1，在子类的构造方法里如果没有指明调用哪一个父类的构造方法（就是子类中没有super（形参）语句；）")])]),a._v(" "),s("p",[a._v("​\tJVM会默认调用父类的无参构造方法，跟本类构造方法的形参没有关系。")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("2，显示的写super，JVM会根据参数调用相应的父类构造方法。")])]),a._v(" "),s("li",[s("p",[a._v("3，有this(形参)，在本类的构造方法之间调用，看被调用的那个构造方法的第一行。")])])]),a._v(" "),s("h4",{attrs:{id:"多态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多态","aria-hidden":"true"}},[a._v("#")]),a._v(" 多态")]),a._v(" "),s("p",[a._v("多态（polymorphism）：多态只有方法多态，没有属性多态。用父类类型屏蔽子类之间的差异")]),a._v(" "),s("p",[a._v("所有的子类对象都可以当父类对象来用，一个父类型的引用可能指向的是一个子类对象，")]),a._v(" "),s("p",[a._v("如：把狗（对象）看作动物（类型）。")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Animal")]),a._v(" a"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Dog")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\t\t\t\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//（编译时类型）\t（运行时类型）")]),a._v("\n")])])]),s("p",[a._v("编译看前面，运行看后面。")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("1，运行时对象不会改变（对象是客观存在的），如：狗这个对象的属性和方法是不会改变的。")])]),a._v(" "),s("li",[s("p",[a._v("2，对一个引用，只能调用编译时类型里的已知方法。")])])]),a._v(" "),s("p",[a._v("​\t如：编译器知道动物里已有的属性和方法，但不知道狗的属性和方法。")]),a._v(" "),s("ul",[s("li",[a._v("3，运行时会根据运行时类型自动寻找覆盖过的方法运行。")])]),a._v(" "),s("h4",{attrs:{id:"static"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#static","aria-hidden":"true"}},[a._v("#")]),a._v(" static")]),a._v(" "),s("p",[a._v("static变量：如：static int index=2;")]),a._v(" "),s("p",[a._v("类的所有对象共同拥有的一个属性；可以用类名直接访问，又称为类变量，类第一次被加载时会初始化静态变量（也就是会先执行static修饰的变量）；")]),a._v(" "),s("p",[a._v("跟类创建了多少对象无关；任何对象对静态变量做的修改，其他对象看到的是修改后的值。")]),a._v(" "),s("p",[a._v("可以用作计数器，记录类创建对象的个数 ， static变量在类加载的时候只会被初始化一次，")]),a._v(" "),s("p",[a._v("​")]),a._v(" "),s("p",[a._v("static方法：如："),s("code",[a._v("public static void teach(){}")])]),a._v(" "),s("p",[a._v("可以用类名直接去调用，不需要对象所以不能直接访问（在没有对象的情况下）实例变量，")]),a._v(" "),s("p",[a._v("在静态方法里不能出现this和super，类的所有对象共同拥有的一个方法；跟类创建了多少对象无关。")]),a._v(" "),s("p",[a._v("在继承里，父类的静态方法只能被子类的静态方法覆盖，且覆盖以后没有多态，（访问的是父类的静态方法）；")]),a._v(" "),s("p",[a._v("static初始化块：如：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Teacher")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" index"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//static初始化块")]),a._v("\n\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("静态初始华块：用static修饰类里面的一个独立的代码块，类第一次被JVM加载的时候执行，只被执行一次。")]),a._v(" "),s("p",[a._v("​")]),a._v(" "),s("p",[a._v("类加载：JVM在第一次使用一个类时，会到classpath所指定的路径去找这个类所对应的字节码文件，并读进JVM保存起来，这个过程称之为类加载，一个线程一个jvm。")]),a._v(" "),s("h4",{attrs:{id:"final"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#final","aria-hidden":"true"}},[a._v("#")]),a._v(" final")]),a._v(" "),s("p",[a._v("final类：如：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Animal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("表示该类不能被继承，意味着不能改变里面的代码；")]),a._v(" "),s("p",[a._v("对虚拟机的正常运行有重要作用的类通常用final修饰，如：String,System,Math ...等类")]),a._v(" "),s("p",[a._v("final方法：如：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("sleep")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("该方法不能被覆盖（修改），但能被子类访问。")]),a._v(" "),s("p",[a._v("​")]),a._v(" "),s("p",[a._v("final变量：如：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("final (static) int index=4;\n")])])]),s("p",[a._v("该变量是常量能被继承（访问）；")]),a._v(" "),s("p",[a._v("final修饰的变量就是常量，通常和static一起连用，来声明常量；")]),a._v(" "),s("p",[a._v("final修饰引用类型数据，指的是引用（地址）不能变，但引用里的数据不受限制。")]),a._v(" "),s("p",[a._v("final修饰的变量，只要在初始化的过程中就可以赋值。")]),a._v(" "),s("p",[a._v("实例变量：声明的同时或构造方法里赋值；")]),a._v(" "),s("p",[a._v("静态变量：声明的同时或在静态代码块里赋值；")]),a._v(" "),s("h4",{attrs:{id:"abstract"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#abstract","aria-hidden":"true"}},[a._v("#")]),a._v(" abstract")]),a._v(" "),s("p",[a._v("abstract类：如：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("abstract")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Animal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("抽象类，不能创建对象(如一些父类)，但是可以声明一个抽象类型的引用（可以声明父类类型子类对象，编译时利用多态调用抽象方法）。")]),a._v(" "),s("p",[a._v("含有抽象方法的类一定是抽象类，但抽象类并不一定要有抽象方法；")]),a._v(" "),s("p",[a._v("抽象类一般是用来被继承的；子类继承自抽象类，就要实现里面的抽象方法，")]),a._v(" "),s("p",[a._v("如果不想让子类也是抽象类的话，必须实现父类里面所有的抽象方法。")]),a._v(" "),s("p",[a._v("抽象类有构造方法，有父类，也遵循单继承的规律。")]),a._v(" "),s("p",[a._v("​")]),a._v(" "),s("p",[a._v("abstract方法：如：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("abstract")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("sleep")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("p",[a._v("抽象方法，只有方法名的定义，没有实现体（只定义了能做什么，没定义怎么做），不能被调用，")]),a._v(" "),s("p",[a._v("用于被子类的方法覆盖或重新实现。只能放在抽象类中。")]),a._v(" "),s("p",[a._v("好处：允许方法的定义和实现分开。")]),a._v(" "),s("p",[a._v("可以：")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("public static")])]),a._v(" "),s("li",[s("p",[a._v("private static")])]),a._v(" "),s("li",[s("p",[a._v("public final")])]),a._v(" "),s("li",[s("p",[a._v("public static final")])])]),a._v(" "),s("p",[a._v("不可以：")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("abstract final void eat();")])]),a._v(" "),s("li",[s("p",[a._v("private abstract void eat();")])]),a._v(" "),s("li",[s("p",[a._v("static abstract void eat();")])])]),a._v(" "),s("p",[s("strong",[a._v("abstract不能和final、private、static连用。")])]),a._v(" "),s("h4",{attrs:{id:"interface"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#interface","aria-hidden":"true"}},[a._v("#")]),a._v(" interface")]),a._v(" "),s("p",[a._v("理解为接口是一个特殊的抽象类，所以接口不能创建对象，且接口没有构造方法，")]),a._v(" "),s("p",[a._v("但可以声明一个接口类型的引用，m是接口类型实现类对象，如：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("M m=new N();\n")])])]),s("p",[a._v("接口存在的意义是被子类实现，如果不想让子类也抽象，就要实现接口里面所有的抽象方法，实现过程中注意访问权限；")]),a._v(" "),s("p",[a._v("用  implements 关键字实现接口")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("接口里面的常量默认都是public static final的；")])]),a._v(" "),s("li",[s("p",[a._v("接口里面的方法默认都是public abstract的。")])])]),a._v(" "),s("p",[a._v("​")]),a._v(" "),s("p",[a._v("接口本身支持多继承，继承了父接口里功能的定义，如：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("interface")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("A")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("extends")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("B")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("C")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("D")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\t\t\n")])])]),s("p",[a._v("类可以同时继承一个父类和实现接口（或多个接口），如：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" AA "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("extends")]),a._v(" BB "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("implements")]),a._v(" CC"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("DD"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("EE"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//AA，BB是类，CC，DD，EE是接口；")]),a._v("\n")])])]),s("p",[a._v("作用：")]),a._v(" "),s("ul",[s("li",[a._v("用接口去实现多继承，接口是对类的共性进行再次抽象，抽象出类的次要类型。")])]),a._v(" "),s("p",[a._v("​\t\t\t如：蜘蛛侠，拥有人和蜘蛛的属性，但主要类型是人，次要类型（接口）是蜘蛛，因为接口是次要类型，所以在类关系里不占一个节点，不会破坏类层次关系的树状结构，")]),a._v(" "),s("ul",[s("li",[a._v("标准（保证弱耦合）：一个接口就是一个标准（里面的属性不能改变，只定义了功能，")])]),a._v(" "),s("p",[a._v("但没有被实现），接口将标准的制定者，标准的实现者以及标准的使用者分离开，降低实现者和使用者的耦合。接口是java里一种重要的降低耦合的工具；接口可以屏蔽不同实现类的差异，当底层的实现类更换后，不会对上层的使用者产生影响，体现在参数和返回值。")]),a._v(" "),s("p",[a._v("​")]),a._v(" "),s("p",[a._v("写程序时，应该先写实现者再写使用者，如：Bank.java是实现者，View.java是使用者，但是有了接口之后，就可以用接口回调的功能；")]),a._v(" "),s("p",[a._v("接口回调：")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("先定义接口，然后写使用者和实现者的顺序随便（一般是先写使用者，后写实现者）；")])]),a._v(" "),s("li",[s("p",[a._v("利用参数把实现者传给使用者（即：实现者是使用者的属性），使用者利用接口调用实现者相应的功能。")])])]),a._v(" "),s("h4",{attrs:{id:"object"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object","aria-hidden":"true"}},[a._v("#")]),a._v(" Object")]),a._v(" "),s("p",[a._v("Object是Java里所有类的直接或间接父类，Object类里面的所有功能是所有java类共有的")]),a._v(" "),s("ul",[s("li",[a._v("1，JVM调用垃圾回收器回收不用的内存（没有引用指向的对象）前运行"),s("strong",[a._v("finalize()")]),a._v("，给JVM用的方法。")])]),a._v(" "),s("p",[a._v("​\t程序显示的通知JVM回收没用的内存（但不一定马上就回收）："),s("code",[a._v("System.gc();")]),a._v("或  "),s("code",[a._v("Runtime.getRuntime().gc();")])]),a._v(" "),s("ul",[s("li",[s("p",[a._v("2，"),s("code",[a._v("toString()")]),a._v("返回对象的字符串表现形式，打印对象时，虚拟机会自动调用"),s("code",[a._v("toString")]),a._v("获取对象的字符串表现格式，如：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("System.out.println(str.toString());\nSystem.out.println(str);\n")])])])])]),a._v(" "),s("p",[a._v("​\t如果本类不提供（覆盖）"),s("code",[a._v("toString()")]),a._v("，那么使用的是Object类里的相应方法，打印的就是地址，如：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("toString")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"....."')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("ul",[s("li",[a._v("3，**基本类型时，“==“判断变量本身的值是否相等；引用类型时，判断的是地址是否相等。equals判断的是对象内容是否相等。**对于自己创建的类，应该覆盖Object类的equals()方法，否则使用的是Object类里的equals()方法，比的是地址。")])]),a._v(" "),s("p",[a._v("​\t覆盖方法如下：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("boolean")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("equals")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" o"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("  \n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("o"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("o"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("o"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getClass")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getClass")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Student")]),a._v(" s"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Student")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("o"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("equals")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("&&")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("age"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v("s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("age "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//比较原则；")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("  \n")])])]),s("p",[a._v("覆盖euqals()方法时遵循的原则：")]),a._v(" "),s("ul",[s("li",[a._v("自反性："),s("code",[a._v("a.quals(a);\t//true")])]),a._v(" "),s("li",[a._v("对称性："),s("code",[a._v("a.equals(b);＜==＞ b.equals(a);\t//true")])]),a._v(" "),s("li",[a._v("传递性："),s("code",[a._v("a.equals(b);//true \t\t b.equals(c); //true －－－＞则：a.equals(c); //为true")])])]),a._v(" "),s("p",[a._v("​")]),a._v(" "),s("h4",{attrs:{id:"封装类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#封装类","aria-hidden":"true"}},[a._v("#")]),a._v(" 封装类")]),a._v(" "),s("p",[a._v("封装类（Wrapper class）：OverLoading时，基本类型时采用向上匹配原则，如果没有基本类型的话就向包装类转换，如果还没有就让这个基本类型在包装类里也采用向上匹配原则；")]),a._v(" "),s("p",[a._v("装箱和拆箱：")]),a._v(" "),s("p",[a._v("装箱：基本类型转换到－－＞包装类：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("boolean")]),a._v("－－－－－＞"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Boolean")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v("－－－－－－－－＞"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Integer")]),a._v("   \t"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//Integer是引用类型，")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v("－－－－－－－－＞"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Ddouble")]),a._v("\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//合法，\t\t但Integer－－－－－－＞Double\t非法")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("double")]),a._v("－－－－－－＞"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Double")]),a._v("\n\n\n任何类型－－－－－＞"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v("\n")])])]),s("p",[a._v("基本数据类型int可以向double自动扩展，但是包装类型之间不能自动的相互转换，举例：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Integer")]),a._v(" it"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Integer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//手动转换；基本类型向包装类型转换。")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("－－－－"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Integer")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("－－－－"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v("\n")])])]),s("p",[a._v('转换时String类型必须为全数字字符串。如："2515"\t 不能为："abc265","aec"…等。')]),a._v(" "),s("p",[a._v("拆箱：")]),a._v(" "),s("h4",{attrs:{id:"内部类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内部类","aria-hidden":"true"}},[a._v("#")]),a._v(" 内部类")]),a._v(" "),s("p",[a._v("定义在其他代码块（类体或者方法体）里的类称为内部类；编译后每一个内部类都会有自己的独立的字节码文件，")]),a._v(" "),s("p",[a._v("文件名："),s("code",[a._v("Outer$Inner.class")]),a._v("－－＞内部类也可以有父类和实现接口。也可以有抽象方法。")]),a._v(" "),s("p",[a._v("根据位置和修饰符的不同分为四种：")]),a._v(" "),s("ul",[s("li",[a._v("1，member inner class\t成员内部类，当实例方法或变量一样理解。\n"),s("ul",[s("li",[a._v("1）定义的位置：类以内，方法之外，没有静态修饰符（static）。")]),a._v(" "),s("li",[a._v("2）本身能定义的属性和方法：只能定义非静态的属性和方法。")]),a._v(" "),s("li",[a._v("3）能直接访问的什么：能访问外部类的所有静态和非静态的属性或方法。")]),a._v(" "),s("li",[a._v("4）怎么创建对象：在外部类内的方法内：Outer.Inner inner=new Outer().new Inner();")])])])]),a._v(" "),s("p",[a._v("​\t\t 在外部类外的类的方法内：Outer.Inner inner=new Outer().new Inner();或")]),a._v(" "),s("p",[a._v("在Outer类里提供一个getInner()方法,返回内部类的对象，这样在外部类外的类的方法内也可以用该成员内部类。")]),a._v(" "),s("p",[a._v("​")]),a._v(" "),s("ul",[s("li",[a._v("2，static inner class \t静态内部类（嵌套内部类），当静态方法或变量一样理解。static只能修饰内部类，不能修饰外部类。\n"),s("ul",[s("li",[a._v("1）定义的位置：类以内，方法之外，有静态修饰符（static）。一般写在外部类的属性下面。")]),a._v(" "),s("li",[a._v("2）本身能定义的属性和方法：可以定义静态和非静态的属性或方法。")]),a._v(" "),s("li",[a._v("3）能直接访问的什么：只能访问外部类的静态属性和方法。")]),a._v(" "),s("li",[a._v("4）怎么创建对象：\n"),s("ul",[s("li",[a._v("在外部类内的类方法里： \tOuter.Inner inner=new Outer.Inner();")]),a._v(" "),s("li",[a._v("在外部类外的类方法里：   Outer.Inner inner=new Outer.Inner();")])])])])])]),a._v(" "),s("p",[a._v("​")]),a._v(" "),s("ul",[s("li",[a._v("3，local inner class \t\t局部内部类\t\t当局部变量一样理解。\n"),s("ul",[s("li",[a._v("1）定义的位置：方法里面的类，前面不能用public或static修饰。")]),a._v(" "),s("li",[a._v("2）本身能定义的属性和方法：只能定义非静态的属性和方法。")]),a._v(" "),s("li",[a._v("3）能直接访问的什么：能访问方法内用final修饰的局部变量（不能与该类内的变量名相同）。能访问外部类的所有静态和非静态的属性或方法。")]),a._v(" "),s("li",[a._v("4）怎么创建对象：只能在方法内创建对象，如：Inner inner=new Inner(); 对象的作用范围只在方法内。")])])])]),a._v(" "),s("p",[a._v("​")]),a._v(" "),s("ul",[s("li",[a._v("4，annonymous inner class\t\t匿名内部类\t如：\tTeacher tc=new Teacher(){}\n"),s("ul",[s("li",[a._v("1）没有名字的类，没有构造方法。是一个特殊的局部内部类，可以实现一个接口，\t或者一个类，生命周期里只能产生一个对象(tc)，也就是说只能被一个对象（tc）调用")]),a._v(" "),s("li",[a._v("2）除了没有名字外，看匿名内部类所在的位置，他的定义和访问将和成员内部类、静态内部类、局部内部类一样。一般像局部内部类的定义和访问比较多。")]),a._v(" "),s("li",[a._v("3）当试图创建接口或者抽象类对象的时候，用匿名内部类。表示类体的{...}紧跟在抽象实例（接口）之后，表示实现该抽象实例（接口）。调用匿名内部类的方法只能用写类时创建的那个对象（tc）。")])])])]),a._v(" "),s("p",[a._v("作用：")]),a._v(" "),s("ul",[s("li",[a._v("1，不破坏访问权限的情况下，内部类可以使用外部类的私有成员变量和方法。")]),a._v(" "),s("li",[a._v("2，将接口公开，将实现类（实现公开的接口）作成内部类隐藏起来，强制要求使用者使用接口，强制降低偶合度。")]),a._v(" "),s("li",[a._v("3，Java通过接口和内部类两种机制来实现多继承。在类内部可以建立本类的实例，然后调用本类内的其他方法。")])]),a._v(" "),s("h2",{attrs:{id:"异常"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异常","aria-hidden":"true"}},[a._v("#")]),a._v(" 异常")]),a._v(" "),s("p",[a._v("Exception(异常)：运行时的概念。")]),a._v(" "),s("p",[a._v("1，Throwable：运行时可能碰到的任何问题的总称；")]),a._v(" "),s("ul",[s("li",[a._v("1）Error：指非常严重的错误，系统不要求程序员处理，也处理不了。如：硬件坏了.....等。")]),a._v(" "),s("li",[a._v("2）Exception：从代码的角度是程序员可以处理的问题；\n"),s("ul",[s("li",[a._v("UncheckedException(RuntimeException 的子类) （未检查异常），程序员小心谨慎完全可以避免的异常，系统不要求程序员处理（可以不管,运行会提示错误），如：3/0数组下标越界。")]),a._v(" "),s("li",[a._v("CheckedExcepiton   （已检查异常），系统要求必须处理异常。")])])])]),a._v(" "),s("p",[a._v("2，异常处理：异常是相对于方法来说的。")]),a._v(" "),s("p",[s("strong",[a._v("1）声明抛出异常（消极的处理）")]),a._v("，throws（抛弃）：写在方法名的定义上，后面跟要抛弃的异常类型，如：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("m1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("throws")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Exception")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("异常产生时，责任可能并不在当前方法，向外抛弃（把异常抛弃，留给调用者处理）可以让异常找到一个最佳的位置处理。")]),a._v(" "),s("p",[a._v("抛弃过程中可以对异常类型进行扩展，但是不能缩小。")]),a._v(" "),s("p",[a._v("throw（抛出）：一般出现在方法实现里，用来抛出异常对象（或者是产生异常），如：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("throw")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("FileNotFoundException")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("p",[a._v("当代码出现异常时，代码不会向下执行，JVM会将异常封装成相应的异常类的对象，然后向外抛出。之后这个方法里剩下的代码就不会再执行了。")]),a._v(" "),s("p",[a._v("​")]),a._v(" "),s("p",[a._v("对于一个方法的返回值：")]),a._v(" "),s("ul",[s("li",[a._v("1）正常运行时，要求方法必须返回定义的类型的值。")]),a._v(" "),s("li",[a._v("2）如果运行不正常（出现异常），方法返回的是异常对象")])]),a._v(" "),s("p",[a._v("方法覆盖：名相同，参数相同，返回类型相同，访问权限不能更小，子类抛弃的异常不能比父类更多。")]),a._v(" "),s("p",[s("strong",[a._v("2）try....catch（积极的处理）")]),a._v("：一个try语句后可以跟多个catch语句；catch时异常子类放上面，异常父类放下面。")]),a._v(" "),s("p",[a._v("如果没有父子关系，先后无所谓")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[a._v("method1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("try")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//可能会出现异常的代码")]),a._v("\n    xxxxxxxxxx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\t （"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v("）\n    xxxxxxxxxx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\t （"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v("）\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("catch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Exception1")]),a._v(" e1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//当try代码块出现异常时,执行catch代码块。")]),a._v("\n    xxxxxxxxx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\t （"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),a._v("）\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("catch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Exception2")]),a._v(" e2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n \t \txxxxxxxxx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\t （"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),a._v("）\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("finally")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//不管有没有异常出现都要执行的代码。")]),a._v("\n    xxxxxxxxx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\t （"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),a._v("）\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n  xxxxxxxxx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\t （"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("6")]),a._v("）\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("ul",[s("li",[s("p",[a._v("1）如果（1），（2）没产生异常，（2）执行后直接执行（5），然后执行（6）。")])]),a._v(" "),s("li",[s("p",[a._v("2）如果（1）产生异常，（2）不会被执行，直接跑出try{..},匹配catch，和catch里定义的类型一致，")])])]),a._v(" "),s("p",[a._v("执行catch完了后，直接跳到（5）执行，最后再执行（6）,如果异常类型都不一致，将导至语法问题。")]),a._v(" "),s("p",[s("strong",[a._v("3）自定义异常类型（业务异常")]),a._v("）：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("MyException")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("extends")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Exception")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("MyException")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" str"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("super")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("str"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])])])},[],!1,null,null,null);t.default=n.exports}}]);