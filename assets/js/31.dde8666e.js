(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{213:function(v,_,t){"use strict";t.r(_);var a=t(0),s=Object(a.a)({},function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程","aria-hidden":"true"}},[v._v("#")]),v._v(" 线程")]),v._v(" "),t("h2",{attrs:{id:"基本概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本概念","aria-hidden":"true"}},[v._v("#")]),v._v(" 基本概念")]),v._v(" "),t("p",[v._v("并行：多个线程可以同时执行，每一个时间段，可以有多个线程同时执行。")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://ww3.sinaimg.cn/large/006tNc79gy1g5etl48tdsj309806egls.jpg",alt:""}})]),v._v(" "),t("p",[v._v("并发：多个线程同时竞争一个位置，竞争到的才可以执行，每一个时间段只有一个线程在执行。")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://ww1.sinaimg.cn/large/006tNc79gy1g5etlcarplj308u06dweo.jpg",alt:""}})]),v._v(" "),t("p",[v._v("进程：是程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是程序的基本执行实体。")]),v._v(" "),t("p",[v._v("线程：进程中并发的一个顺序执行的最小调度单元。")]),v._v(" "),t("p",[v._v("并发原理：CPU分配时间片，多线程交替运行。宏观并行，微观串行。")]),v._v(" "),t("p",[v._v("进程和线程的关系：")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://ww2.sinaimg.cn/large/006tNc79gy1g5etm4ypu2j30eo06sq4l.jpg",alt:"这里写图片描述"}})]),v._v(" "),t("p",[v._v("进程间通信的方式：")]),v._v(" "),t("ul",[t("li",[v._v("信号")]),v._v(" "),t("li",[v._v("文件")]),v._v(" "),t("li",[v._v("管道")]),v._v(" "),t("li",[v._v("共享内存区")]),v._v(" "),t("li",[v._v("信号量")]),v._v(" "),t("li",[v._v("消息")]),v._v(" "),t("li",[v._v("socket")])]),v._v(" "),t("p",[t("strong",[v._v("线程间的协作")]),v._v("：")]),v._v(" "),t("p",[v._v("在一个进程中会出现多个线程会访问同一个内存区域，因此就需要使用一种线程间的协作手段来处理")]),v._v(" "),t("p",[t("strong",[v._v("线程的同步机制主要有：互斥量，信号量，条件变量")])]),v._v(" "),t("p",[t("strong",[v._v("互斥量 ：出现了mutex，就为互斥量，为锁机制")])]),v._v(" "),t("p",[v._v("(1)、在一个lock(加锁)和unlock(解锁)之间，形成的叫做："),t("strong",[v._v("临界区域")])]),v._v(" "),t("p",[t("strong",[v._v("线程同步")]),v._v("："),t("strong",[v._v("阻塞别人而完成自己（是不是就是让别人等等）。利用互斥量达到同步，使封锁区域最小化")])]),v._v(" "),t("p",[v._v("(2)、加锁后，没有解锁————>将发生阻塞(不能再进行加锁)")]),v._v(" "),t("p",[v._v("(3)、利用互斥量，将程序执行的不确定顺序变为了确定性的顺序")]),v._v(" "),t("p",[t("strong",[v._v("线程间同步")]),v._v("：")]),v._v(" "),t("p",[v._v("锁机制：互斥锁、条件变量、信号量、读写锁")]),v._v(" "),t("p",[v._v("互斥锁：提供了以排他方式数据结构被并发修改的方法")]),v._v(" "),t("p",[v._v("读写锁：写锁优先抢占资源，读锁允许多个线程共同读共享数据，而写锁操作是互斥的")]),v._v(" "),t("p",[v._v("条件变量：以原子方式阻塞进程，直到某个特定条件为真为止")]),v._v(" "),t("p",[v._v("一般情况下：互斥锁起保护作用，条件变量和互斥锁一起使用")]),v._v(" "),t("p",[t("strong",[v._v("总结：线程间通信的目的主要用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制")])]),v._v(" "),t("h2",{attrs:{id:"线程-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程-2","aria-hidden":"true"}},[v._v("#")]),v._v(" 线程")]),v._v(" "),t("p",[v._v("线程三要素：CPU、Date、Code")]),v._v(" "),t("p",[v._v("多线程间堆空间共享，栈空间独立。堆存的是地址，栈存的是变量（如：局部变量）")]),v._v(" "),t("p",[v._v("创建线程有 4 方式：继承 Thread+实现 Runnable+实现 Callable+线程池获得")]),v._v(" "),t("p",[v._v("Thread对象代表一个线程。")]),v._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("//表示新建一个线程对象，并不表示线程。")]),v._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Tread")]),v._v(" t"),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("new")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Thread")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])])]),t("p",[v._v("当调用"),t("code",[v._v("t.start();")]),v._v("才起动线程，当得到CPU时，就会执行线程t的方法体。")]),v._v(" "),t("p",[v._v("多线程共同访问的同一个对象（临界资源），如果破坏了不可分割的操作（原子操作），就会造成数据不一致的情况。")]),v._v(" "),t("p",[v._v("在java中，任何对象都有一个互斥锁标记，用来分配给线程。")]),v._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("synchronized")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("o"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n\t"),t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("//..同步代码块. .")]),v._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n")])])]),t("p",[v._v("对o（o是临界资源）加锁的同步代码块，哪个线程能拿到该对象（临界资源）的锁，哪个线程就能调用该对象（临界资源）的同步方法。退出同步代码块时，会自动释放o的锁标记。")]),v._v(" "),t("p",[v._v("一个线程，可以同时拥有多个对象的锁标记")]),v._v(" "),t("p",[v._v("在java中，任何对象都有一个锁池，用来存放等待该对象锁标记的线程，线程阻塞在对象锁池中时，不会释放其所拥有的其它对象的锁标记。")]),v._v(" "),t("p",[v._v("在java中，任何对象都有一个等待队列，用来存放线程，")]),v._v(" "),t("p",[v._v("线程t1对（让）o调用wait方法,必须放在对o加锁的同步代码块中!")]),v._v(" "),t("p",[v._v("1、t1会释放其所拥有的所有锁标记;")]),v._v(" "),t("p",[v._v("2、t1会进入o的等待队列")]),v._v(" "),t("p",[v._v("​\tt2对（让）o调用notify/notifyAll方法,也必须放在对o加锁的同步代码块中!")]),v._v(" "),t("p",[v._v("​\t会从o的等待队列中释放一个/全部线程，对t2毫无影响，t2继续执行。")]),v._v(" "),t("h1",{attrs:{id:"并发"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并发","aria-hidden":"true"}},[v._v("#")]),v._v(" 并发")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("说说线程安全问题，什么是线程安全，如何保证线程安全")])]),v._v(" "),t("li",[t("p",[v._v("重入锁的概念，重入锁为什么可以防止死锁")])]),v._v(" "),t("li",[t("p",[v._v("产生死锁的四个条件")]),v._v(" "),t("p",[v._v("互斥、请求与保持、不剥夺、循环等待")])]),v._v(" "),t("li",[t("p",[v._v("如何检查死锁（通过jConsole检查死锁）")])]),v._v(" "),t("li",[t("p",[v._v("volatile 实现原理（禁止指令重排、刷新内存）")])]),v._v(" "),t("li",[t("p",[v._v("synchronized 实现原理（对象监视器）")])]),v._v(" "),t("li",[t("p",[v._v("synchronized 与 lock 的区别")])]),v._v(" "),t("li",[t("p",[v._v("AQS同步队列")])]),v._v(" "),t("li",[t("p",[v._v("CAS无锁的概念、乐观锁和悲观锁")])]),v._v(" "),t("li",[t("p",[v._v("常见的原子操作类")])]),v._v(" "),t("li",[t("p",[v._v("什么是ABA问题，出现ABA问题JDK是如何解决的")])]),v._v(" "),t("li",[t("p",[v._v("乐观锁的业务场景及实现方式")])]),v._v(" "),t("li",[t("p",[v._v("Java 8并法包下常见的并发类")])]),v._v(" "),t("li",[t("p",[v._v("偏向锁、轻量级锁、重量级锁、自旋锁的概念")])]),v._v(" "),t("li",[t("p",[v._v("AtomicInteger底层实现原理；")])]),v._v(" "),t("li",[t("p",[v._v("synchronized与ReentraLock哪个是公平锁；")])]),v._v(" "),t("li",[t("p",[v._v("CAS机制会出现什么问题；")])]),v._v(" "),t("li",[t("p",[v._v("用过并发包下边的哪些类；")])]),v._v(" "),t("li",[t("p",[v._v("CopyOnWriteArrayList是什么；")])]),v._v(" "),t("li",[t("p",[v._v("Java中有哪些同步方案")]),v._v(" "),t("p",[v._v("重量级锁、显式锁、并发容器、并发同步器、CAS、volatile、AQS等")])])])])},[],!1,null,null,null);_.default=s.exports}}]);