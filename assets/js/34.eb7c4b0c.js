(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{215:function(e,t,v){"use strict";v.r(t);var _=v(0),r=Object(_.a)({},function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"开源框架"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#开源框架","aria-hidden":"true"}},[e._v("#")]),e._v(" 开源框架")]),e._v(" "),v("h2",{attrs:{id:"servlet"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#servlet","aria-hidden":"true"}},[e._v("#")]),e._v(" Servlet")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("HTTP请求的GET与POST方式的区别")]),e._v(" "),v("ul",[v("li",[e._v("GET在浏览器回退时是无害的，而POST会再次提交请求。")]),e._v(" "),v("li",[e._v("GET产生的URL地址可以被搜藏，而POST不可以。")]),e._v(" "),v("li",[e._v("GET请求会被浏览器主动cache，而POST不会，除非手动设置。")]),e._v(" "),v("li",[e._v("GET请求只能进行url编码，而POST支持多种编码方式。")]),e._v(" "),v("li",[e._v("GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。")]),e._v(" "),v("li",[e._v("GET请求在URL中传送的参数是有长度限制的，而POST么有。")]),e._v(" "),v("li",[e._v("对参数的数据类型，GET只接受ASCII字符，而POST没有限制。")]),e._v(" "),v("li",[e._v("GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。")]),e._v(" "),v("li",[e._v("GET参数通过URL传递，POST放在Request body中。")])])]),e._v(" "),v("li",[v("p",[e._v("Session与Cookie区别")]),e._v(" "),v("p",[e._v("（1）Cookie以文本文件格式存储在浏览器中，而session存储在服务端它存储了限制数据量。它只允许4kb它没有在cookie中保存多个变量。")]),e._v(" "),v("p",[e._v("（2）cookie的存储限制了数据量，只允许4KB，而session是无限量的")]),e._v(" "),v("p",[e._v("（3）我们可以轻松访问cookie值但是我们无法轻松访问会话值，因此它更安全")]),e._v(" "),v("p",[e._v("（4）设置cookie时间可以使cookie过期。但是使用session的destory()，我们将会销毁会话。")])]),e._v(" "),v("li",[v("p",[e._v("Servlet的生命周期")]),e._v(" "),v("p",[e._v("servlet 声明周期可以分四个阶段：")]),e._v(" "),v("ul",[v("li",[e._v("类装载过程")]),e._v(" "),v("li",[e._v("init() 初始化过程")]),e._v(" "),v("li",[e._v("service() 服务过程，选择doGet \\ doPost")]),e._v(" "),v("li",[e._v("destroy() 销毁过程")])])]),e._v(" "),v("li",[v("p",[e._v("转发与重定向的区别")])])]),e._v(" "),v("p",[e._v("共同点： 都实现了根据自己的条件实现的页面的跳转。")]),e._v(" "),v("p",[e._v("区别："),v("br"),e._v("\n1.类别    2.概念    3.共享数据    4.应用\nI.Redirect\nII.URL重新定向：可以是任意的URL\nIII.不能共享request里面的数据\nIV.一般用于用户注销登录时返回主页面和跳转到其它的网站等等")]),e._v(" "),v("p",[e._v("I.Forward\nII.页面的转发：只能是同一个Web应用程序的其他Web组件\nIII.转发页面和转发到的页面可以共享request里面的数据\nIV.一般用于用户登录的时候根据角色转发到相应的模块等等")]),e._v(" "),v("h2",{attrs:{id:"spring"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spring","aria-hidden":"true"}},[e._v("#")]),e._v(" Spring")]),e._v(" "),v("ul",[v("li",[e._v("MVC设计思想")]),e._v(" "),v("li",[e._v("BeanFactory 和 ApplicationContext 有什么区别")])]),e._v(" "),v("p",[v("strong",[e._v("BeanFactory：")])]),e._v(" "),v("p",[e._v("是Spring里面最低层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能；")]),e._v(" "),v("p",[v("strong",[e._v("ApplicationContext：")])]),e._v(" "),v("p",[e._v("应用上下文，继承BeanFactory接口，它是Spring的一各更高级的容器，提供了更多的有用的功能；")]),e._v(" "),v("ol",[v("li",[v("p",[e._v("国际化（MessageSource）")])]),e._v(" "),v("li",[v("p",[e._v("访问资源，如URL和文件（ResourceLoader）")])]),e._v(" "),v("li",[v("p",[e._v("载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层")])]),e._v(" "),v("li",[v("p",[e._v("消息发送、响应机制（ApplicationEventPublisher）")])]),e._v(" "),v("li",[v("p",[e._v("AOP（拦截器）")])])]),e._v(" "),v("p",[v("strong",[e._v("两者装载bean的区别")])]),e._v(" "),v("p",[v("strong",[e._v("BeanFactory：")])]),e._v(" "),v("p",[e._v("BeanFactory在启动的时候不会去实例化Bean，只有从容器中拿Bean的时候才会去实例化；")]),e._v(" "),v("p",[v("strong",[e._v("ApplicationContext：")])]),e._v(" "),v("p",[e._v("ApplicationContext在启动的时候就把所有的Bean全部实例化了。它还可以为Bean配置lazy-init=true来让Bean延迟实例化；")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("Spring Bean 的生命周期")]),e._v(" "),v("p",[v("img",{attrs:{src:"http://ww1.sinaimg.cn/large/006tNc79gy1g5euwkl4e8j30nv0ait9o.jpg",alt:""}})])]),e._v(" "),v("li",[v("p",[e._v("Spring IOC 如何实现")]),e._v(" "),v("p",[e._v("原先需要自行实例化的对象， 交给IOC容器去实现")]),e._v(" "),v("p",[v("strong",[e._v("注入方式：")])]),e._v(" "),v("ul",[v("li",[e._v("接口注入")]),e._v(" "),v("li",[e._v("setter")]),e._v(" "),v("li",[e._v("构造器注入")])]),e._v(" "),v("p",[e._v("IOC容器的设计与实现有两种：BeanFactory和ApplicationContext")])]),e._v(" "),v("li",[v("p",[e._v("Spring中Bean的作用域，默认的是哪一个")]),e._v(" "),v("p",[e._v("spring中提供了四种作用域")]),e._v(" "),v("table",[v("thead",[v("tr",[v("th",[e._v("作用域")]),e._v(" "),v("th",[e._v("字符")]),e._v(" "),v("th",[e._v("描述")])])]),e._v(" "),v("tbody",[v("tr",[v("td",[e._v("单例")]),e._v(" "),v("td",[e._v("singleton")]),e._v(" "),v("td",[e._v("整个应用中只创建一个实例，默认")])]),e._v(" "),v("tr",[v("td",[e._v("原型")]),e._v(" "),v("td",[e._v("prototype")]),e._v(" "),v("td",[e._v("每次注入时都新建一个实例")])]),e._v(" "),v("tr",[v("td",[e._v("会话")]),e._v(" "),v("td",[e._v("session")]),e._v(" "),v("td",[e._v("为每个会话创建一个实例")])]),e._v(" "),v("tr",[v("td",[e._v("请求")]),e._v(" "),v("td",[e._v("request")]),e._v(" "),v("td",[e._v("为每个请求创建一个实例")])])])])]),e._v(" "),v("li",[v("p",[e._v("说说 Spring AOP 实现原理")]),e._v(" "),v("p",[e._v("Spring AOP 使用了两种代理机制：")]),e._v(" "),v("ul",[v("li",[e._v("基于 JDK 的动态代理（接口代理）。")]),e._v(" "),v("li",[e._v("基于 CGLib 的动态代理（类代理）。")])])]),e._v(" "),v("li",[v("p",[e._v("动态代理（CGLib 与 JDK）、优缺点、性能对比、如何选择")])]),e._v(" "),v("li",[v("p",[e._v("Spring 事务实现方式、事务的传播机制、默认的事务类别")]),e._v(" "),v("p",[e._v("Spring事务的1+3种实现方式、7种传播行为、4种隔离级别：\n1）编程式事务管理：调用beginTransaction()、commit()、rollback()等事务管理相关的方法\n2）声明式事务管理：基于TransactionProxyFactoryBean的声明式事务管理：–很少使用\n3）声明式事务管理：基于AspectAOP声明式事务管理：–常使用\n4）声明式事务管理：基于注解@Transaction的声明式事务管理：–经常使用")]),e._v(" "),v("p",[e._v("1）propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。Spring默认的事务传播行为\n2）propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。\n3）propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。\n4）propagation_required_new：新建事务，如果当前事务存在，把当前事务挂起。\n5）propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\n6）propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。\n7）propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作。\n注：Spring事务的嵌套解析—-Spring的事务传播策略在内部方法调用时将不起作用")]),e._v(" "),v("p",[e._v("Spring的事务传播策略在两个不同的Service调用时会起作用")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("class ServiceA { \nvoid methodA() {ServiceB.methodB();} \n} \nclass ServiceB { \nvoid methodB() {… } \n} \n")])])]),v("p",[e._v("如果ServiceA.methodA已经起了事务，调用ServiceB.methodB时，B不新起事务，如果A没有事务，则B新建一个事务，B回滚A也回滚。")]),e._v(" "),v("p",[e._v("如果ServiceA.methodA已经起了事务，调用ServiceB.methodB时，B不新起事务，如果A没有事务，则B新建一个事务，B回滚A也回滚。")]),e._v(" "),v("p",[e._v("1）读未提交：T1读取T2未提交的东西，会出现脏读，不可重复读，幻读")]),e._v(" "),v("p",[e._v("2）读已提交：mysql默认，会出现不可重复读和幻读")]),e._v(" "),v("p",[e._v("3）可重复读：针对的是update操作，但是会出现幻读现象，幻读针对的是insert操作")]),e._v(" "),v("p",[e._v("4）串行化：解决了脏读、不可重复读和幻读，但是效率比较低")])]),e._v(" "),v("li",[v("p",[e._v("Spring 事务底层原理")])]),e._v(" "),v("li",[v("p",[e._v("如何自定义注解实现功能")])]),e._v(" "),v("li",[v("p",[e._v("Spring MVC 运行流程")]),e._v(" "),v("p",[v("img",{attrs:{src:"http://ww1.sinaimg.cn/large/006tNc79gy1g5ev24hrqrj30m00gjahl.jpg",alt:"img"}})])]),e._v(" "),v("li",[v("p",[e._v("Spring MVC 启动流程")])]),e._v(" "),v("li",[v("p",[e._v("Spring 的单例实现原理")]),e._v(" "),v("p",[e._v("Spring 对 Bean 实例的创建是采用单例注册表的方式进行实现的，而这个注册表的缓存是 ConcurrentHashMap 对象")])]),e._v(" "),v("li",[v("p",[e._v("spring中@Autowired和@Resource注解的区别？")]),e._v(" "),v("p",[e._v("相同点：\n@Resource的作用相当于@Autowired，均可标注在字段或属性的setter方法上。")]),e._v(" "),v("p",[e._v("不同点：\n（1）提供方：@Autowired是由org.springframework.beans.factory.annotation.Autowired提供，换句话说就是由Spring提供；@Resource是由javax.annotation.Resource提供，即J2EE提供，需要JDK1.6及以上。\n（2）注入方式：@Autowired只按照byType 注入；@Resource默认按byName自动注入，也提供按照byType 注入；\n（3）属性：@Autowired按类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false。如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。@Resource有两个中重要的属性：name和type。name属性指定byName，如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。需要注意的是，@Resource如果没有指定name属性，并且按照默认的名称仍然找不到依赖对象时， @Resource注解会回退到按类型装配。但一旦指定了name属性，就只能按名称装配了。")])]),e._v(" "),v("li",[v("p",[e._v("Spring声明一个 bean 如何对其进行个性化定制；")])]),e._v(" "),v("li",[v("p",[e._v("MyBatis的原理")])]),e._v(" "),v("li",[v("p",[e._v("可参考《"),v("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247484822&idx=1&sn=6fbee2a12b31b6102a18d3725671d41b&chksm=e9c5fc27deb275319641c3f30d168b85c7c196fd276d47efa35046b5dc54f5b77174c5bf8808&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("为什么会有Spring"),v("OutboundLink")],1),e._v("》")])]),e._v(" "),v("li",[v("p",[e._v("可参考《"),v("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247484827&idx=1&sn=b9d82f3fced6a875f8dfc22e5849b28e&chksm=e9c5fc2adeb2753c516ef8fc959c0c9dd84ccacaa40473b64bc58b5137c30562a0b45803ba8e&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("为什么会有Spring AOP"),v("OutboundLink")],1),e._v("》")])]),e._v(" "),v("li",[v("p",[e._v("一个Controller调用两个Service，这两Service又都分别调用两个Dao，问其中用到了几个数据库连接池的连接？")])]),e._v(" "),v("li",[v("p",[e._v("MyBatis怎么防止SQL注入；")]),e._v(" "),v("p",[e._v("这是因为MyBatis启用了预编译功能，在SQL执行前，会先将上面的SQL发送给数据库进行编译；执行时，直接使用编译好的SQL，替换占位符“?”就可以了。因为SQL注入只能对编译过程起作用，所以这样的方式就很好地避免了SQL注入的问题。")])]),e._v(" "),v("li",[v("p",[e._v("Tomcat本身的参数你⼀般会怎么调整？")])])]),e._v(" "),v("h2",{attrs:{id:"dubbo"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dubbo","aria-hidden":"true"}},[e._v("#")]),e._v(" Dubbo")]),e._v(" "),v("h1",{attrs:{id:"容器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#容器","aria-hidden":"true"}},[e._v("#")]),e._v(" 容器")]),e._v(" "),v("h2",{attrs:{id:"jetty"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jetty","aria-hidden":"true"}},[e._v("#")]),e._v(" Jetty")]),e._v(" "),v("h2",{attrs:{id:"tomcat"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tomcat","aria-hidden":"true"}},[e._v("#")]),e._v(" Tomcat")]),e._v(" "),v("h2",{attrs:{id:"resin"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#resin","aria-hidden":"true"}},[e._v("#")]),e._v(" Resin")]),e._v(" "),v("h2",{attrs:{id:"springboot集成"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#springboot集成","aria-hidden":"true"}},[e._v("#")]),e._v(" SpringBoot集成")])])},[],!1,null,null,null);t.default=r.exports}}]);