(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{222:function(t,a,e){"use strict";e.r(a);var r=e(0),v=Object(r.a)({},function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"消息队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#消息队列","aria-hidden":"true"}},[t._v("#")]),t._v(" 消息队列")]),t._v(" "),e("h2",{attrs:{id:"什么是-mq"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-mq","aria-hidden":"true"}},[t._v("#")]),t._v(" 什么是 MQ")]),t._v(" "),e("p",[t._v("消息队列，即MQ，Message Queue。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdn.net/20181019144009502?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5ajIwMThneXE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70",alt:"img"}})]),t._v(" "),e("p",[t._v("消息队列是典型的：生产者、消费者模型。生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，这样就实现了生产者和消费者的解耦。")]),t._v(" "),e("h2",{attrs:{id:"amqp和jms"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#amqp和jms","aria-hidden":"true"}},[t._v("#")]),t._v(" AMQP和JMS")]),t._v(" "),e("p",[t._v("MQ是消息通信的模型，并不是具体实现。现在实现MQ的有两种主流方式：AMQP、JMS。")]),t._v(" "),e("p",[e("img",{attrs:{src:"http://ww1.sinaimg.cn/large/006tNc79gy1g5a7u6q49oj30n2041aa9.jpg",alt:"img"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"http://ww4.sinaimg.cn/large/006tNc79gy1g5a7u5hc11j30n808t75a.jpg",alt:"img"}})]),t._v(" "),e("p",[t._v("两者间的区别和联系：")]),t._v(" "),e("p",[t._v("JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式")]),t._v(" "),e("p",[t._v("JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。")]),t._v(" "),e("p",[t._v("JMS规定了两种消息模型；而AMQP的消息模型更加丰富")]),t._v(" "),e("h2",{attrs:{id:"mq分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mq分类","aria-hidden":"true"}},[t._v("#")]),t._v(" MQ分类")]),t._v(" "),e("h3",{attrs:{id:"有-broker-的-mq"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#有-broker-的-mq","aria-hidden":"true"}},[t._v("#")]),t._v(" 有 Broker 的 MQ")]),t._v(" "),e("p",[t._v("这个流派通常有一台服务器作为 Broker，所有的消息都通过它中转。生产者把消息发送给它就结束自己的任务了，Broker 则把消息主动推送给消费者（或者消费者主动轮询）")]),t._v(" "),e("h4",{attrs:{id:"重-topic"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重-topic","aria-hidden":"true"}},[t._v("#")]),t._v(" 重 Topic")]),t._v(" "),e("p",[t._v("kafka、JMS（ActiveMQ）就属于这个流派，生产者会发送 key 和数据到 Broker，由 Broker 比较 key 之后决定给哪个消费者。这种模式是我们最常见的模式，是我们对 MQ 最多的印象。在这种模式下一个 topic 往往是一个比较大的概念，甚至一个系统中就可能只有一个 topic，topic 某种意义上就是 queue，生产者发送 key 相当于说：“hi，把数据放到 key 的队列中”")]),t._v(" "),e("p",[e("img",{attrs:{src:"http://ww1.sinaimg.cn/large/006tNc79gy1g57voqv0maj30gq057mwz.jpg",alt:"img"}})]),t._v(" "),e("p",[t._v("如上图所示，Broker 定义了三个队列，key1，key2，key3，生产者发送数据的时候会发送 key1 和 data，Broker 在推送数据的时候则推送 data（也可能把 key 带上）。")]),t._v(" "),e("p",[t._v("虽然架构一样但是 kafka 的性能要比 jms 的性能不知道高到多少倍，所以基本这种类型的 MQ 只有 kafka 一种备选方案。如果你需要一条暴力的数据流（在乎性能而非灵活性）那么 kafka 是最好的选择")]),t._v(" "),e("h4",{attrs:{id:"轻-topic"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#轻-topic","aria-hidden":"true"}},[t._v("#")]),t._v(" 轻 Topic")]),t._v(" "),e("p",[t._v("这种的代表是 RabbitMQ（或者说是 AMQP）。生产者发送 key 和数据，消费者定义订阅的队列，Broker 收到数据之后会通过一定的逻辑计算出 key 对应的队列，然后把数据交给队列")]),t._v(" "),e("p",[e("img",{attrs:{src:"http://ww4.sinaimg.cn/large/006tNc79gy1g57vos8r3oj30op08mmx3.jpg",alt:"img"}})]),t._v(" "),e("p",[t._v("这种模式下解耦了 key 和 queue，在这种架构中 queue 是非常轻量级的（在 RabbitMQ 中它的上限取决于你的内存），消费者关心的只是自己的 queue；生产者不必关心数据最终给谁只要指定 key 就行了，中间的那层映射在 AMQP 中叫 exchange（交换机）。")]),t._v(" "),e("p",[t._v("AMQP 中有四种 exchange")]),t._v(" "),e("ul",[e("li",[t._v("Direct exchange：key 就等于 queue")]),t._v(" "),e("li",[t._v("Fanout exchange：无视 key，给所有的 queue 都来一份")]),t._v(" "),e("li",[t._v("Topic exchange：key 可以用“宽字符”模糊匹配 queue")]),t._v(" "),e("li",[t._v("Headers exchange：无视 key，通过查看消息的头部元数据来决定发给那个 queue（AMQP 头部元数据非常丰富而且可以自定义）")])]),t._v(" "),e("p",[t._v("这种结构的架构给通讯带来了很大的灵活性，我们能想到的通讯方式都可以用这四种 exchange 表达出来。如果你需要一个企业数据总线（在乎灵活性）那么 RabbitMQ 绝对的值得一用")]),t._v(" "),e("h3",{attrs:{id:"无-broker-的-mq"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#无-broker-的-mq","aria-hidden":"true"}},[t._v("#")]),t._v(" 无 Broker 的 MQ")]),t._v(" "),e("p",[t._v("无 Broker 的 MQ 的代表是 ZeroMQ。该作者非常睿智，他非常敏锐的意识到——MQ 是更高级的 Socket，它是解决通讯问题的。所以 ZeroMQ 被设计成了一个“库”而不是一个中间件，这种实现也可以达到——没有 Broker 的目的")]),t._v(" "),e("p",[e("img",{attrs:{src:"http://ww3.sinaimg.cn/large/006tNc79gy1g57vorta41j30ek01oq2p.jpg",alt:"img"}})]),t._v(" "),e("p",[t._v("节点之间通讯的消息都是发送到彼此的队列中，每个节点都既是生产者又是消费者。ZeroMQ 做的事情就是封装出一套类似于 Socket 的 API 可以完成发送数据，读取数据")]),t._v(" "),e("p",[t._v("ZeroMQ 其实就是一个跨语言的、重量级的 Actor 模型邮箱库。你可以把自己的程序想象成一个 Actor，ZeroMQ 就是提供邮箱功能的库；ZeroMQ 可以实现同一台机器的 RPC 通讯也可以实现不同机器的 TCP、UDP 通讯，如果你需要一个强大的、灵活、野蛮的通讯能力，别犹豫 ZeroMQ")]),t._v(" "),e("h2",{attrs:{id:"死信、延迟、重试队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#死信、延迟、重试队列","aria-hidden":"true"}},[t._v("#")]),t._v(" 死信、延迟、重试队列")]),t._v(" "),e("h3",{attrs:{id:"死信队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#死信队列","aria-hidden":"true"}},[t._v("#")]),t._v(" 死信队列")]),t._v(" "),e("p",[t._v("DLQ(Deal Letter Queue)，死信队列。当一个消息在队列中变成死信之后，他能被重新发送到 DLQ 中，与 DLQ 绑定到队列就是死信队列。")]),t._v(" "),e("h3",{attrs:{id:"什么情况下需要死信队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么情况下需要死信队列","aria-hidden":"true"}},[t._v("#")]),t._v(" 什么情况下需要死信队列")]),t._v(" "),e("ul",[e("li",[t._v("消息被拒绝")]),t._v(" "),e("li",[t._v("消息过期")]),t._v(" "),e("li",[t._v("队列达到最大长度")])]),t._v(" "),e("p",[e("img",{attrs:{src:"http://ww4.sinaimg.cn/large/006tNc79gy1g5a7fo9qp1j30oh07smxz.jpg",alt:"img"}})]),t._v(" "),e("p",[t._v("生产者生产一条消息，存储到普通队列中；设置队列的过期时间为 10 秒，在 10 秒内没有消费者消费消息，那么判定消息过期；此时如果设置了死信队列，过期消息被丢给死信队列交换机，然后被存储在死信队列中。")]),t._v(" "),e("h3",{attrs:{id:"延迟队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#延迟队列","aria-hidden":"true"}},[t._v("#")]),t._v(" 延迟队列")]),t._v(" "),e("p",[t._v("顾名思义就是延迟执行消息，比如我们可以增加一个队列并设置其超时时间为 10 秒并且不设置任何消费者，等到消息超时，我们可以将消息放入死信队列，让消费者监听这个死信队列就达到了延迟队列的效果。")]),t._v(" "),e("h3",{attrs:{id:"重试队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重试队列","aria-hidden":"true"}},[t._v("#")]),t._v(" 重试队列")]),t._v(" "),e("p",[t._v("重试的消息在延迟的某个时间点（业务可设置）后，再次投递给消费者。而如果一直这样重复消费都持续失败到一定次数，就会投递到死信队列，最后需要进行人工干预。")]),t._v(" "),e("h2",{attrs:{id:"为什么使用消息队列？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用消息队列？","aria-hidden":"true"}},[t._v("#")]),t._v(" 为什么使用消息队列？")]),t._v(" "),e("p",[t._v("消息队列常见的使用场景吧，其实场景有很多，但是比较核心的有 3 个：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("解耦")])]),t._v(" "),e("li",[e("strong",[t._v("异步")])]),t._v(" "),e("li",[e("strong",[t._v("削峰")])])]),t._v(" "),e("h3",{attrs:{id:"解耦"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解耦","aria-hidden":"true"}},[t._v("#")]),t._v(" 解耦")]),t._v(" "),e("p",[t._v("看这么个场景。A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃......")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://github.com/doocs/advanced-java/raw/master/images/mq-1.png",alt:"mq-1"}}),t._v("在这个场景中，A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。A 系统要时时刻刻考虑 BCDE 四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？头发都白了啊！")]),t._v(" "),e("p",[t._v("如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://github.com/doocs/advanced-java/raw/master/images/mq-2.png",alt:"mq-2"}}),t._v("异步")]),t._v(" "),e("p",[t._v("再来看一个场景，A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求，等待个 1s，这几乎是不可接受的。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://github.com/doocs/advanced-java/raw/master/images/mq-3.png",alt:"mq-3"}})]),t._v(" "),e("p",[t._v("一般互联网类的企业，对于用户直接的操作，一般要求是每个请求都必须在 200 ms 以内完成，对用户几乎是无感知的。")]),t._v(" "),e("p",[t._v("如果"),e("strong",[t._v("使用 MQ")]),t._v("，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms，对于用户而言，其实感觉上就是点个按钮，8ms 以后就直接返回了，爽！网站做得真好，真快！")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://github.com/doocs/advanced-java/raw/master/images/mq-4.png",alt:"mq-4"}})]),t._v(" "),e("h3",{attrs:{id:"削峰"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#削峰","aria-hidden":"true"}},[t._v("#")]),t._v(" 削峰")]),t._v(" "),e("p",[t._v("每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量就 50 个。结果每次一到 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统是直接基于 MySQL 的，大量的请求涌入 MySQL，每秒钟对 MySQL 执行约 5k 条 SQL。")]),t._v(" "),e("p",[t._v("一般的 MySQL，扛到每秒 2k 个请求就差不多了，如果每秒请求到 5k 的话，可能就直接把 MySQL 给打死了，导致系统崩溃，用户也就没法再使用系统了。")]),t._v(" "),e("p",[t._v("但是高峰期一过，到了下午的时候，就成了低峰期，可能也就 1w 的用户同时在网站上操作，每秒中的请求数量可能也就 50 个请求，对整个系统几乎没有任何的压力。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://github.com/doocs/advanced-java/raw/master/images/mq-5.png",alt:"mq-5"}})]),t._v(" "),e("p",[t._v("如果使用 MQ，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就 ok，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://github.com/doocs/advanced-java/raw/master/images/mq-6.png",alt:"mq-6"}}),t._v("]")]),t._v(" "),e("p",[t._v("这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。")]),t._v(" "),e("h3",{attrs:{id:"优缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优缺点","aria-hidden":"true"}},[t._v("#")]),t._v(" 优缺点")]),t._v(" "),e("p",[t._v("缺点有以下几个：")]),t._v(" "),e("ul",[e("li",[t._v("系统可用性降低\n系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，人 ABCD 四个系统好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整，MQ 一挂，整套系统崩溃的，你不就完了？如何保证消息队列的高可用，可以"),e("a",{attrs:{href:"https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("点击这里查看"),e("OutboundLink")],1),t._v("。")]),t._v(" "),e("li",[t._v("系统复杂度提高\n硬生生加个 MQ 进来，你怎么"),e("a",{attrs:{href:"https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-that-messages-are-not-repeatedly-consumed.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("保证消息没有重复消费"),e("OutboundLink")],1),t._v("？怎么"),e("a",{attrs:{href:"https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-the-reliable-transmission-of-messages.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("处理消息丢失的情况"),e("OutboundLink")],1),t._v("？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已。")]),t._v(" "),e("li",[t._v("一致性问题\nA 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。")])]),t._v(" "),e("h2",{attrs:{id:"常见mq产品"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见mq产品","aria-hidden":"true"}},[t._v("#")]),t._v(" 常见MQ产品")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("特性")]),t._v(" "),e("th",[t._v("ActiveMQ")]),t._v(" "),e("th",[t._v("RabbitMQ")]),t._v(" "),e("th",[t._v("RocketMQ")]),t._v(" "),e("th",[t._v("Kafka")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("单机吞吐量")]),t._v(" "),e("td",[t._v("万级，比 RocketMQ、Kafka 低一个数量级")]),t._v(" "),e("td",[t._v("同 ActiveMQ")]),t._v(" "),e("td",[t._v("10 万级，支撑高吞吐")]),t._v(" "),e("td",[t._v("10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景")])]),t._v(" "),e("tr",[e("td",[t._v("topic 数量对吞吐量的影响")]),t._v(" "),e("td"),t._v(" "),e("td"),t._v(" "),e("td",[t._v("topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic")]),t._v(" "),e("td",[t._v("topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源")])]),t._v(" "),e("tr",[e("td",[t._v("时效性")]),t._v(" "),e("td",[t._v("ms 级")]),t._v(" "),e("td",[t._v("微秒级，这是 RabbitMQ 的一大特点，延迟最低")]),t._v(" "),e("td",[t._v("ms 级")]),t._v(" "),e("td",[t._v("延迟在 ms 级以内")])]),t._v(" "),e("tr",[e("td",[t._v("可用性")]),t._v(" "),e("td",[t._v("高，基于主从架构实现高可用")]),t._v(" "),e("td",[t._v("同 ActiveMQ")]),t._v(" "),e("td",[t._v("非常高，分布式架构")]),t._v(" "),e("td",[t._v("非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用")])]),t._v(" "),e("tr",[e("td",[t._v("消息可靠性")]),t._v(" "),e("td",[t._v("有较低的概率丢失数据")]),t._v(" "),e("td",[t._v("基本不丢")]),t._v(" "),e("td",[t._v("经过参数优化配置，可以做到 0 丢失")]),t._v(" "),e("td",[t._v("同 RocketMQ")])]),t._v(" "),e("tr",[e("td",[t._v("功能支持")]),t._v(" "),e("td",[t._v("MQ 领域的功能极其完备")]),t._v(" "),e("td",[t._v("基于 erlang 开发，并发能力很强，性能极好，延时很低")]),t._v(" "),e("td",[t._v("MQ 功能较为完善，还是分布式的，扩展性好")]),t._v(" "),e("td",[t._v("功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用")])])])]),t._v(" "),e("p",[t._v("综上，各种对比之后，有如下建议：")]),t._v(" "),e("p",[t._v("一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；")]),t._v(" "),e("p",[t._v("后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；")]),t._v(" "),e("p",[t._v("不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 "),e("a",{attrs:{href:"https://github.com/apache/rocketmq",target:"_blank",rel:"noopener noreferrer"}},[t._v("Apache"),e("OutboundLink")],1),t._v("，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。")]),t._v(" "),e("p",[t._v("所以"),e("strong",[t._v("中小型公司")]),t._v("，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；"),e("strong",[t._v("大型公司")]),t._v("，基础架构研发实力较强，用 RocketMQ 是很好的选择。")]),t._v(" "),e("p",[t._v("如果是"),e("strong",[t._v("大数据领域")]),t._v("的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。")])])},[],!1,null,null,null);a.default=v.exports}}]);