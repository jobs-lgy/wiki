(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{212:function(v,_,a){"use strict";a.r(_);var l=a(0),i=Object(l.a)({},function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"jvm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm","aria-hidden":"true"}},[v._v("#")]),v._v(" JVM")]),v._v(" "),a("h2",{attrs:{id:"内存模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存模型","aria-hidden":"true"}},[v._v("#")]),v._v(" 内存模型")]),v._v(" "),a("p",[v._v("堆")]),v._v(" "),a("p",[v._v("栈")]),v._v(" "),a("p",[v._v("方法区")]),v._v(" "),a("p",[v._v("本地栈")]),v._v(" "),a("p",[v._v("程序计数器")]),v._v(" "),a("p",[v._v("元空间")]),v._v(" "),a("p",[v._v("直接内存/堆外内存")]),v._v(" "),a("p",[v._v("Java中的字符串：")]),v._v(" "),a("p",[a("img",{attrs:{src:"http://ww1.sinaimg.cn/large/006tNc79gy1g63vhn7cjxj31eu0oy1b7.jpg",alt:"image-20190818154048232"}})]),v._v(" "),a("h2",{attrs:{id:"垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收","aria-hidden":"true"}},[v._v("#")]),v._v(" 垃圾回收")]),v._v(" "),a("p",[v._v("新生代：Serial、ParNew、Parallel Scavenge")]),v._v(" "),a("p",[v._v("老年代：Serial Old、Parallel Old、CMS")]),v._v(" "),a("p",[v._v("G1")]),v._v(" "),a("p",[v._v("直接内存/堆外内存")]),v._v(" "),a("h2",{attrs:{id:"监控调优"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#监控调优","aria-hidden":"true"}},[v._v("#")]),v._v(" 监控调优")]),v._v(" "),a("p",[v._v("命令：")]),v._v(" "),a("p",[v._v("工具：")]),v._v(" "),a("ul",[a("li",[v._v("JVM运行时内存区域划分")]),v._v(" "),a("li",[v._v("为什么JVM调优经常会将-Xms和-Xmx参数设置成一样；")]),v._v(" "),a("li",[v._v("内存溢出OOM和堆栈溢出SOE的示例及原因、如何排查与解决")]),v._v(" "),a("li",[v._v("如何判断对象是否可以回收或存活")]),v._v(" "),a("li",[v._v("常见的GC回收算法及其含义")]),v._v(" "),a("li",[v._v("常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等")]),v._v(" "),a("li",[v._v("JVM如何设置参数")]),v._v(" "),a("li",[v._v("JVM性能调优")]),v._v(" "),a("li",[v._v("类加载器、双亲委派模型、一个类的生命周期、类是如何加载到JVM中的")]),v._v(" "),a("li",[v._v("类加载的过程：加载、验证、准备、解析、初始化")]),v._v(" "),a("li",[v._v("强引用、软引用、弱引用、虚引用")]),v._v(" "),a("li",[v._v("Java内存模型JMM")]),v._v(" "),a("li",[v._v("Minor GC与Full GC分别在什么时候发生？什么时候触发Full GC;")]),v._v(" "),a("li",[v._v("GC收集器有哪些？CMS收集器与G1收集器的特点。")]),v._v(" "),a("li",[v._v("Java在什么时候会出现内存泄漏；")]),v._v(" "),a("li",[v._v("Java中的大对象如何进行存储；")]),v._v(" "),a("li",[v._v("rt.jar被什么类加载器加载，什么时间加载；")]),v._v(" "),a("li",[v._v("自己写的类被什么加载，什么时间加载；")]),v._v(" "),a("li",[v._v("自己写的两个不同的类是被同一个类加载器加载的吗？为什么？")]),v._v(" "),a("li",[v._v("为什么新生代内存需要有两个Survivor区？")]),v._v(" "),a("li",[v._v("几种常用的内存调试工具：jmap、jstack、jconsole；")]),v._v(" "),a("li",[v._v("类加载的五个过程：加载、验证、准备、解析、初始化；")]),v._v(" "),a("li",[v._v("G1停顿吗，CMS回收步骤，CMS为什么会停顿，停顿时间；")]),v._v(" "),a("li",[v._v("栈主要存的数据是什么，堆呢？")]),v._v(" "),a("li",[v._v("堆分为哪几块，比如说新生代老生代，那么新生代又分为什么？")]),v._v(" "),a("li",[v._v("软引用和弱引用的使用场景（软引用可以实现缓存，弱引用可以用来在回调函数中防止内存泄露）；")]),v._v(" "),a("li",[v._v("引用计数法与GC Root可达性分析法区别；")]),v._v(" "),a("li",[v._v("JMM里边的原子性、可见性、有序性是如何体现出来的，JMM中内存屏障是什么意思，")]),v._v(" "),a("li",[v._v("Java内存模型，方法区存什么；")]),v._v(" "),a("li",[v._v("CMS垃圾回收过程；")]),v._v(" "),a("li",[v._v("Full GC次数太多了，如何优化；")]),v._v(" "),a("li",[v._v("直接内存如何管理的；")])])])},[],!1,null,null,null);_.default=i.exports}}]);