(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{198:function(t,a,s){"use strict";s.r(a);var e=s(0),n=Object(e.a)({},function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"docker-网络"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker-网络","aria-hidden":"true"}},[t._v("#")]),t._v(" Docker 网络")]),t._v(" "),s("p",[t._v("Docker 允许通过外部访问容器或容器互联的方式来提供网络服务")]),t._v(" "),s("h2",{attrs:{id:"docker-外部访问容器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker-外部访问容器","aria-hidden":"true"}},[t._v("#")]),t._v(" Docker 外部访问容器")]),t._v(" "),s("p",[t._v("容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 "),s("code",[t._v("-P")]),t._v(" 或 "),s("code",[t._v("-p")]),t._v(" 参数来指定端口映射。")]),t._v(" "),s("p",[t._v("当使用 "),s("code",[t._v("-P")]),t._v(" 标记时，Docker 会随机映射一个 "),s("code",[t._v("49000~49900")]),t._v(" 的端口到内部容器开放的网络端口。")]),t._v(" "),s("p",[t._v("使用 "),s("code",[t._v("docker container ls")]),t._v(" 可以看到，本地主机的 49155 被映射到了容器的 5000 端口。此时访问本机的 49155 端口即可访问容器内 web 应用提供的界面。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ docker run -d -P training/webapp python app.py\n\n$ docker container "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ls")]),t._v(" -l\nCONTAINER ID  IMAGE                   COMMAND       CREATED        STATUS        PORTS                    NAMES\nbc533791f3f5  training/webapp:latest  python app.py 5 seconds ago  Up 2 seconds  0.0.0.0:49155-"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("5000/tcp  nostalgic_morse\n")])])]),s("p",[t._v("同样的，可以通过 "),s("code",[t._v("docker logs")]),t._v(" 命令来查看应用的信息。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ docker logs -f nostalgic_morse\n* Running on http://0.0.0.0:5000/\n10.0.2.2 - - "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("23/May/2014 20:16:31"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"GET / HTTP/1.1"')]),t._v(" 200 -\n10.0.2.2 - - "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("23/May/2014 20:16:31"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"GET /favicon.ico HTTP/1.1"')]),t._v(" 404 -\n")])])]),s("p",[s("code",[t._v("-p")]),t._v(" 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 "),s("code",[t._v("ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"映射所有接口地址"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#映射所有接口地址","aria-hidden":"true"}},[t._v("#")]),t._v(" 映射所有接口地址")]),t._v(" "),s("p",[t._v("使用 "),s("code",[t._v("hostPort:containerPort")]),t._v(" 格式本地的 5000 端口映射到容器的 5000 端口，可以执行")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ docker run -d -p 5000:5000 training/webapp python app.py\n")])])]),s("p",[t._v("此时默认会绑定本地所有接口上的所有地址。")]),t._v(" "),s("h3",{attrs:{id:"映射到指定地址的指定端口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#映射到指定地址的指定端口","aria-hidden":"true"}},[t._v("#")]),t._v(" 映射到指定地址的指定端口")]),t._v(" "),s("p",[t._v("可以使用 "),s("code",[t._v("ip:hostPort:containerPort")]),t._v(" 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py\n")])])]),s("h3",{attrs:{id:"映射到指定地址的任意端口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#映射到指定地址的任意端口","aria-hidden":"true"}},[t._v("#")]),t._v(" 映射到指定地址的任意端口")]),t._v(" "),s("p",[t._v("使用 "),s("code",[t._v("ip::containerPort")]),t._v(" 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ docker run -d -p 127.0.0.1::5000 training/webapp python app.py\n")])])]),s("p",[t._v("还可以使用 "),s("code",[t._v("udp")]),t._v(" 标记来指定 "),s("code",[t._v("udp")]),t._v(" 端口")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py\n")])])]),s("h3",{attrs:{id:"查看映射端口配置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#查看映射端口配置","aria-hidden":"true"}},[t._v("#")]),t._v(" 查看映射端口配置")]),t._v(" "),s("p",[t._v("使用 "),s("code",[t._v("docker port")]),t._v(" 来查看当前映射的端口配置，也可以查看到绑定的地址")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ docker port nostalgic_morse 5000\n127.0.0.1:49155.\n")])])]),s("p",[t._v("注意：")]),t._v(" "),s("ul",[s("li",[t._v("容器有自己的内部网络和 ip 地址（使用 "),s("code",[t._v("docker inspect")]),t._v(" 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）")]),t._v(" "),s("li",[s("code",[t._v("-p")]),t._v(" 标记可以多次使用来绑定多个端口")])]),t._v(" "),s("p",[t._v("例如")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ docker run -d \\\n    -p 5000:5000 \\\n    -p 3000:80 \\\n    training/webapp \\\n    python app.py\n")])])]),s("h2",{attrs:{id:"docker-容器互联"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker-容器互联","aria-hidden":"true"}},[t._v("#")]),t._v(" Docker 容器互联")]),t._v(" "),s("p",[t._v("如果你之前有 "),s("code",[t._v("Docker")]),t._v(" 使用经验，你可能已经习惯了使用 "),s("code",[t._v("--link")]),t._v(" 参数来使容器互联。")]),t._v(" "),s("p",[t._v("随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 "),s("code",[t._v("--link")]),t._v(" 参数。")]),t._v(" "),s("h3",{attrs:{id:"新建网络"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#新建网络","aria-hidden":"true"}},[t._v("#")]),t._v(" 新建网络")]),t._v(" "),s("p",[t._v("下面先创建一个新的 Docker 网络。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ docker network create -d bridge my-net\n")])])]),s("p",[s("code",[t._v("-d")]),t._v(" 参数指定 Docker 网络类型，有 "),s("code",[t._v("bridge")]),t._v(" "),s("code",[t._v("overlay")]),t._v("。其中 "),s("code",[t._v("overlay")]),t._v(" 网络类型用于 "),s("code",[t._v("Swarm mode")]),t._v("，在本小节中你可以忽略它。")]),t._v(" "),s("h3",{attrs:{id:"连接容器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#连接容器","aria-hidden":"true"}},[t._v("#")]),t._v(" 连接容器")]),t._v(" "),s("p",[t._v("运行一个容器并连接到新建的 "),s("code",[t._v("my-net")]),t._v(" 网络")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ docker run -it --rm --name busybox1 --network my-net busybox sh\n")])])]),s("p",[t._v("打开新的终端，再运行一个容器并加入到 "),s("code",[t._v("my-net")]),t._v(" 网络")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ docker run -it --rm --name busybox2 --network my-net busybox sh\n")])])]),s("p",[t._v("再打开一个新的终端查看容器信息")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ docker container "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ls")]),t._v("\n\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\nb47060aca56b        busybox             "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"sh"')]),t._v("                11 minutes ago      Up 11 minutes                           busybox2\n8720575823ec        busybox             "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"sh"')]),t._v("                16 minutes ago      Up 16 minutes                           busybox1\n")])])]),s("p",[t._v("下面通过 "),s("code",[t._v("ping")]),t._v(" 来证明 "),s("code",[t._v("busybox1")]),t._v(" 容器和 "),s("code",[t._v("busybox2")]),t._v(" 容器建立了互联关系。")]),t._v(" "),s("p",[t._v("在 "),s("code",[t._v("busybox1")]),t._v(" 容器输入以下命令")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("/ "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# ping busybox2")]),t._v("\nPING busybox2 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("172.19.0.3"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(": 56 data bytes\n64 bytes from 172.19.0.3: seq"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("0 ttl"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("64 time"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("0.072 ms\n64 bytes from 172.19.0.3: seq"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("1 ttl"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("64 time"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("0.118 ms\n")])])]),s("p",[t._v("用 ping 来测试连接 "),s("code",[t._v("busybox2")]),t._v(" 容器，它会解析成 "),s("code",[t._v("172.19.0.3")]),t._v("。")]),t._v(" "),s("p",[t._v("同理在 "),s("code",[t._v("busybox2")]),t._v(" 容器执行 "),s("code",[t._v("ping busybox1")]),t._v("，也会成功连接到。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("/ "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# ping busybox1")]),t._v("\nPING busybox1 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("172.19.0.2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(": 56 data bytes\n64 bytes from 172.19.0.2: seq"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("0 ttl"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("64 time"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("0.064 ms\n64 bytes from 172.19.0.2: seq"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("1 ttl"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("64 time"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("0.143 ms\n")])])]),s("p",[t._v("这样，"),s("code",[t._v("busybox1")]),t._v(" 容器和 "),s("code",[t._v("busybox2")]),t._v(" 容器建立了互联关系。")]),t._v(" "),s("h3",{attrs:{id:"docker-compose"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker-compose","aria-hidden":"true"}},[t._v("#")]),t._v(" Docker Compose")]),t._v(" "),s("p",[t._v("如果你有多个容器之间需要互相连接，推荐使用 "),s("code",[t._v("Docker Compose")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"docker-配置-dns"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker-配置-dns","aria-hidden":"true"}},[t._v("#")]),t._v(" Docker 配置 DNS")]),t._v(" "),s("p",[t._v("如何自定义配置容器的主机名和 DNS 呢？秘诀就是 Docker 利用虚拟文件来挂载容器的 3 个相关配置文件。")]),t._v(" "),s("p",[t._v("在容器中使用 "),s("code",[t._v("mount")]),t._v(" 命令可以看到挂载信息：")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("mount")]),t._v("\n/dev/disk/by-uuid/1fec"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".ebdf on /etc/hostname "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("type")]),t._v(" ext4 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\n/dev/disk/by-uuid/1fec"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".ebdf on /etc/hosts "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("type")]),t._v(" ext4 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\ntmpfs on /etc/resolv.conf "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("type")]),t._v(" tmpfs "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\n")])])]),s("p",[t._v("这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 "),s("code",[t._v("/etc/resolv.conf")]),t._v(" 文件立刻得到更新。")]),t._v(" "),s("p",[t._v("配置全部容器的 DNS ，也可以在 "),s("code",[t._v("/etc/docker/daemon.json")]),t._v(" 文件中增加以下内容来设置。")]),t._v(" "),s("div",{staticClass:"language-json extra-class"},[s("pre",{pre:!0,attrs:{class:"language-json"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"dns"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"114.114.114.114"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"8.8.8.8"')]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("这样每次启动的容器 DNS 自动配置为 "),s("code",[t._v("114.114.114.114")]),t._v(" 和 "),s("code",[t._v("8.8.8.8")]),t._v("。使用以下命令来证明其已经生效。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ docker run -it --rm ubuntu:17.10  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("cat")]),t._v(" etc/resolv.conf\n\nnameserver 114.114.114.114\nnameserver 8.8.8.8\n")])])]),s("p",[t._v("如果用户想要手动指定容器的配置，可以在使用 "),s("code",[t._v("docker run")]),t._v(" 命令启动容器时加入如下参数：")]),t._v(" "),s("p",[s("code",[t._v("-h HOSTNAME")]),t._v(" 或者 "),s("code",[t._v("--hostname=HOSTNAME")]),t._v(" 设定容器的主机名，它会被写到容器内的 "),s("code",[t._v("/etc/hostname")]),t._v("和 "),s("code",[t._v("/etc/hosts")]),t._v("。但它在容器外部看不到，既不会在 "),s("code",[t._v("docker container ls")]),t._v(" 中显示，也不会在其他的容器的 "),s("code",[t._v("/etc/hosts")]),t._v(" 看到。")]),t._v(" "),s("p",[s("code",[t._v("--dns=IP_ADDRESS")]),t._v(" 添加 DNS 服务器到容器的 "),s("code",[t._v("/etc/resolv.conf")]),t._v(" 中，让容器用这个服务器来解析所有不在 "),s("code",[t._v("/etc/hosts")]),t._v(" 中的主机名。")]),t._v(" "),s("p",[s("code",[t._v("--dns-search=DOMAIN")]),t._v(" 设定容器的搜索域，当设定搜索域为 "),s("code",[t._v(".example.com")]),t._v(" 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 "),s("code",[t._v("host.example.com")]),t._v("。")]),t._v(" "),s("blockquote",[s("p",[t._v("注意：如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的 "),s("code",[t._v("/etc/resolv.conf")]),t._v(" 来配置容器。")])]),t._v(" "),s("h2",{attrs:{id:"docker-高级网络配置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker-高级网络配置","aria-hidden":"true"}},[t._v("#")]),t._v(" Docker 高级网络配置")]),t._v(" "),s("blockquote",[s("p",[t._v("注意：本章属于 "),s("code",[t._v("Docker")]),t._v(" 高级配置，如果您是初学者，您可以暂时跳过本章节，直接学习 "),s("code",[t._v("Docker Compose")]),t._v(" 一节。")])]),t._v(" "),s("p",[t._v("本章将介绍 Docker 的一些高级网络配置和选项。")]),t._v(" "),s("p",[t._v("当 Docker 启动时，会自动在主机上创建一个 "),s("code",[t._v("docker0")]),t._v(" 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。")]),t._v(" "),s("p",[t._v("同时，Docker 随机分配一个本地未占用的私有网段（在 "),s("a",{attrs:{href:"http://tools.ietf.org/html/rfc1918",target:"_blank",rel:"noopener noreferrer"}},[t._v("RFC1918"),s("OutboundLink")],1),t._v(" 中定义）中的一个地址给 "),s("code",[t._v("docker0")]),t._v("接口。比如典型的 "),s("code",[t._v("172.17.42.1")]),t._v("，掩码为 "),s("code",[t._v("255.255.0.0")]),t._v("。此后启动的容器内的网口也会自动分配一个同一网段（"),s("code",[t._v("172.17.0.0/16")]),t._v("）的地址。")]),t._v(" "),s("p",[t._v("当创建一个 Docker 容器的时候，同时会创建了一对 "),s("code",[t._v("veth pair")]),t._v(" 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 "),s("code",[t._v("eth0")]),t._v("；另一端在本地并被挂载到 "),s("code",[t._v("docker0")]),t._v(" 网桥，名称以 "),s("code",[t._v("veth")]),t._v(" 开头（例如 "),s("code",[t._v("vethAQI2QT")]),t._v("）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。")]),t._v(" "),s("p",[s("img",{attrs:{src:"http://ww3.sinaimg.cn/large/006tNc79gy1g59y3hsl2lj31b20u0gmn.jpg",alt:"Docker 网络"}})]),t._v(" "),s("p",[t._v("接下来的部分将介绍在一些场景中，Docker 所有的网络定制配置。以及通过 Linux 命令来调整、补充、甚至替换 Docker 默认的网络配置。")]),t._v(" "),s("h3",{attrs:{id:"docker-快速配置指南"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker-快速配置指南","aria-hidden":"true"}},[t._v("#")]),t._v(" Docker 快速配置指南")]),t._v(" "),s("p",[t._v("下面是一个跟 Docker 网络相关的命令列表。")]),t._v(" "),s("p",[t._v("其中有些命令选项只有在 Docker 服务启动的时候才能配置，而且不能马上生效。")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("-b BRIDGE")]),t._v(" 或 "),s("code",[t._v("--bridge=BRIDGE")]),t._v(" 指定容器挂载的网桥")]),t._v(" "),s("li",[s("code",[t._v("--bip=CIDR")]),t._v(" 定制 docker0 的掩码")]),t._v(" "),s("li",[s("code",[t._v("-H SOCKET...")]),t._v(" 或 "),s("code",[t._v("--host=SOCKET...")]),t._v(" Docker 服务端接收命令的通道")]),t._v(" "),s("li",[s("code",[t._v("--icc=true|false")]),t._v(" 是否支持容器之间进行通信")]),t._v(" "),s("li",[s("code",[t._v("--ip-forward=true|false")]),t._v(" 请看下文容器之间的通信")]),t._v(" "),s("li",[s("code",[t._v("--iptables=true|false")]),t._v(" 是否允许 Docker 添加 iptables 规则")]),t._v(" "),s("li",[s("code",[t._v("--mtu=BYTES")]),t._v(" 容器网络中的 MTU")])]),t._v(" "),s("p",[t._v("下面2个命令选项既可以在启动服务时指定，也可以在启动容器时指定。在 Docker 服务启动的时候指定则会成为默认值，后面执行 "),s("code",[t._v("docker run")]),t._v(" 时可以覆盖设置的默认值。")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("--dns=IP_ADDRESS...")]),t._v(" 使用指定的DNS服务器")]),t._v(" "),s("li",[s("code",[t._v("--dns-search=DOMAIN...")]),t._v(" 指定DNS搜索域")])]),t._v(" "),s("p",[t._v("最后这些选项只有在 "),s("code",[t._v("docker run")]),t._v(" 执行时使用，因为它是针对容器的特性内容。")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("-h HOSTNAME")]),t._v(" 或 "),s("code",[t._v("--hostname=HOSTNAME")]),t._v(" 配置容器主机名")]),t._v(" "),s("li",[s("code",[t._v("--link=CONTAINER_NAME:ALIAS")]),t._v(" 添加到另一个容器的连接")]),t._v(" "),s("li",[s("code",[t._v("--net=bridge|none|container:NAME_or_ID|host")]),t._v(" 配置容器的桥接模式")]),t._v(" "),s("li",[s("code",[t._v("-p SPEC")]),t._v(" 或 "),s("code",[t._v("--publish=SPEC")]),t._v(" 映射容器端口到宿主主机")]),t._v(" "),s("li",[s("code",[t._v("-P or --publish-all=true|false")]),t._v(" 映射容器所有端口到宿主主机")])]),t._v(" "),s("h3",{attrs:{id:"docker-容器访问控制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker-容器访问控制","aria-hidden":"true"}},[t._v("#")]),t._v(" Docker 容器访问控制")]),t._v(" "),s("p",[t._v("容器的访问控制，主要通过 Linux 上的 "),s("code",[t._v("iptables")]),t._v(" 防火墙来进行管理和实现。"),s("code",[t._v("iptables")]),t._v(" 是 Linux 上默认的防火墙软件，在大部分发行版中都自带。")]),t._v(" "),s("h4",{attrs:{id:"容器访问外部网络"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#容器访问外部网络","aria-hidden":"true"}},[t._v("#")]),t._v(" 容器访问外部网络")]),t._v(" "),s("p",[t._v("容器要想访问外部网络，需要本地系统的转发支持。在Linux 系统中，检查转发是否打开。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$sysctl")]),t._v(" net.ipv4.ip_forward\nnet.ipv4.ip_forward "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" 1\n")])])]),s("p",[t._v("如果为 0，说明没有开启转发，则需要手动打开。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$sysctl")]),t._v(" -w net.ipv4.ip_forward"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("1\n")])])]),s("p",[t._v("如果在启动 Docker 服务的时候设定 "),s("code",[t._v("--ip-forward=true")]),t._v(", Docker 就会自动设定系统的 "),s("code",[t._v("ip_forward")]),t._v("参数为 1。")]),t._v(" "),s("h4",{attrs:{id:"容器之间访问"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#容器之间访问","aria-hidden":"true"}},[t._v("#")]),t._v(" 容器之间访问")]),t._v(" "),s("p",[t._v("容器之间相互访问，需要两方面的支持。")]),t._v(" "),s("ul",[s("li",[t._v("容器的网络拓扑是否已经互联。默认情况下，所有容器都会被连接到 "),s("code",[t._v("docker0")]),t._v(" 网桥上。")]),t._v(" "),s("li",[t._v("本地系统的防火墙软件 -- "),s("code",[t._v("iptables")]),t._v(" 是否允许通过。")])]),t._v(" "),s("h4",{attrs:{id:"访问所有端口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#访问所有端口","aria-hidden":"true"}},[t._v("#")]),t._v(" 访问所有端口")]),t._v(" "),s("p",[t._v("当启动 Docker 服务时候，默认会添加一条转发策略到 iptables 的 FORWARD 链上。策略为通过（"),s("code",[t._v("ACCEPT")]),t._v("）还是禁止（"),s("code",[t._v("DROP")]),t._v("）取决于配置"),s("code",[t._v("--icc=true")]),t._v("（缺省值）还是 "),s("code",[t._v("--icc=false")]),t._v("。当然，如果手动指定 "),s("code",[t._v("--iptables=false")]),t._v(" 则不会添加 "),s("code",[t._v("iptables")]),t._v(" 规则。")]),t._v(" "),s("p",[t._v("可见，默认情况下，不同容器之间是允许网络互通的。如果为了安全考虑，可以在 "),s("code",[t._v("/etc/default/docker")]),t._v(" 文件中配置 "),s("code",[t._v("DOCKER_OPTS=--icc=false")]),t._v(" 来禁止它。")]),t._v(" "),s("h4",{attrs:{id:"访问指定端口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#访问指定端口","aria-hidden":"true"}},[t._v("#")]),t._v(" 访问指定端口")]),t._v(" "),s("p",[t._v("在通过 "),s("code",[t._v("-icc=false")]),t._v(" 关闭网络访问后，还可以通过 "),s("code",[t._v("--link=CONTAINER_NAME:ALIAS")]),t._v(" 选项来访问容器的开放端口。")]),t._v(" "),s("p",[t._v("例如，在启动 Docker 服务时，可以同时使用 "),s("code",[t._v("icc=false --iptables=true")]),t._v(" 参数来关闭允许相互的网络访问，并让 Docker 可以修改系统中的 "),s("code",[t._v("iptables")]),t._v(" 规则。")]),t._v(" "),s("p",[t._v("此时，系统中的 "),s("code",[t._v("iptables")]),t._v(" 规则可能是类似")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" iptables -nL\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\nChain FORWARD "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("policy ACCEPT"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\ntarget     prot opt "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("source")]),t._v("               destination\nDROP       all  --  0.0.0.0/0            0.0.0.0/0\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\n")])])]),s("p",[t._v("之后，启动容器（"),s("code",[t._v("docker run")]),t._v("）时使用 "),s("code",[t._v("--link=CONTAINER_NAME:ALIAS")]),t._v(" 选项。Docker 会在 "),s("code",[t._v("iptable")]),t._v(" 中为 两个容器分别添加一条 "),s("code",[t._v("ACCEPT")]),t._v(" 规则，允许相互访问开放的端口（取决于 "),s("code",[t._v("Dockerfile")]),t._v("中的 "),s("code",[t._v("EXPOSE")]),t._v(" 指令）。")]),t._v(" "),s("p",[t._v("当添加了 "),s("code",[t._v("--link=CONTAINER_NAME:ALIAS")]),t._v(" 选项后，添加了 "),s("code",[t._v("iptables")]),t._v(" 规则。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" iptables -nL\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\nChain FORWARD "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("policy ACCEPT"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\ntarget     prot opt "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("source")]),t._v("               destination\nACCEPT     tcp  --  172.17.0.2           172.17.0.3           tcp spt:80\nACCEPT     tcp  --  172.17.0.3           172.17.0.2           tcp dpt:80\nDROP       all  --  0.0.0.0/0            0.0.0.0/0\n")])])]),s("p",[t._v("注意："),s("code",[t._v("--link=CONTAINER_NAME:ALIAS")]),t._v(" 中的 "),s("code",[t._v("CONTAINER_NAME")]),t._v(" 目前必须是 Docker 分配的名字，或使用 "),s("code",[t._v("--name")]),t._v(" 参数指定的名字。主机名则不会被识别。")]),t._v(" "),s("h3",{attrs:{id:"docker-端口映射实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker-端口映射实现","aria-hidden":"true"}},[t._v("#")]),t._v(" Docker 端口映射实现")]),t._v(" "),s("p",[t._v("默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器。")]),t._v(" "),s("h4",{attrs:{id:"容器访问外部实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#容器访问外部实现","aria-hidden":"true"}},[t._v("#")]),t._v(" 容器访问外部实现")]),t._v(" "),s("p",[t._v("容器所有到外部网络的连接，源地址都会被 NAT 成本地系统的 IP 地址。这是使用 "),s("code",[t._v("iptables")]),t._v(" 的源地址伪装操作实现的。")]),t._v(" "),s("p",[t._v("查看主机的 NAT 规则。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" iptables -t nat -nL\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\nChain POSTROUTING "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("policy ACCEPT"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\ntarget     prot opt "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("source")]),t._v("               destination\nMASQUERADE  all  --  172.17.0.0/16       "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("172.17.0.0/16\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\n")])])]),s("p",[t._v("其中，上述规则将所有源地址在 "),s("code",[t._v("172.17.0.0/16")]),t._v(" 网段，目标地址为其他网段（外部网络）的流量动态伪装为从系统网卡发出。MASQUERADE 跟传统 SNAT 的好处是它能动态从网卡获取地址。")]),t._v(" "),s("h4",{attrs:{id:"外部访问容器实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#外部访问容器实现","aria-hidden":"true"}},[t._v("#")]),t._v(" 外部访问容器实现")]),t._v(" "),s("p",[t._v("容器允许外部访问，可以在 "),s("code",[t._v("docker run")]),t._v(" 时候通过 "),s("code",[t._v("-p")]),t._v(" 或 "),s("code",[t._v("-P")]),t._v(" 参数来启用。")]),t._v(" "),s("p",[t._v("不管用那种办法，其实也是在本地的 "),s("code",[t._v("iptable")]),t._v(" 的 nat 表中添加相应的规则。")]),t._v(" "),s("p",[t._v("使用 "),s("code",[t._v("-P")]),t._v(" 时：")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ iptables -t nat -nL\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\nChain DOCKER "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("2 references"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\ntarget     prot opt "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("source")]),t._v("               destination\nDNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:49153 to:172.17.0.2:80\n")])])]),s("p",[t._v("使用 "),s("code",[t._v("-p 80:80")]),t._v(" 时：")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ iptables -t nat -nL\nChain DOCKER "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("2 references"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\ntarget     prot opt "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("source")]),t._v("               destination\nDNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:172.17.0.2:80\n")])])]),s("p",[t._v("注意：")]),t._v(" "),s("ul",[s("li",[t._v("这里的规则映射了 "),s("code",[t._v("0.0.0.0")]),t._v("，意味着将接受主机来自所有接口的流量。用户可以通过 "),s("code",[t._v("-p IP:host_port:container_port")]),t._v(" 或 "),s("code",[t._v("-p IP::port")]),t._v(" 来指定允许访问容器的主机上的 IP、接口等，以制定更严格的规则。")]),t._v(" "),s("li",[t._v("如果希望永久绑定到某个固定的 IP 地址，可以在 Docker 配置文件 "),s("code",[t._v("/etc/docker/daemon.json")]),t._v(" 中添加如下内容。")])]),t._v(" "),s("div",{staticClass:"language-json extra-class"},[s("pre",{pre:!0,attrs:{class:"language-json"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"ip"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0.0.0.0"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"配置-docker0-网桥"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#配置-docker0-网桥","aria-hidden":"true"}},[t._v("#")]),t._v(" 配置 docker0 网桥")]),t._v(" "),s("p",[t._v("Docker 服务默认会创建一个 "),s("code",[t._v("docker0")]),t._v(" 网桥（其上有一个 "),s("code",[t._v("docker0")]),t._v(" 内部接口），它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。")]),t._v(" "),s("p",[t._v("Docker 默认指定了 "),s("code",[t._v("docker0")]),t._v(" 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信，它还给出了 MTU（接口允许接收的最大传输单元），通常是 1500 Bytes，或宿主主机网络路由上支持的默认值。这些值都可以在服务启动的时候进行配置。")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("--bip=CIDR")]),t._v(" IP 地址加掩码格式，例如 192.168.1.5/24")]),t._v(" "),s("li",[s("code",[t._v("--mtu=BYTES")]),t._v(" 覆盖默认的 Docker mtu 配置")])]),t._v(" "),s("p",[t._v("也可以在配置文件中配置 DOCKER_OPTS，然后重启服务。")]),t._v(" "),s("p",[t._v("由于目前 Docker 网桥是 Linux 网桥，用户可以使用 "),s("code",[t._v("brctl show")]),t._v(" 来查看网桥和端口连接信息。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" brctl show\nbridge name     bridge "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("id")]),t._v("               STP enabled     interfaces\ndocker0         8000.3a1d7362b4ee       no              veth65f9\n                                             vethdda6\n")])])]),s("p",[t._v("*注："),s("code",[t._v("brctl")]),t._v(" 命令在 Debian、Ubuntu 中可以使用 "),s("code",[t._v("sudo apt-get install bridge-utils")]),t._v(" 来安装。")]),t._v(" "),s("p",[t._v("每次创建一个新容器的时候，Docker 从可用的地址段中选择一个空闲的 IP 地址分配给容器的 eth0 端口。使用本地主机上 "),s("code",[t._v("docker0")]),t._v(" 接口的 IP 作为所有容器的默认网关。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" docker run -i -t --rm base /bin/bash\n$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ip")]),t._v(" addr show eth0\n24: eth0: "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("BROADCAST,UP,LOWER_UP"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\n    link/ether 32:6f:e0:35:57:91 brd ff:ff:ff:ff:ff:ff\n    inet 172.17.0.3/16 scope global eth0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::306f:e0ff:fe35:5791/64 scope "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("link")]),t._v("\n       valid_lft forever preferred_lft forever\n$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ip")]),t._v(" route\ndefault via 172.17.42.1 dev eth0\n172.17.0.0/16 dev eth0  proto kernel  scope "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("link")]),t._v("  src 172.17.0.3\n")])])]),s("h3",{attrs:{id:"docker-自定义网桥"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker-自定义网桥","aria-hidden":"true"}},[t._v("#")]),t._v(" Docker 自定义网桥")]),t._v(" "),s("p",[t._v("除了默认的 "),s("code",[t._v("docker0")]),t._v(" 网桥，用户也可以指定网桥来连接各个容器。")]),t._v(" "),s("p",[t._v("在启动 Docker 服务的时候，使用 "),s("code",[t._v("-b BRIDGE")]),t._v("或"),s("code",[t._v("--bridge=BRIDGE")]),t._v(" 来指定使用的网桥。")]),t._v(" "),s("p",[t._v("如果服务已经运行，那需要先停止服务，并删除旧的网桥。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" systemctl stop docker\n$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ip")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("link")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" dev docker0 down\n$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" brctl delbr docker0\n")])])]),s("p",[t._v("然后创建一个网桥 "),s("code",[t._v("bridge0")]),t._v("。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" brctl addbr bridge0\n$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ip")]),t._v(" addr "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),t._v(" 192.168.5.1/24 dev bridge0\n$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ip")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("link")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" dev bridge0 up\n")])])]),s("p",[t._v("查看确认网桥创建并启动。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ip")]),t._v(" addr show bridge0\n4: bridge0: "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("BROADCAST,MULTICAST"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" mtu 1500 qdisc noop state UP group default\n    link/ether 66:38:d0:0d:76:18 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.5.1/24 scope global bridge0\n       valid_lft forever preferred_lft forever\n")])])]),s("p",[t._v("在 Docker 配置文件 "),s("code",[t._v("/etc/docker/daemon.json")]),t._v(" 中添加如下内容，即可将 Docker 默认桥接到创建的网桥上。")]),t._v(" "),s("div",{staticClass:"language-json extra-class"},[s("pre",{pre:!0,attrs:{class:"language-json"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"bridge"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"bridge0"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("启动 Docker 服务。")]),t._v(" "),s("p",[t._v("新建一个容器，可以看到它已经桥接到了 "),s("code",[t._v("bridge0")]),t._v(" 上。")]),t._v(" "),s("p",[t._v("可以继续用 "),s("code",[t._v("brctl show")]),t._v(" 命令查看桥接的信息。另外，在容器中可以使用 "),s("code",[t._v("ip addr")]),t._v(" 和 "),s("code",[t._v("ip route")]),t._v(" 命令来查看 IP 地址配置和路由信息。")]),t._v(" "),s("h3",{attrs:{id:"docker-工具和示例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker-工具和示例","aria-hidden":"true"}},[t._v("#")]),t._v(" Docker 工具和示例")]),t._v(" "),s("p",[t._v("在介绍自定义网络拓扑之前，你可能会对一些外部工具和例子感兴趣：")]),t._v(" "),s("h4",{attrs:{id:"pipework"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pipework","aria-hidden":"true"}},[t._v("#")]),t._v(" pipework")]),t._v(" "),s("p",[t._v("Jérôme Petazzoni 编写了一个叫 "),s("a",{attrs:{href:"https://github.com/jpetazzo/pipework",target:"_blank",rel:"noopener noreferrer"}},[t._v("pipework"),s("OutboundLink")],1),t._v(" 的 shell 脚本，可以帮助用户在比较复杂的场景中完成容器的连接。")]),t._v(" "),s("h4",{attrs:{id:"playground"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#playground","aria-hidden":"true"}},[t._v("#")]),t._v(" playground")]),t._v(" "),s("p",[t._v("Brandon Rhodes 创建了一个提供完整的 Docker 容器网络拓扑管理的 "),s("a",{attrs:{href:"https://github.com/brandon-rhodes/fopnp/tree/m/playground",target:"_blank",rel:"noopener noreferrer"}},[t._v("Python库"),s("OutboundLink")],1),t._v("，包括路由、NAT 防火墙；以及一些提供 HTTP, SMTP, POP, IMAP, Telnet, SSH, FTP 的服务器。")]),t._v(" "),s("h3",{attrs:{id:"docker-编辑网络配置文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker-编辑网络配置文件","aria-hidden":"true"}},[t._v("#")]),t._v(" Docker 编辑网络配置文件")]),t._v(" "),s("p",[t._v("Docker 1.2.0 开始支持在运行中的容器里编辑 "),s("code",[t._v("/etc/hosts")]),t._v(", "),s("code",[t._v("/etc/hostname")]),t._v(" 和 "),s("code",[t._v("/etc/resolv.conf")]),t._v("文件。")]),t._v(" "),s("p",[t._v("但是这些修改是临时的，只在运行的容器中保留，容器终止或重启后并不会被保存下来。也不会被 "),s("code",[t._v("docker commit")]),t._v(" 提交。")]),t._v(" "),s("h3",{attrs:{id:"实例：创建一个点到点连接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实例：创建一个点到点连接","aria-hidden":"true"}},[t._v("#")]),t._v(" 实例：创建一个点到点连接")]),t._v(" "),s("p",[t._v("默认情况下，Docker 会将所有容器连接到由 "),s("code",[t._v("docker0")]),t._v(" 提供的虚拟子网中。")]),t._v(" "),s("p",[t._v("用户有时候需要两个容器之间可以直连通信，而不用通过主机网桥进行桥接。")]),t._v(" "),s("p",[t._v("解决办法很简单：创建一对 "),s("code",[t._v("peer")]),t._v(" 接口，分别放到两个容器中，配置成点到点链路类型即可。")]),t._v(" "),s("p",[t._v("首先启动 2 个容器：")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ docker run -i -t --rm --net"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("none base /bin/bash\nroot@1f1f4c1f931a:/"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#")]),t._v("\n$ docker run -i -t --rm --net"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("none base /bin/bash\nroot@12e343489d2f:/"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#")]),t._v("\n")])])]),s("p",[t._v("找到进程号，然后创建网络命名空间的跟踪文件。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ docker inspect -f "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'{{.State.Pid}}'")]),t._v(" 1f1f4c1f931a\n2989\n$ docker inspect -f "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'{{.State.Pid}}'")]),t._v(" 12e343489d2f\n3004\n$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("mkdir")]),t._v(" -p /var/run/netns\n$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ln")]),t._v(" -s /proc/2989/ns/net /var/run/netns/2989\n$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ln")]),t._v(" -s /proc/3004/ns/net /var/run/netns/3004\n")])])]),s("p",[t._v("创建一对 "),s("code",[t._v("peer")]),t._v(" 接口，然后配置路由")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ip")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("link")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),t._v(" A "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("type")]),t._v(" veth peer name B\n\n$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ip")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("link")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" A netns 2989\n$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ip")]),t._v(" netns "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("exec")]),t._v(" 2989 "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ip")]),t._v(" addr "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),t._v(" 10.1.1.1/32 dev A\n$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ip")]),t._v(" netns "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("exec")]),t._v(" 2989 "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ip")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("link")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" A up\n$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ip")]),t._v(" netns "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("exec")]),t._v(" 2989 "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ip")]),t._v(" route "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),t._v(" 10.1.1.2/32 dev A\n\n$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ip")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("link")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" B netns 3004\n$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ip")]),t._v(" netns "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("exec")]),t._v(" 3004 "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ip")]),t._v(" addr "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),t._v(" 10.1.1.2/32 dev B\n$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ip")]),t._v(" netns "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("exec")]),t._v(" 3004 "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ip")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("link")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" B up\n$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ip")]),t._v(" netns "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("exec")]),t._v(" 3004 "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ip")]),t._v(" route "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),t._v(" 10.1.1.1/32 dev B\n")])])]),s("p",[t._v("现在这 2 个容器就可以相互 ping 通，并成功建立连接。点到点链路不需要子网和子网掩码。")]),t._v(" "),s("p",[t._v("此外，也可以不指定 "),s("code",[t._v("--net=none")]),t._v(" 来创建点到点链路。这样容器还可以通过原先的网络来通信。")]),t._v(" "),s("p",[t._v("利用类似的办法，可以创建一个只跟主机通信的容器。但是一般情况下，更推荐使用 "),s("code",[t._v("--icc=false")]),t._v(" 来关闭容器之间的通信。")])])},[],!1,null,null,null);a.default=n.exports}}]);