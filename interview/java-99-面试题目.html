<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面试题目 | JavaChen Wiki</title>
    <meta name="description" content="JavaChen Wiki">
    <link rel="icon" href="/wiki/img/logo.ico">
  <meta http-quiv="pragma" cotent="no-cache">
  <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
  <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/wiki/assets/css/0.styles.bdf32acf.css" as="style"><link rel="preload" href="/wiki/assets/js/app.dd178f5a.js" as="script"><link rel="preload" href="/wiki/assets/js/2.9f273a62.js" as="script"><link rel="preload" href="/wiki/assets/js/38.2a06b872.js" as="script"><link rel="prefetch" href="/wiki/assets/js/10.e389070d.js"><link rel="prefetch" href="/wiki/assets/js/11.19e9f97f.js"><link rel="prefetch" href="/wiki/assets/js/12.f95e0459.js"><link rel="prefetch" href="/wiki/assets/js/13.127730fd.js"><link rel="prefetch" href="/wiki/assets/js/14.34eed2f7.js"><link rel="prefetch" href="/wiki/assets/js/15.a8cf4000.js"><link rel="prefetch" href="/wiki/assets/js/16.6346731c.js"><link rel="prefetch" href="/wiki/assets/js/17.143af375.js"><link rel="prefetch" href="/wiki/assets/js/18.7d95703a.js"><link rel="prefetch" href="/wiki/assets/js/19.8726bd0b.js"><link rel="prefetch" href="/wiki/assets/js/20.2914a04f.js"><link rel="prefetch" href="/wiki/assets/js/21.ebd751e0.js"><link rel="prefetch" href="/wiki/assets/js/22.f6801be0.js"><link rel="prefetch" href="/wiki/assets/js/23.87ecfe73.js"><link rel="prefetch" href="/wiki/assets/js/24.cabcaf93.js"><link rel="prefetch" href="/wiki/assets/js/25.306828f5.js"><link rel="prefetch" href="/wiki/assets/js/26.59450304.js"><link rel="prefetch" href="/wiki/assets/js/27.44fddb85.js"><link rel="prefetch" href="/wiki/assets/js/28.4e15bea1.js"><link rel="prefetch" href="/wiki/assets/js/29.bed7cbfd.js"><link rel="prefetch" href="/wiki/assets/js/3.28138f41.js"><link rel="prefetch" href="/wiki/assets/js/30.36a67cca.js"><link rel="prefetch" href="/wiki/assets/js/31.dde8666e.js"><link rel="prefetch" href="/wiki/assets/js/32.148ea73a.js"><link rel="prefetch" href="/wiki/assets/js/33.61c937cc.js"><link rel="prefetch" href="/wiki/assets/js/34.eb7c4b0c.js"><link rel="prefetch" href="/wiki/assets/js/35.abb4ce3d.js"><link rel="prefetch" href="/wiki/assets/js/36.f03d0378.js"><link rel="prefetch" href="/wiki/assets/js/37.84491176.js"><link rel="prefetch" href="/wiki/assets/js/39.63965d3b.js"><link rel="prefetch" href="/wiki/assets/js/4.c0af9872.js"><link rel="prefetch" href="/wiki/assets/js/40.bf2e354a.js"><link rel="prefetch" href="/wiki/assets/js/41.bed53451.js"><link rel="prefetch" href="/wiki/assets/js/42.34d4f2f5.js"><link rel="prefetch" href="/wiki/assets/js/43.867c0e23.js"><link rel="prefetch" href="/wiki/assets/js/44.0201a314.js"><link rel="prefetch" href="/wiki/assets/js/45.d6f1a311.js"><link rel="prefetch" href="/wiki/assets/js/46.419d44e4.js"><link rel="prefetch" href="/wiki/assets/js/47.a3f8b595.js"><link rel="prefetch" href="/wiki/assets/js/48.574cc219.js"><link rel="prefetch" href="/wiki/assets/js/49.224dd6c4.js"><link rel="prefetch" href="/wiki/assets/js/5.c521f8b1.js"><link rel="prefetch" href="/wiki/assets/js/50.c8825040.js"><link rel="prefetch" href="/wiki/assets/js/51.2dab614a.js"><link rel="prefetch" href="/wiki/assets/js/52.8382a180.js"><link rel="prefetch" href="/wiki/assets/js/53.bfab18a9.js"><link rel="prefetch" href="/wiki/assets/js/54.87a1d37c.js"><link rel="prefetch" href="/wiki/assets/js/55.5f207671.js"><link rel="prefetch" href="/wiki/assets/js/56.f0e8e082.js"><link rel="prefetch" href="/wiki/assets/js/57.c868e5c9.js"><link rel="prefetch" href="/wiki/assets/js/6.6a737c5b.js"><link rel="prefetch" href="/wiki/assets/js/7.48bba6b4.js"><link rel="prefetch" href="/wiki/assets/js/8.26532964.js"><link rel="prefetch" href="/wiki/assets/js/9.3c4a4032.js">
    <link rel="stylesheet" href="/wiki/assets/css/0.styles.bdf32acf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/wiki/" class="home-link router-link-active"><!----> <span class="site-name">JavaChen Wiki</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/wiki/" class="nav-link">主页</a></div><div class="nav-item"><a href="/wiki/docker/" class="nav-link">Docker</a></div><div class="nav-item"><a href="/wiki/elasticsearch/" class="nav-link">Elasticsearch</a></div><div class="nav-item"><a href="/wiki/hadoop/" class="nav-link">Hadoop</a></div><div class="nav-item"><a href="/wiki/interview/" class="nav-link router-link-active">Interview</a></div><div class="nav-item"><a href="/wiki/rabbitMQ/" class="nav-link">RabbitMQ</a></div><div class="nav-item"><a href="/wiki/redis/" class="nav-link">Redis</a></div><div class="nav-item"><a href="/wiki/spring-cloud-cshop/" class="nav-link">Spring-cloud-cshop</a></div><div class="nav-item"><a href="/wiki/about.html" class="nav-link">关于</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/wiki/" class="nav-link">主页</a></div><div class="nav-item"><a href="/wiki/docker/" class="nav-link">Docker</a></div><div class="nav-item"><a href="/wiki/elasticsearch/" class="nav-link">Elasticsearch</a></div><div class="nav-item"><a href="/wiki/hadoop/" class="nav-link">Hadoop</a></div><div class="nav-item"><a href="/wiki/interview/" class="nav-link router-link-active">Interview</a></div><div class="nav-item"><a href="/wiki/rabbitMQ/" class="nav-link">RabbitMQ</a></div><div class="nav-item"><a href="/wiki/redis/" class="nav-link">Redis</a></div><div class="nav-item"><a href="/wiki/spring-cloud-cshop/" class="nav-link">Spring-cloud-cshop</a></div><div class="nav-item"><a href="/wiki/about.html" class="nav-link">关于</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Interview</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/wiki/interview/" class="sidebar-link">编程之道</a></li><li><a href="/wiki/interview/java-0-基础.html" class="sidebar-link">Java基础</a></li><li><a href="/wiki/interview/java-1-数据结构和算法.html" class="sidebar-link">基本概念</a></li><li><a href="/wiki/interview/java-2-JVM.html" class="sidebar-link">JVM</a></li><li><a href="/wiki/interview/java-3-线程.html" class="sidebar-link">线程</a></li><li><a href="/wiki/interview/java-4-网络编程.html" class="sidebar-link">NIO、BIO、AIO</a></li><li><a href="/wiki/interview/java-5-设计模式.html" class="sidebar-link">设计模式</a></li><li><a href="/wiki/interview/java-6-框架.html" class="sidebar-link">开源框架</a></li><li><a href="/wiki/interview/java-7-数据库.html" class="sidebar-link">数据库</a></li><li><a href="/wiki/interview/java-8-分布式.html" class="sidebar-link">分布式</a></li><li><a href="/wiki/interview/java-9-微服务.html" class="sidebar-link">微服务</a></li><li><a href="/wiki/interview/java-99-面试题目.html" class="active sidebar-link">面试题目</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/interview/java-99-面试题目.html#java基础" class="sidebar-link">Java基础</a></li><li class="sidebar-sub-header"><a href="/wiki/interview/java-99-面试题目.html#集合" class="sidebar-link">集合</a></li><li class="sidebar-sub-header"><a href="/wiki/interview/java-99-面试题目.html#线程和并发" class="sidebar-link">线程和并发</a></li><li class="sidebar-sub-header"><a href="/wiki/interview/java-99-面试题目.html#算法" class="sidebar-link">算法</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="面试题目"><a href="#面试题目" aria-hidden="true" class="header-anchor">#</a> 面试题目</h1> <h2 id="java基础"><a href="#java基础" aria-hidden="true" class="header-anchor">#</a> Java基础</h2> <ul><li><p><strong>Java</strong> 虚拟机的运行时数据区有几块?线 程私有和线程共享区域有哪些?</p> <p>1、程序计数器：线程私有，当前县城执行的字节码的行号指示器。</p> <p>2、虚拟机栈：线程私有，存放基本数据类型、对象引用和 returnAddress 类型。</p> <p>3、本地方法栈：为虚拟机使用到的 Native 方法服务。</p> <p>4、Java 堆：线程共享，存放对象的实例，也是 GC 回收器管理的主要 区域。</p> <p>5、方法区：线程共享，存放已被虚拟机加载的类信息、常量、静态变 量、即时编译后的代码等数据。</p> <p>6、运行时常量池：方法区的一部分，存放编译期生成的各种字面量和 符号引用。</p> <p>7、直接内存：不是虚拟机运行时数据区的一部分，也不是 Java 虚拟 机规范中定义的内存区域，容易引起 OOM 异常，NIO 会调用，不受 Java 堆大小的限制。</p></li> <li><p>Java的平台无关性如何体现出来的</p> <p>传统的编程中，源代码编译为可执行的代码后，只能针对特定的平台（操作系统），换句话说，针对Windows编写和编译的代码，只能在Windows上运行</p> <p>java程序则编译为字节码。字节码本身不能运行，因为它不是原生代码。字节码只能够在Java虚拟机（JVM）上运行。JVM是一个原生应用程序，它负责解释字节码。通过使用JVM可用在众多的平台上运行程序。</p> <p>简单来说：java源文件(.java)通过编译器生成字节码文件（.class），字节码文件（.class）通过JVM（Java虚拟机）中的解释器再翻译成特定机器上的机器码，然后在特定的机器上运行。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。</p></li> <li><p>面向对象的特征：继承、封装和多态</p> <p>面向对象编程有四个特征：抽象，封装，继承，多态。</p> <p>多态有四种体现形式：</p> <ol><li><p>接口和接口的继承。</p></li> <li><p>类和类的继承。</p></li> <li><p>重载。</p></li> <li><p>重写。</p></li></ol> <p>其中重载和重写为核心。</p> <p>重载：重载发生在同一个类中，在该类中如果存在多个同名方法，但是方法的参数类型和个数不一样，那么说明该方法被重载了。</p> <p>重写：重写发生在子类继承父类的关系中，父类中的方法被子类继承，方法名，返回值类型，参数完全一样，但是方法体不一样，那么说明父类中的该方法被子类重写了。</p></li> <li><p><strong>Static</strong>加载顺序</p> <p>父类的静态代码块，子类的静态代码块，调用子类的main方法中的方法，父类的构造代码块，父类的构造器，子类的构造代码块，子类的构造器</p> <p>注意：静态代码块是在类加载时加载的</p></li> <li><p>final, finally, finalize 的区别</p> <p>Final是一个修饰符：</p> <p>当final修饰一个变量的时候，变量变成一个常量，它不能被二次赋值</p> <p>当final修饰的变量为静态变量（即由static修饰）时，必须在声明这个变	量的时候给它赋值</p> <p>当final修饰方法时，该方法不能被重写</p> <p>当final修饰类时，该类不能被继承</p> <p>Final不能修饰抽象类，因为抽象类中会有需要子类实现的抽	象方法，（抽	象类中可以有抽象方法，也可以有普通方法，当一个抽象类中没有抽象方	法时，这个抽象类也就没有了它存在的必要）</p> <p>Final不能修饰接口，因为接口中有需要其实现类来实现的方法</p> <p>Finally：</p> <p>Finally只能与try/catch语句结合使用，finally语句块中的语句一定会执行，并且会在return，continue，break关键字之前执行</p> <p>finalize：</p> <p>Finalize是一个方法，属于java.lang.Object类，finalize()方法是GC	（garbage 	collector垃圾回收）运行机制的一部分，finalize()方法是在	GC清理它所从	属的对象时被调用的</p></li> <li><p>Exception、Error、运行时异常与一般异常有何异同</p> <p>java 异常是程序运行过程中出现的错误。Java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类。在Java API中定义了许多异常类,分为两大类，错误Error和异常Exception。其中异常类Exception又分为运行时异常(RuntimeException)和非运行时异常(非runtimeException)，也称之为不检查异常（Unchecked Exception）和检查异常（Checked Exception）。</p> <p>1、Error与Exception</p> <p>​	Error是程序无法处理的错误，比如OutOfMemoryError、ThreadDeath等。</p> <p>​	这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</p> <p>​</p> <p>​	Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。程序中应当尽可能去处理这些异常。</p> <p>2、运行时异常和非运行时异常</p> <p>​		运行时异常：都是RuntimeException类及其子类异常：</p> <p>​	   	 IndexOutOfBoundsException 索引越界异常</p> <p>​			ArithmeticException：数学计算异常</p> <p>​			NullPointerException：空指针异常</p> <p>​			ArrayOutOfBoundsException：数组索引越界异常</p> <p>​			ClassNotFoundException：类文件未找到异常</p> <p>​			ClassCastException：造型异常（类型转换异常）</p> <p>​</p> <p>​	这些异常是不检查异常（Unchecked Exception），程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的。</p> <p>​</p> <p>​	非运行时异常：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如：</p> <p>​			IOException、文件读写异常</p> <p>​			FileNotFoundException：文件未找到异常</p> <p>​		    EOFException：读写文件尾异常</p> <p>​			MalformedURLException：URL格式错误异常</p> <p>​			SocketException：Socket异常</p> <p>​			SQLException：SQL数据库异常</p></li> <li><p>int 和 Integer 有什么区别，Integer的值缓存范围</p> <p>int 是基本数据类型，直接存数值，进行初始化时 int 类的变量初始值为 0 ；
Integer 是对象，用一个引用指向这个对象，Integer 的变量初始化值为 null 。</p></li> <li><p>包装类，装箱和拆箱</p> <p>包装类：是对基本类型的一种包装，主要是为了将这些基本数据类型当成对象操作。</p> <h5 id="自动装箱：将基本数据类重新转换为对象"><a href="#自动装箱：将基本数据类重新转换为对象" aria-hidden="true" class="header-anchor">#</a> 自动装箱：将基本数据类重新转换为对象</h5> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 声明一个Integer 对象</span>
        <span class="token class-name">Integer</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        <span class="token comment">// 以上的声明就是用到了自动的装箱：</span>
        <span class="token comment">//解析为 Integer num = Integer.valueOf(10); </span>
        <span class="token comment">//valueOf(参数)方法其实调用的是 new Integer(10);</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="自动拆箱：将对象重新转换为基本数据类型"><a href="#自动拆箱：将对象重新转换为基本数据类型" aria-hidden="true" class="header-anchor">#</a> 自动拆箱：将对象重新转换为基本数据类型</h5> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args <span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 声明一个Integer 对象</span>
        <span class="token class-name">Integer</span>  a  <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
         <span class="token comment">// 下面进行计算时隐含的有自动拆箱</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> a<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因为对象时不能直接进行运算的，而是要转化为基本数据类型才能够加减乘除。</p></li> <li><p>String、StringBuilder、StringBuffer</p> <p>String       字符串常量   不可变  使用字符串拼接时是不同的2个空间</p> <p>StringBuffer  字符串变量   可变   线程安全  字符串拼接直接在字符串后追加</p> <p>StringBuilder 字符串变量   可变   非线程安全  字符串拼接直接在字符串后追加</p> <p>1、StringBuilder执行效率高于StringBuffer高于String。</p> <p>2、String是一个常量，是不可变的，所以对于每一次+=赋值都会创建一个新的对象，StringBuffer和StringBuilder都是可变的，当进行字符串拼接时采用append方法，在原来的基础上进行追加，所以性能比String要高，又因为StringBuffer是线程安全的而StringBuilder是线程非安全的，所以StringBuilder的效率高于StringBuffer.</p> <p>3、对于大数据量的字符串的拼接，采用StringBuffer、StringBuilder。</p></li> <li><p>重载和重写的区别</p> <p>重载发生在本类，方法名相同，参数列表不同，与返回值无关，只和方法名、参数列表、参数的类型有关。</p> <p>（1）方法名必须相同</p> <p>（2）方法的参数列表一定不一样。</p> <p>（3）访问修饰符和返回值类型可以相同也可以不同。</p> <p>其实简单而言：重载就是对于不同的情况写不同的方法。 比如，同一个类中，写不同的构造函数用于初始化不同的参数。</p> <p>重写发生在父类子类之间，比如所有类都是继承与Object类的，Object类中本身就有equals、hashcode、toString方法等。在任意子类中定义了重名和同样的参数列表就构成方法重写。</p> <p>重写：一般都是表示子类和父类之间的关系，其主要的特征是：方法名相同，参数相同，但是具体的实现不同。</p> <p>（1）方法名必须相同，返回值类型必须相同</p> <p>（2）参数列表必须相同</p> <p>（3）访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。</p> <p>（4）子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</p> <p>（5）构造方法不能被重写</p> <p>简单而言：就是具体的实现类对于父类的该方法实现不满意，需要自己在写一个满足于自己要求的方法。</p></li> <li><p>抽象类和接口有什么区别</p> <p>1、抽象类里可以有构造方法，而接口内不能有构造方法。</p> <p>2、抽象类中可以有普通成员变量，而接口中不能有普通成员变量。</p> <p>3、抽象类中可以包含非抽象的普通方法，而接口中所有的方法必须是 抽象的，不能有非抽象的普通方法。</p> <p>4、抽象类中的抽象方法的访问类型可以是 public ，protected 和默认 类型，但接口中的抽象方法只有 public 和默认类型。</p> <p>5、抽象类中可以包含静态方法，接口内不能包含静态方法。</p> <p>6、抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变 量的访问类型可以任意，但接口中定义的变量只能是 public static 类 型，并且默认为 public static 类型。</p> <p>7、一个类可以实现多个接口，但只能继承一个抽象类。</p> <p>8、接口更多的是在系统框架设计方法发挥作用，主要定义模块之间的 通信，而抽象类在代码实现方面发挥作用，可以实现代码的重用。</p></li> <li><p><strong>Java</strong> 反射</p> <p>反射机制指的是程序在运行时能够获取自身的信息。 为什么要用反射机制?直接创建对象不就可以了吗，这就涉及到了动 态与静态的概念，</p> <p>静态编译：在编译时确定类型，绑定对象,即通过。</p> <p>动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥 了 java 的灵活性，体现了多态的应用，有以降低类之间的藕合性。</p> <p>一句话，反射机制的优点就是可以实现动态创建对象和编译，体现出很大的灵活性，特别是在 J2EE 的开发中 它的灵活性就表现的十分明显。</p> <p>作用：</p> <p>1、首先得根据传入的类的全名来创建 Class 对象。</p> <p>2、获得类方 法的方法。</p> <p>3、获得类中属性的方法。</p> <p>缺点：</p> <p>1、性能第一：反射包括了一些动态类型，所以 JVM 无法对这些 代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。 我们应该避免在经常被 执行的代码或对性能要求很高的程序中使用 反射。</p> <p>2、安全限制：使用反射技术要求程序必须在一个没有安全限制 的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet。</p> <p>3、内部暴露：由于反射允许代码执行一些在正常情况下不被 允许的操作(比如访问私有的属性和方法)，所以使用反射可能会导 致意料之外的副作用--代码有功能上的错误，降低可移植性。反射 代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可 能也随着变化。</p></li> <li><p>equals与==的区别</p> <p>== 比较基本类型，比较的时基本类型的值；比较引用类型则比较的是地址值。</p> <p>equals是Object类里的方法，只能比较引用类型，也是比较地址。实际开发中往往重写equals方法。如String，arrays，Integer都重写了。重写类的equals方法时，也要重写hashCode方法</p></li> <li><p>hashCode和equals方法的区别与联系</p> <p>两个对象 equals的时候，hashCode必须相等，但hashCode相等，对象不一定equals。</p> <p>如果没有重写 hashcode方法，使用Object自带的hashCode，无法保证两个对象equals的时候 hashCode 必须相等的条件。</p> <p>在Java中，重写equals()方法之后，是否需要重写hashCode()方法，那要看分情况来说明。有些情况下，是建议；有些情况下，是必须重写。</p> <ul><li>首先说建议的情况：比如你的对象想放到Set集合或者是想作为Map的key时，那么你必须重写equals()方法，这样才能保证唯一性。当然，在这种情况下，你不想重写hashCode()方法，也没有错。但是，对于良好的编程风格而言，你应该在重写equals()方法的同时，也重写hashCode()方法。</li> <li>必须重写hashCode()的情况：如果你的对象想放进散列存储的集合中（比如：HashSet,LinkedHashSet）或者想作为散列Map（例如：HashMap,LinkedHashMap等等）的Key时，在重写equals()方法的同时，必须重写hashCode()方法。</li></ul> <p>最后明白两点就行了：
1、hashCode()方法存在的主要目的就是提高效率。</p> <p>2、在集合中判断两个对象相等的条件，其实无论是往集合中存数据，还是从集合中取数据，包括如果控制唯一性等，都是用这个条件判断的，条件如下：</p> <p>首先判断两个对象的hashCode是否相等，如果不相等，就认为这两个对象不相等，就完成了。如果相等，才会判断两个对象的equals()是否相等，如果不相等，就认为这两个对象不相等，如果相等，那就认为这两个对象相等。</p> <p>上面的条件对于任何集合都是如此，只要理解上面的条件，你就明白了，为什么在有些情况下建议重写hashCode().有些情况下，是必须要重写的，只有一个目的，就是提高效率，你想想，如果你重写了hashCode(),只要不满足第一个条件，那就直接可以判断两个对象是不等的，也就不用花费时间再去比较equals了。</p></li> <li><p>toString()方法什么情况下需要重写；</p> <p>如果不重写，直接调用Object类的toString()方法，打印的是该对象的内存地址（类名@哈希码值）。</p> <p>一般在编写代码，POJO类必须重写toString方法。如果继承了另一个POJO类，注意在前面加一下super.toString</p></li> <li><p>Object的hashcode()是怎么计算的？</p> <p>Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，是通过该对象的内存地址（物理地址）进行hash计算(目前只知道hash计算取余的方法)，最后返回hashcode</p></li> <li><p>String中hashcode是怎么实现的；</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h <span class="token operator">=</span> hash<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">char</span> val<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            h <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">*</span> h <span class="token operator">+</span> val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        hash <span class="token operator">=</span> h<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> h<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>若hashcode方法永远返回1或者一个常量会产生什么结果？</p> <p>当hashCode()返回常量时，所有对象都出现hash冲突，而hashCode()本身的性能也会降级。
做hash的key的时候效率会极度变低，变量比较也会变慢</p></li> <li><p>什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable 接口的作用</p> <p>序列化：将那些实现了Serializable接口的对象转换成一个字节序列，并且能够在以后将这个字节序列完全恢复为原来的对象，序列化可以弥补不同操作系统之间的差异。</p> <p>反序列化：将这个字节序列完全恢复为原来的对象</p> <p>实现序列化的方法</p> <p>1、实现Serializable接口</p> <ul><li><p>该接口是一个可序列化的标志，并没有包含实际的属性和方法。</p></li> <li><p>如果不在该方法中添加readObject()和writeObject()方法，则采取默认的序列化机制。如果添加了这两个方法之后还想利用Java默认的序列化机制，则在这两个方法中分别调用defaultReadObject()和defaultWriteObject()两个方法。</p></li> <li><p>为了保证安全性，可以使用transient关键字进行修饰不必序列化的属性。因为在反序列化时，private修饰的属性也能被查看到。</p></li></ul> <p>2、实现ExternalSerializeable方法</p> <p>自己对要序列化的内容进行控制，控制哪些属性能被序列化，哪些不能被序列化。</p> <p>反序列化的方法：</p> <ul><li><p>实现Serializable接口对象在反序列化时不需要调用对象所在类的构造方法，完全基于字节。</p></li> <li><p>实现externalSerializable接口的方法在反序列化时会调用构造方法。</p></li></ul> <p>注意事项：</p> <ul><li><p>被static修饰的属性不会被序列化</p></li> <li><p>对象的类名、属性名都会被序列化，方法不会被序列化。</p></li> <li><p>要保证序列化对象所在类的属性也是可以被序列化的。</p></li> <li><p>当通过网络、文件进行序列化时，必须按照写入的顺序读取对象。</p></li> <li><p>反序列化时必须有序列化对象时的class文件。</p></li> <li><p>最好显示地声明serializableID，因为在不同的JVM之间，默认生成serializeableID可能不同,会造成反序列化失败。</p></li></ul></li></ul> <p>实现java.io.Serializable 接口的类是可序列化的，是可以转换为字节序列，这些字节序列可以被完全存储以备以后重新生成原来的对象。</p> <ul><li><p>Java 8有哪些新特性</p> <p><strong>Lambda表达式</strong></p> <p><strong>接口的默认方法与静态方法</strong>：我们可以在接口中定义默认方法，使用default关键字，并提供默认的实现。所有实现这个接口的类都会接受默认方法的实现，除非子类提供的自己的实现。</p> <p><strong>方法引用</strong>：通常与Lambda表达式联合使用，可以直接引用已有Java类或对象的方法。</p> <p><strong>重复注解</strong></p> <p><strong>扩展注解的支持</strong>：Java 8扩展了注解的上下文，几乎可以为任何东西添加注解，包括局部变量、泛型类、父类与接口的实现，连方法的异常也能添加注解</p> <p><strong>Optional</strong>：Java 8引入Optional类来防止空指针异常</p> <p><strong>Stream</strong>：Stream API是把真正的函数式编程风格引入到Java中。其实简单来说可以把Stream理解为MapReduce</p> <p><strong>Date/Time API (JSR 310)</strong></p> <p><strong>JavaScript引擎Nashorn</strong></p> <p><strong>Base64</strong></p></li> <li><p>浅拷贝和深拷贝的区别；</p> <p>浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化</p> <p>深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变</p> <p>深拷贝的实现方法主要有两种：</p> <ul><li><p>通过重写clone方法来实现深拷贝</p></li> <li><p>通过对象序列化实现深拷贝</p></li></ul></li> <li><p>String s=”abc”和String s=new String(“abc”)区别；</p> <p>String a=&quot;abc&quot;，这行代码被执行的时候，JAVA虚拟机首先在字符串池中查找是否已经存在了值为&quot;abc&quot;的这么一个对象，它的判断依据是String类equals(Object obj)方法的返回值。如果有，则不再创建新的对象，将使用串池里原来的那个内存，直接返回已存在对象的引用，而不会重新分配内存；如果没有，则先创建这个对象，然后把它加入到字符串池中，再将它的引用返回。</p> <p>而如果用String s=new String(&quot;abc&quot;)，不管串池里有没有&quot;abc&quot;，它都会在堆中重新分配一块内存，定义一个新的对象。</p> <p>再看下个例子：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> s<span class="token operator">=</span><span class="token string">&quot;java&quot;</span><span class="token operator">+</span><span class="token string">&quot;blog&quot;</span><span class="token punctuation">;</span><span class="token comment">//直接将javablog对象放入字符串池中。</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token operator">==</span><span class="token string">&quot;javablog&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//结果是true;</span>

<span class="token class-name">String</span> str1<span class="token operator">=</span><span class="token string">&quot;java&quot;</span><span class="token punctuation">;</span><span class="token comment">//指向字符串池</span>
<span class="token class-name">String</span> str2<span class="token operator">=</span><span class="token string">&quot;blog&quot;</span><span class="token punctuation">;</span><span class="token comment">//指向字符串池</span>
<span class="token class-name">String</span> s <span class="token operator">=</span> str1<span class="token operator">+</span>str2<span class="token punctuation">;</span> 
</code></pre></div><p>+运算符会在堆中建立起两个String对象，这两个对象的值分别是“java”,&quot;blog&quot;,也就是说从字符串常量池中复制这两个值，然后再堆中创建两个对象。然后再建立对象s, 然后将“javablog”的堆地址赋给s. 这句话共创建了3个String对象。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token operator">==</span><span class="token string">&quot;javablog&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//因为内存地址不同，结果是false;</span>

<span class="token class-name">String</span> s<span class="token operator">=</span>str1<span class="token operator">+</span><span class="token string">&quot;blog&quot;</span><span class="token punctuation">;</span><span class="token comment">//不放在字符串池中，而是在堆中分分配。</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token operator">==</span><span class="token string">&quot;javablog&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//结果是false;</span>
</code></pre></div><p>JVM对形如<code>String str=&quot;java&quot;+&quot;blog&quot;;</code>根据编译器合并已知量的优化功能，在池中开辟一块空间，存放合并后的String常量&quot;javablog&quot;。而<code>String s=str1+str2;</code>是在运行时候才能知道的，也就是说str1+str2是在堆里创建的所以结果为false了。</p> <p>总之，创建字符串有两种方式：两种内存区域(pool,heap)
1、&quot;&quot;创建的字符串在字符串池中。
2、new 创建字符串时，首先查看池中是否有相同的字符串，如果有则拷贝一份放到堆中，然后返回堆中的地址；如果池中没有则在堆中创建一份，然后返回堆中的地址，</p> <p>3、在对字符串赋值时，如果右操作数含有一个或一个以上的字符串引用时，则在堆中再建立一个字符串对象，返回引用。如：<code>String s= str1+&quot;blog&quot;</code>;</p></li></ul> <h2 id="集合"><a href="#集合" aria-hidden="true" class="header-anchor">#</a> 集合</h2> <ul><li><p><strong>HashMap</strong> 和 <strong>HashTable</strong> 区别?</p> <p>1、Hashtable 是基于陈旧的 Dictionary 类的，HashMap 是 Java 1.2 引 进的 Map 接口的一个实现</p> <p>2、Hashtable 的方法是同步的，而 HashMap 的方法不是，因此</p> <p>HashTable 是线程安全的，但是代码的执行效率上要慢于 HashMap。</p> <p>3、HashMap 允许空值和空键，但是 HashTable 不可以。</p> <p>4、HashMap 非同步实现 Map 接口，是一个“链表数组”的数据结构， 最大承载量是 16，可以自动变长，由 Entry[]控制(key，value，next)， hashCode()判断 key 是否重复。</p> <p>5、建议需要做同步，使用 ConcurrentHashMap，降低了锁的粒度。在 hashMap 的基础上，ConcurrentHashMap 将数据分为多个 segment， 默认 16 个(concurrency level)，然后每次操作对一个 segment 加锁， 避免多线程锁得几率，提高并发效率。这里在并发读取时，除了 key 对应的 value 为 null 之外，并没有使用锁。</p></li> <li><p><strong>ArrayList</strong> 和 <strong>LinkedList</strong> 区别?</p> <p>ArrayList 基于数组实现，LinkedList 基于链表实现，ArrayList 增加和 删除比 LinkedList 慢，但是 LinkedList 在查找的时需要递归查找，效 率比 ArrayList 慢。</p> <p>关于多线程方面，如果要求线程安全的，有一个 Vector，不过比较多的使用的是 CopyOnWriteArrayList 替代 ArrayList， CopyOnWriteArrayList 适合使用在读操作远远大于写操作的场景里， 比如缓存。发生修改时候做 copy，新老版本分离，保证读的高性能， 适用于以读为主的情况。</p> <p>Arraylist与LinkedList默认空间是多少；</p> <p>ArrayList和LinkList的删除一个元素的时间复杂度；（ArrayList是O(N)，LinkList是O(1)）；</p></li> <li><p><strong>Set</strong> 接口</p> <p>1、HashSet 是 Set 接口的典型实现，HashSet 按 hash 算法来存储元 素，因此具有很好的存取和查找性能。</p> <p>特点：不能保证元素的排列顺 序，顺序有可能发生变化;HashSet 是异步的;集合元素值可以是 null; 当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode()方法来得到该对象的 hashCode 值，然后根据该 HashCode 值来确定该对象在 HashSet 中存储的位置。HashSet 还有 一个子类LinkedHashSet，其集合也是根据元素 hashCode 值来决定 元素的存储位置，但它同时用链表来维护元素的次序，这样使得元素 看起来是以插入的顺序保存的，也就是说，当遍历 LinkedHashSet 集 合元素时，它将会按元素的添加顺序来访问集合里的元素。所以 LinkedHashSet 的性能略低于 HashSet，但在迭代访问全部元素时将 有很好的性能，因为它以链表来维护内部顺序。</p> <p>2、TreeSet 是 SortSet 接口的唯一实现，TreeSet 可以确保集合元素处 于排序状态。TreeSet 不是根据元素插入顺序进行排序的，而是根据 元素的值来排序的。TreeSet 支持两种排序方法:自然排序和定制排 序。</p> <p>3、EnumSet 中所有值都必须是指定枚举类型的值，它的元素也是有序 的，以枚举值在枚举类的定义顺序来决定集合元素的顺序。EnumSet 集合不允许加入 null 元素，否则会抛出 NullPointerException 异常。 EnumSet 类没有暴露任何构造器来创建该类的实例，程序应该通过它提供的 static 方法来创建 EnumSet 对象。</p> <p>4、总结:
A、HashSet 的性能比 Treeset 好，因为 TreeSet 需要额外的红黑树算 法来维护集合元素的次序，只有当需要一个保持排序的 Set 时，才会 用 TreeSet。
B、EnumSet 是性能最好的，但它只能保存枚举值。</p> <p>C、它们都是线程不安全的。</p> <p>注：Set 是一种不包含重复的元素的 Collection，即任意的两个元素 e1 和 e2 都有 e1.equals(e2)=false，Set 最多有一个 null 元素。</p> <p>关于 HashSet，条目数和容量之和来讲，迭代是线性的。因此，如果 迭代性能很重要，那就应该慎重选择一个适当的初始容量。容量选得 太大，既浪费空间，也浪费时间。默认的初试容量是 101，一般来讲， 它比你所需要的要多。可以使用 int 构造函数来指定初始容量。要分 配 HashSet 的初始容量为 17:</p> <div class="language- extra-class"><pre class="language-text"><code>Set s=new HashSet(17);
</code></pre></div><p>HashSet 另有一个称作装载因数(load factor)的&quot;调整参数(tuning parameter)&quot;。</p> <p>区别:</p> <p>1、HashSet 是通过 HashMap 实现的，TreeSet 是通过 TreeMap 实现 的，只不过 Set 用的只是 Map 的 key。</p> <p>2、Map 的 key 和 Set 都有一个共同的特性就是集合的唯一 性。TreeMap 更是多了一个排序的功能。</p> <p>3、hashCode 和 equal()是 HashMap 用的，因为无需排序所以只需要关注定位和唯一性即可。
a. hashCode 是用来计算 hash 值的，hash 值是用来确定 hash 表索引的。
b. hash 表中的一个索引处存放的是一张链表， 所以还要通过 equal 方法循环比较链上的每一个对象才可以真正定位到键值对应的 Entry。</p> <p>c. put时，如果hash表中没定位到,就在链表前加一个Entry，如果 定位到了,则更换 Entry 中的 value,并返回旧 value。</p> <p>4、由于 TreeMap 需要排序，所以需要一个 Comparator 为键值进行 大小比较。当然也是用 Comparator 定位的.。</p> <p>a. Comparator 可以在创建 TreeMap 时指定</p> <p>b. 如果创建时没有确定，那么就会使用 key.compareTo()方法，这就要求 key 必须实现 Comparable 接口。
TreeMap 是使用 Tree 数据结构实现的,所以使用 compare 接口就可 以完成定位了。</p></li> <li><p>List 和 Set 区别</p></li> <li><p>Set和hashCode以及equals方法的联系</p></li> <li><p>Set内存放的元素为什么不可以重复，内部是如何保证和实现的？</p></li> <li><p>List 和 Map 区别</p></li> <li><p>ArrayList 与 Vector 区别</p></li></ul> <p>首先看这两类都实现List接口，而List接口一共有三个实现类，分别是ArrayList、Vector和LinkedList。List用于存放多个元素，能够维护元素的次序，并且允许元素的重复。3个具体实现类的相关区别如下：</p> <p>ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</p> <p>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。</p> <p>LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</p> <p>vector是线程（Thread）同步（Synchronized）的，所以它也是线程安全的，而Arraylist是线程异步（ASynchronized）的，是不安全的。如果不考虑到线程的安全因素，一般用Arraylist效率比较高。</p> <p>如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度</p> <p>的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。</p> <p>如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，都是0(1),这个时候使用vector和arraylist都可以。而</p> <p>如果移动一个指定位置的数据花费的时间为0(n-i)n为总长度，这个时候就应该考虑到使用Linkedlist,因为它移动一个指定位置的数据</p> <p>所花费的时间为0(1),而查询一个指定位置的数据时花费的时间为0(i)。</p> <p>ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，</p> <p>都允许直接序号索引元素，但是插入数据要设计到数组元素移动 等内存操作，所以索引数据快插入数据慢，</p> <p>Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差</p> <p>LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快！</p> <p>笼统来说：</p> <p>​		LinkedList：增删改快</p> <p>​        ArrayList：查询快（有索引的存在）</p> <ul><li><p>HashSet 和 HashMap 区别</p></li> <li><p>HashMap 和 ConcurrentHashMap 的区别</p></li> <li><p>HashMap 的工作原理及代码实现，什么时候用到红黑树</p></li> <li><p>多线程情况下HashMap死循环的问题</p></li> <li><p>HashMap出现Hash DOS攻击的问题</p></li> <li><p>ConcurrentHashMap 的工作原理及代码实现，如何统计所有的元素个数</p></li> <li><p>谈谈HashMap，哈希表解决hash冲突的方法；</p> <p>开放地址法、链地址法、再哈希法、建立公共溢出区等）</p></li> <li><p>Java Collections和Arrays的sort方法默认的排序方法是什么；</p></li> <li><p>说一下TreeMap的实现原理？红黑树的性质？红黑树遍历方式有哪些？如果key冲突如何解决？setColor()方法在什么时候用？什么时候会进行旋转和颜色转换？</p></li></ul> <h2 id="线程和并发"><a href="#线程和并发" aria-hidden="true" class="header-anchor">#</a> 线程和并发</h2> <ul><li>Lock与synchronized 的区别</li></ul> <p>1、ReentrantLock 拥有Synchronized相同的并发性和内存语义，此外还多了 锁投票，定时锁等候和中断锁等候</p> <p>线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定，</p> <p>如果使用 synchronized ，如果A不释放，B将一直等下去，不能被中断</p> <p>如果 使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情</p> <p>ReentrantLock获取锁定与三种方式：</p> <p>a) lock(), 如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁</p> <p>b) tryLock(), 如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false；</p> <p>c)tryLock(long timeout,TimeUnit unit)， 如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；</p> <p>d) lockInterruptibly:如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断</p> <p>2、synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定，但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到finally{}中</p> <p>3、在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态；</p> <p>5.0的多线程任务包对于同步的性能方面有了很大的改进，在原有synchronized关键字的基础上，又增加了ReentrantLock，以及各种Atomic类。了解其性能的优劣程度，有助与我们在特定的情形下做出正确的选择。</p> <p>总体的结论先摆出来：</p> <p>synchronized：</p> <p>在资源竞争不是很激烈的情况下，偶尔会有同步的情形下，synchronized是很合适的。原因在于，编译程序通常会尽可能的进行优化synchronize，另外可读性非常好，不管用没用过5.0多线程包的程序员都能理解。</p> <p>ReentrantLock:</p> <p>ReentrantLock提供了多样化的同步，比如有时间限制的同步，可以被Interrupt的同步（synchronized的同步是不能Interrupt的）等。在资源竞争不激烈的情形下，性能稍微比synchronized差点点。但是当同步非常激烈的时候，synchronized的性能一下子能下降好几十倍。而ReentrantLock确还能维持常态。</p> <p>Atomic:</p> <p>和上面的类似，不激烈情况下，性能比synchronized略逊，而激烈的时候，也能维持常态。激烈的时候，Atomic的性能会优于ReentrantLock一倍左右。但是其有一个缺点，就是只能同步一个值，一段代码中只能出现一个Atomic的变量，多于一个同步无效。因为他不能在多个Atomic之间同步。</p> <p>所以，我们写同步的时候，优先考虑synchronized，如果有特殊需要，再进一步优化。ReentrantLock和Atomic如果用的不好，不仅不能提高性能，还可能带来灾难。</p> <ul><li>线程和进程的概念、并行和并发的概念</li></ul> <p>并发：</p> <ul><li><p>创建线程的方式及实现</p> <p>创建线程有 4 方式:继承 Thread+实现 Runnable+实现 Callable+线程池获得</p></li> <li><p>进程间通信的方式</p></li></ul> <p>信号、文件、信号量、管道、共享内存、消息、socket</p> <ul><li><p>说说 CountDownLatch、CyclicBarrier 原理和区别</p> <table><thead><tr><th>CountDownLatch</th> <th>CyclicBarrier</th></tr></thead> <tbody><tr><td>减计数方式</td> <td>加计数方式</td></tr> <tr><td>计数为0时，无法重置</td> <td>计数达到指定值时，计数置为0重新开始</td></tr> <tr><td>不可重复利用</td> <td>可重复利用</td></tr></tbody></table></li> <li><p>说说 Semaphore 原理</p></li></ul> <p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，保证合理的使用公共资源。线程可以通过acquire()方法来获取信号量的许可，当信号量中没有可用的许可的时候，线程阻塞，直到有可用的许可为止。线程可以通过release()方法释放它持有的信号量的许可。</p> <ul><li>说说 Exchanger 原理</li></ul> <p>jdk1.5提供的，Exchanger提供的是一个交换服务，允许原子性的交换两个（多个）对象，但同时只有一对才会成功。</p> <ul><li>ThreadLocal 原理分析，ThreadLocal为什么会出现OOM，出现的深层次原理</li></ul> <p>可以私有化存储线程的变量值，每个Thread线程维护着一个ThreadLocalMap，而ThreadLocalMap中的一个键即是一个ThreadLocal，value是我们通过set方法传进去的参数。</p> <p>ThreadLocal，它作为一个key用的是弱引用</p> <p>内存泄漏归根结底是由于ThreadLocalMap的生命周期跟Thread一样长。如果没有手动删除为null的key就会导致内存泄漏。</p> <ul><li>讲讲线程池的实现原理</li></ul> <p>就是一个线程集合workerSet和一个阻塞队列workQueue。当用户向线程池提交一个任务(也就是线程)时，线程池会先将任务放入workQueue中。workerSet中的线程会不断的从workQueue中获取线程然后执行。当workQueue中没有任务的时候，worker就会阻塞，直到队列中有任务了就取出来继续执行。</p> <ul><li>线程池的几种实现方式？任务拒接策略有哪几种？</li></ul> <p>Java通过Executors提供四种线程池，分别为：
newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p> <p>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p> <p>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p> <p>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p> <ul><li>线程的生命周期，状态是如何转移的</li></ul> <p>（1）新建状态——（2）就绪状态—（3）运行状态——（4）阻塞状态——（5）死亡状态</p> <p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5eu7ehr61j30ht0chjuk.jpg" alt="img"></p> <ul><li><p>一个线程连着调用start两次会出现什么情况？</p> <p>由于状态只有就绪、阻塞、执行，状态是无法由执行转化为执行的，所以会报不合法的状态！</p> <p>Java的线程是不允许启动两次的，第二次调用必然会抛出IllegalThreadStateException，这是一种运行时异常，多次调用start被认为是编程错误。</p></li> <li><p>wait方法能不能被重写，wait能不能被中断？</p> <p>wait是final类型的，不可以被重写，不仅如此，notify和notifyall都是final类型的。可以被中断</p></li> <li><p>Object类中常见的方法，为什么wait notify会放在Object里边？</p> <p>JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p></li> <li><p>线程池，如何根据CPU的核数来设计线程大小，如果是计算机密集型的呢，如果是IO密集型的呢？</p></li> <li><p>多个线程同时读写，读线程的数量远远⼤于写线程，你认为应该如何解决并发的问题？你会选择加什么样的锁？</p> <p>（ReentrantReadWriteLock）读写锁最适用于对数据结构的读操作次数多于写操作的场合，因为，读模式锁定时可以共享，而写模式锁定时只能某个线程独占资源(解释为读模式可以共享 所以不用创建线程 多个线程共享个资源, 二写模式由单个线程独占,所以要写更多的内容则需要创建更多的线程)，因而，读写锁也可以叫做个共享-独占锁。</p></li> <li><p>线程池内的线程如果全部忙，提交⼀个新的任务，会发⽣什么？队列全部塞满了之后，还是忙，再提交会发⽣什么？</p> <p>将任务存进任务队列中 . ThreadPoolExecutor's中的submit()方法会抛出一个RejectedExecutionException异常</p></li> <li><p>synchronized关键字锁住的是什么东西？在字节码中是怎么表示的？在内存中的对象上表现为什么？</p> <p>对象，monitor.enter() monitor.exit() 标记对象头信息</p></li> <li><p>wait/notify/notifyAll⽅法需不需要被包含在synchronized块中？这是为什么？</p> <p>wait() 方法执行默认释放对象锁 所以为了同步 需要在synchronized块中</p></li></ul> <h2 id="算法"><a href="#算法" aria-hidden="true" class="header-anchor">#</a> 算法</h2> <p>不稳定的排序算法有：希尔排序，快速排序，选择排序，堆排序</p> <p>稳定的有：插入排序，冒泡排序</p> <p>快希选堆不稳，选堆归基不变</p> <p>冒择路（入）兮（希）快归堆</p> <p>冒泡：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 用来交换的临时数</span>
    <span class="token comment">// 要遍历的次数</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 从后向前依次的比较相邻两个数的大小，遍历一次后，把数组中第i小的数放在第i个位置上</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> list<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;</span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 比较相邻的元素，如果前面的数大于后面的数，则交换</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                temp <span class="token operator">=</span> list<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                list<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                list<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对冒泡排序常见的改进方法是加入标志性变量exchange，用于标志某一趟排序过程中是否有数据交换。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 对 bubbleSort 的优化算法</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bubbleSort_2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 用来交换的临时数</span>
    <span class="token keyword">boolean</span> bChange <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 交换标志</span>
    <span class="token comment">// 要遍历的次数</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        bChange <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token comment">// 从后向前依次的比较相邻两个数的大小，遍历一次后，把数组中第i小的数放在第i个位置上</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> list<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;</span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 比较相邻的元素，如果前面的数大于后面的数，则交换</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                temp <span class="token operator">=</span> list<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                list<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                list<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
                bChange <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 如果标志为false，说明本轮遍历没有交换，已经是有序数列，可以结束排序</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">false</span> <span class="token operator">==</span> bChange<span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>快速排序：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickSort</span> <span class="token punctuation">{</span>
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">int</span> pivot<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         pivot<span class="token operator">=</span><span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>left<span class="token punctuation">,</span>pivot<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>pivot<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">int</span> key<span class="token operator">=</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">&gt;=</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            right<span class="token operator">--</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
         arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>
         <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">&lt;=</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            left<span class="token operator">++</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
         arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">=</span>key<span class="token punctuation">;</span>
      <span class="token keyword">return</span> left<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/wiki/interview/java-9-微服务.html" class="prev">
          微服务
        </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/wiki/assets/js/app.dd178f5a.js" defer></script><script src="/wiki/assets/js/2.9f273a62.js" defer></script><script src="/wiki/assets/js/38.2a06b872.js" defer></script>
  </body>
</html>
