<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java基础 | JavaChen Wiki</title>
    <meta name="description" content="JavaChen Wiki">
    <link rel="icon" href="/wiki/img/logo.ico">
  <meta http-quiv="pragma" cotent="no-cache">
  <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
  <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/wiki/assets/css/0.styles.bdf32acf.css" as="style"><link rel="preload" href="/wiki/assets/js/app.dd178f5a.js" as="script"><link rel="preload" href="/wiki/assets/js/2.9f273a62.js" as="script"><link rel="preload" href="/wiki/assets/js/28.4e15bea1.js" as="script"><link rel="prefetch" href="/wiki/assets/js/10.e389070d.js"><link rel="prefetch" href="/wiki/assets/js/11.19e9f97f.js"><link rel="prefetch" href="/wiki/assets/js/12.f95e0459.js"><link rel="prefetch" href="/wiki/assets/js/13.127730fd.js"><link rel="prefetch" href="/wiki/assets/js/14.34eed2f7.js"><link rel="prefetch" href="/wiki/assets/js/15.a8cf4000.js"><link rel="prefetch" href="/wiki/assets/js/16.6346731c.js"><link rel="prefetch" href="/wiki/assets/js/17.143af375.js"><link rel="prefetch" href="/wiki/assets/js/18.7d95703a.js"><link rel="prefetch" href="/wiki/assets/js/19.8726bd0b.js"><link rel="prefetch" href="/wiki/assets/js/20.2914a04f.js"><link rel="prefetch" href="/wiki/assets/js/21.ebd751e0.js"><link rel="prefetch" href="/wiki/assets/js/22.f6801be0.js"><link rel="prefetch" href="/wiki/assets/js/23.87ecfe73.js"><link rel="prefetch" href="/wiki/assets/js/24.cabcaf93.js"><link rel="prefetch" href="/wiki/assets/js/25.306828f5.js"><link rel="prefetch" href="/wiki/assets/js/26.59450304.js"><link rel="prefetch" href="/wiki/assets/js/27.44fddb85.js"><link rel="prefetch" href="/wiki/assets/js/29.bed7cbfd.js"><link rel="prefetch" href="/wiki/assets/js/3.28138f41.js"><link rel="prefetch" href="/wiki/assets/js/30.36a67cca.js"><link rel="prefetch" href="/wiki/assets/js/31.dde8666e.js"><link rel="prefetch" href="/wiki/assets/js/32.148ea73a.js"><link rel="prefetch" href="/wiki/assets/js/33.61c937cc.js"><link rel="prefetch" href="/wiki/assets/js/34.eb7c4b0c.js"><link rel="prefetch" href="/wiki/assets/js/35.abb4ce3d.js"><link rel="prefetch" href="/wiki/assets/js/36.f03d0378.js"><link rel="prefetch" href="/wiki/assets/js/37.84491176.js"><link rel="prefetch" href="/wiki/assets/js/38.2a06b872.js"><link rel="prefetch" href="/wiki/assets/js/39.63965d3b.js"><link rel="prefetch" href="/wiki/assets/js/4.c0af9872.js"><link rel="prefetch" href="/wiki/assets/js/40.bf2e354a.js"><link rel="prefetch" href="/wiki/assets/js/41.bed53451.js"><link rel="prefetch" href="/wiki/assets/js/42.34d4f2f5.js"><link rel="prefetch" href="/wiki/assets/js/43.867c0e23.js"><link rel="prefetch" href="/wiki/assets/js/44.0201a314.js"><link rel="prefetch" href="/wiki/assets/js/45.d6f1a311.js"><link rel="prefetch" href="/wiki/assets/js/46.419d44e4.js"><link rel="prefetch" href="/wiki/assets/js/47.a3f8b595.js"><link rel="prefetch" href="/wiki/assets/js/48.574cc219.js"><link rel="prefetch" href="/wiki/assets/js/49.224dd6c4.js"><link rel="prefetch" href="/wiki/assets/js/5.c521f8b1.js"><link rel="prefetch" href="/wiki/assets/js/50.c8825040.js"><link rel="prefetch" href="/wiki/assets/js/51.2dab614a.js"><link rel="prefetch" href="/wiki/assets/js/52.8382a180.js"><link rel="prefetch" href="/wiki/assets/js/53.bfab18a9.js"><link rel="prefetch" href="/wiki/assets/js/54.87a1d37c.js"><link rel="prefetch" href="/wiki/assets/js/55.5f207671.js"><link rel="prefetch" href="/wiki/assets/js/56.f0e8e082.js"><link rel="prefetch" href="/wiki/assets/js/57.c868e5c9.js"><link rel="prefetch" href="/wiki/assets/js/6.6a737c5b.js"><link rel="prefetch" href="/wiki/assets/js/7.48bba6b4.js"><link rel="prefetch" href="/wiki/assets/js/8.26532964.js"><link rel="prefetch" href="/wiki/assets/js/9.3c4a4032.js">
    <link rel="stylesheet" href="/wiki/assets/css/0.styles.bdf32acf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/wiki/" class="home-link router-link-active"><!----> <span class="site-name">JavaChen Wiki</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/wiki/" class="nav-link">主页</a></div><div class="nav-item"><a href="/wiki/docker/" class="nav-link">Docker</a></div><div class="nav-item"><a href="/wiki/elasticsearch/" class="nav-link">Elasticsearch</a></div><div class="nav-item"><a href="/wiki/hadoop/" class="nav-link">Hadoop</a></div><div class="nav-item"><a href="/wiki/interview/" class="nav-link router-link-active">Interview</a></div><div class="nav-item"><a href="/wiki/rabbitMQ/" class="nav-link">RabbitMQ</a></div><div class="nav-item"><a href="/wiki/redis/" class="nav-link">Redis</a></div><div class="nav-item"><a href="/wiki/spring-cloud-cshop/" class="nav-link">Spring-cloud-cshop</a></div><div class="nav-item"><a href="/wiki/about.html" class="nav-link">关于</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/wiki/" class="nav-link">主页</a></div><div class="nav-item"><a href="/wiki/docker/" class="nav-link">Docker</a></div><div class="nav-item"><a href="/wiki/elasticsearch/" class="nav-link">Elasticsearch</a></div><div class="nav-item"><a href="/wiki/hadoop/" class="nav-link">Hadoop</a></div><div class="nav-item"><a href="/wiki/interview/" class="nav-link router-link-active">Interview</a></div><div class="nav-item"><a href="/wiki/rabbitMQ/" class="nav-link">RabbitMQ</a></div><div class="nav-item"><a href="/wiki/redis/" class="nav-link">Redis</a></div><div class="nav-item"><a href="/wiki/spring-cloud-cshop/" class="nav-link">Spring-cloud-cshop</a></div><div class="nav-item"><a href="/wiki/about.html" class="nav-link">关于</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Interview</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/wiki/interview/" class="sidebar-link">编程之道</a></li><li><a href="/wiki/interview/java-0-基础.html" class="active sidebar-link">Java基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/interview/java-0-基础.html#java概述" class="sidebar-link">Java概述</a></li><li class="sidebar-sub-header"><a href="/wiki/interview/java-0-基础.html#变量" class="sidebar-link">变量</a></li><li class="sidebar-sub-header"><a href="/wiki/interview/java-0-基础.html#数据类型" class="sidebar-link">数据类型</a></li><li class="sidebar-sub-header"><a href="/wiki/interview/java-0-基础.html#类" class="sidebar-link">类</a></li><li class="sidebar-sub-header"><a href="/wiki/interview/java-0-基础.html#异常" class="sidebar-link">异常</a></li></ul></li><li><a href="/wiki/interview/java-1-数据结构和算法.html" class="sidebar-link">基本概念</a></li><li><a href="/wiki/interview/java-2-JVM.html" class="sidebar-link">JVM</a></li><li><a href="/wiki/interview/java-3-线程.html" class="sidebar-link">线程</a></li><li><a href="/wiki/interview/java-4-网络编程.html" class="sidebar-link">NIO、BIO、AIO</a></li><li><a href="/wiki/interview/java-5-设计模式.html" class="sidebar-link">设计模式</a></li><li><a href="/wiki/interview/java-6-框架.html" class="sidebar-link">开源框架</a></li><li><a href="/wiki/interview/java-7-数据库.html" class="sidebar-link">数据库</a></li><li><a href="/wiki/interview/java-8-分布式.html" class="sidebar-link">分布式</a></li><li><a href="/wiki/interview/java-9-微服务.html" class="sidebar-link">微服务</a></li><li><a href="/wiki/interview/java-99-面试题目.html" class="sidebar-link">面试题目</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="java基础"><a href="#java基础" aria-hidden="true" class="header-anchor">#</a> Java基础</h1> <h2 id="java概述"><a href="#java概述" aria-hidden="true" class="header-anchor">#</a> Java概述</h2> <p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g5e80w4efbj30l40es7em.jpg" alt="img"></p> <p>JDK：Java程序开发工具包，包括JRE和开发人员使用的工具</p> <p>JRE：Java程序运行时环境，包括JVM和运行时所需要的类库</p> <p>JVM：Java运行程序的虚拟机</p> <p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g5e824ifwcj30gf0bmn1d.jpg" alt="img"></p> <p>区别：</p> <ul><li>运行一个已有程序用JRE</li> <li>开发一个全新程序用JDK</li></ul> <p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5e8181cxej30cx08swff.jpg" alt="img"></p> <p>代码编译过程</p> <ul><li>javac： javac -d . HelloWorld.java －－＞生成HelloWorld.class类文件</li> <li>java：启动虚拟机(java)，运行类文件。如：java com.work.core.HelloWorld</li></ul> <div class="language- extra-class"><pre class="language-text"><code>源文件－－－＞编译器（javac.exe）－－－＞中间码( .class)－－－＞虚拟机（java.exe）－－－＞机器指令－－－＞CPU
</code></pre></div><h2 id="变量"><a href="#变量" aria-hidden="true" class="header-anchor">#</a> 变量</h2> <p>变量：在程序运行过程中固定不变的量</p> <p>常量：</p> <ul><li>final来定义常量</li> <li>常量一旦初始化后就无法再改动</li> <li>常量名称通常使用大写字母</li> <li>必须要在常量声明的时候就对其进行初始化，否则会出现编译错误</li></ul> <p>常量分类：</p> <ul><li>字符串常量</li> <li>整数常量</li> <li>浮点数常量</li> <li>字符常量</li> <li>布尔常量</li> <li>空常量</li> <li>null</li></ul> <p>变量声明：</p> <ul><li><p>给变量起名，是给变量选择一种数据类型。如：int age；</p></li> <li><p>不同的变量：</p> <ul><li>1）参与的运算是不同的，</li> <li>2）存储的值是不同的，</li> <li>3）需要的存储空间的大小也不同</li></ul></li></ul> <p>变量：</p> <ul><li>成员变量</li> <li>局部变量</li></ul> <p>实例变量和局部变量的区别：</p> <ul><li><p>1，位置：局部变量定义在方法里面。实例变量定义在类以内方法之外。</p></li> <li><p>2，使用的范围：局部变量只能在定义他的方法里面使用，直接调用变量名就可以了。</p></li></ul> <p>​	实例变量至少可以在定义他的整个类内使用，使用时必须用对象去调用。只有跟对象一起实例变量才有意义。</p> <ul><li><p>3，局部变量使用之前必须初始化。实例变量不需要赋初值，系统会给默认的初值。</p></li> <li><p>4，局部变量在同一方法里不能重名。局部变量和实例变量可以重名，在方法里采用就近原则。</p></li></ul> <h2 id="数据类型"><a href="#数据类型" aria-hidden="true" class="header-anchor">#</a> 数据类型</h2> <h3 id="分类"><a href="#分类" aria-hidden="true" class="header-anchor">#</a> 分类</h3> <p>基本数据类型：</p> <ul><li>整数类型
<ul><li>byte：8位，最大存储数据量是255，数据范围是-128~127</li> <li>int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1</li> <li>short：16位，最大数据存储量是65536，数据范围是-32768~32767之间</li> <li>long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1</li></ul></li> <li>浮点数类型
<ul><li>float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F(1个符号，8个指数，23个尾数)</li> <li>double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加(1个符号，11个指数，52个尾数)</li></ul></li> <li>字符类型
<ul><li>char：16位，存储Unicode码，用单引号赋值，char(一个字符＝2个字节)，只能表示一个字。  如：char c='中'; c存的是‘中‘这个字的编码。</li></ul></li> <li>布尔类型
<ul><li>boolean：只有true和false两个取值</li></ul></li></ul> <p>说明：</p> <ul><li>字符串不是基本类型，而是引用类型</li> <li>浮点类型可能只是一个近视值，不是精确值</li> <li>数据范围与字节数不一定相关，例如float范围比long更广，但是float长度为4，long长度为8</li> <li>浮点数类型默认为double，整数类型模式为int</li></ul> <p><strong>引用数据类型：</strong></p> <ul><li>字符串</li> <li>数组</li> <li>类</li> <li>接口</li> <li>集合</li> <li>Lambda</li></ul> <h3 id="类型转换"><a href="#类型转换" aria-hidden="true" class="header-anchor">#</a> 类型转换</h3> <p>自动类型转换：</p> <ul><li>不需要特殊编码，自动完成</li> <li>数据范围从小到大</li> <li>char--&gt;byte--&gt;short--&gt;int--&gt;long--&gt;float--&gt;double</li></ul> <p>强制转换：</p> <ul><li>需要编码</li> <li>范围大的转换为范围小的</li> <li>损失精度，产生误差，小数点以后的数字全部舍弃</li> <li>容易超过取值范围</li></ul> <h3 id="封装类型"><a href="#封装类型" aria-hidden="true" class="header-anchor">#</a> 封装类型</h3> <ul><li>基本类型只能按值传递，而对应封装类是按引用传递的</li> <li>基本类型是在堆栈上创建的，而所有的对象类型都是在堆上创建的。</li> <li>默认值不同</li> <li>封装类的出现，是为了更方便的使用一些基本类型不具备的方法，比如valueOf()，toString()等等</li> <li>装箱时基本类型会自动封装成封装类型，拆箱时反之</li></ul> <h2 id="类"><a href="#类" aria-hidden="true" class="header-anchor">#</a> 类</h2> <h3 id="对象"><a href="#对象" aria-hidden="true" class="header-anchor">#</a> 对象</h3> <p>对象是用来描述客观存在的事物的一个实体，它是构成复杂系统的一个基本单位。一个对象由一组属性和对这组属性进行操作的一组服务组成。</p> <p>面向过程：是代码的容器。</p> <p>面向对象：对象所共有的功能和属性进行抽像，成为了类，是客观事物在人脑中的主观反映。在程序里类是创建对象的模板。</p> <h3 id="方法"><a href="#方法" aria-hidden="true" class="header-anchor">#</a> 方法</h3> <p>什么是方法？</p> <ul><li>方法是解决一类问题的步骤的有序组合</li> <li>方法包含于类或对象中</li> <li>方法在程序中被创建，在其他地方被引用</li></ul> <p>方法的优点：</p> <ul><li>使程序变得更简短而清晰</li> <li>有利于程序维护</li> <li>可以提高程序开发的效率</li> <li>提高了代码的重用性</li></ul> <p>方法的定义：</p> <div class="language- extra-class"><pre class="language-text"><code>修饰符 返回值类型 方法名(参数类型 参数名){
    ...
    方法体
    ...
    return 返回值;
}
</code></pre></div><ul><li>修饰符：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li> <li>返回值类型 ：方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字void。</li> <li>方法名：是方法的实际名称。方法名和参数表共同构成方法签名。方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头写，不使用连接符。例如：addPerson</li> <li>参数类型：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li> <li>方法体：方法体包含具体的语句，定义该方法的功能。</li></ul> <p>变量作用域</p> <ul><li>方法内定义的变量被称为局部变量。</li> <li>局部变量的作用范围从声明开始，直到包含它的块结束。</li> <li>局部变量必须声明才可以使用。</li> <li>方法的参数范围涵盖整个方法。参数实际上是一个局部变量。</li></ul> <h4 id="修饰符"><a href="#修饰符" aria-hidden="true" class="header-anchor">#</a> 修饰符</h4> <p>访问修饰符：</p> <div class="language- extra-class"><pre class="language-text"><code>	修饰符 	当前类 	同一包内 	子孙类 	其他包
	public 			Y 	Y 	Y 	Y
	protected 	Y 	Y 	Y 	N
	default 		Y 	Y 	N 	N
	private 		Y 	N 	N 	N
</code></pre></div><p>访问控制和继承：</p> <ul><li>父类中声明为 public 的方法在子类中也必须为 public。</li> <li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private</li> <li>父类中声明为 private 的方法，不能够被继承</li></ul> <p>非访问修饰符：</p> <ul><li><strong>static修饰符</strong>，用来修饰类方法和类变量。
<ul><li>静态变量：static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。</li> <li>静态方法：static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</li></ul></li> <li><strong>final修饰符</strong>，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。
<ul><li>final 变量：final 变量能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。
<ul><li>final 修饰符通常和 static 修饰符一起使用来创建类常量。</li></ul></li> <li>final 方法：类中的 final 方法可以被子类继承，但是不能被子类修改。
声明 final 方法的主要目的是防止该方法的内容被修改。</li> <li>final 类：final 类不能被继承，没有类能够继承 final 类的任何特性。</li></ul></li> <li><strong>abstract 修饰符</strong>，用来创建抽象类和抽象方法</li> <li><strong>synchronized 和 volatile 修饰符</strong>，主要用于线程的编程</li></ul> <h4 id="构造方法"><a href="#构造方法" aria-hidden="true" class="header-anchor">#</a> 构造方法</h4> <p>构造方法：</p> <ul><li><p>没有返回类型，方法名必须和类同名。</p></li> <li><p>构造方法不能手动调用，它只用在创建对象在时候，只出现在new之后。</p></li></ul> <p>​	只要构造方法被调用运行，就一定有对象产生。</p> <ul><li><p>在一个对象的生命周期里，构造方法只能被调用一次。</p></li> <li><p>类写好后一定有构造方法，</p></li></ul> <p>​	如果程序没有显示的提供构造方法，JVM会提供一个默认的构造方法，public classname(){}</p> <p>​	如果程序显示提供，系统不再提供默认的</p> <ul><li><p>同一个类的多个构造方法一定重载。</p></li> <li><p>创建对象的同时构造方法的代码块里还可以写需要运行的代码，还可以给属性（实例变量）赋值。</p></li></ul> <p>引用类型的属性赋值就是用new创建对象，然后调用构造方法。如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Student</span> stu<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>用new创建对象时JVM做的三件事：</p> <ul><li><p>1，申请空间；（把值放到空间里，再把空间的地址给引用变量。）－－－－创建父类对象</p></li> <li><p>2，初始化实例变量；没显示声明值的话就用默认值。</p></li> <li><p>3，执行构造方法，</p></li></ul> <p>因为实例变量在创建对象的过程中被初始化，所以使用实例变量前必须创建对象（要用对象去调用），否则实例变量根本不存在。</p> <h4 id="方法重载"><a href="#方法重载" aria-hidden="true" class="header-anchor">#</a> 方法重载</h4> <p>方法重载（overloading）：编译时多态。</p> <p><strong>在一个类的内部，方法名相同形参数不同的方法，对返回类型不要求</strong>，这种现象称之为重载；</p> <p>编译器会自动选择使用的方法。体现了一个<strong>编译时多态</strong>。</p> <p>好处：对使用者屏蔽因为参数不同造成方法间的差异。</p> <p>找方法时如果没有合适的，采取自动向上扩展原则。</p> <p>调用时形参之间的区别一定要明确。</p> <ul><li><p>形参的个数不同</p></li> <li><p>形参的类型不同</p></li> <li><p>形参的顺序不同</p></li> <li><p>形参的名字相同</p></li></ul> <h4 id="方法覆盖"><a href="#方法覆盖" aria-hidden="true" class="header-anchor">#</a> 方法覆盖</h4> <p>方法覆盖（override）：<strong>运行时多态</strong>。</p> <ul><li><p>1，发生在父类和子类之间</p></li> <li><p>2，方法名相同，参数相同，返回类型相同</p></li> <li><p>3，子类方法的访问权限不能更严格，只能等于或更加宽松。</p></li></ul> <h4 id="this"><a href="#this" aria-hidden="true" class="header-anchor">#</a> this</h4> <p>1，在普通方法里，指代当前对象引用（哪个对象调用该方法，this就指向该对象）</p> <p>2，this不能出现在静态方法里。</p> <p>3，在构造方法里，this用来指代本类的其他构造方法。在本类构造方法之间互相调用。如：this(形参);</p> <p>​	使用时放在构造方法里的第一行。</p> <p>4，不能写成死循环（不能递归调用）</p> <h4 id="参数传递"><a href="#参数传递" aria-hidden="true" class="header-anchor">#</a> 参数传递</h4> <p>基本类型数据传递的是本身的值，引用类型数据传递的是引用（地址，对象变量本身的值）</p> <h3 id="面向对象"><a href="#面向对象" aria-hidden="true" class="header-anchor">#</a> 面向对象</h3> <h4 id="封装"><a href="#封装" aria-hidden="true" class="header-anchor">#</a> 封装</h4> <p>封装（Encapsulation）就是隐藏所有属性和方法的实现细节，公开方法的功能。</p> <p>访问控制修饰符：public（公开的），protected（受保护的，1，本包内可见；2，其他包的子类可见）</p> <p>​				 default（默认，本包内可见），private（私有的，类内部可见）</p> <h4 id="继承"><a href="#继承" aria-hidden="true" class="header-anchor">#</a> 继承</h4> <p>继承（inheritance）：抽象出不变性。从一般到特殊的关系，可以设计成继承</p> <p><strong>对于父类里的属性和方法，子类有权访问的，我们称为可以继承</strong>。</p> <p>特点：</p> <ul><li><p>共性写在父类里面，特性写在子类</p></li> <li><p>所有类的总父类是	Object (Object是类的祖先)</p></li> <li><p>父类里写的是共性，子类里写的是特性。</p></li> <li><p>父类中用private修饰的属性和方法不能被子类继承；</p></li> <li><p>但是父类里的属性子类都有，如果子类有特殊属性的话，就要在子类里定义，且在创建该子类对象的时候初始化属性（包括父类所有属性和该子类所有属性）；</p></li></ul> <p>用new创建子类对象，JVM执行的过程：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    

<span class="token class-name">Dog</span> d<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div><ul><li><p>（1）申请空间；（把值放到空间里，再把空间的地址给引用变量。）</p></li> <li><p>（2）看本类构造方法的第一句</p></li> <li><p>（3）默认的创建父类对象：</p></li></ul> <p>​	执行顺序：子类（2）－－－＞  父类（2－－＞3－－＞4－－＞5）－－－＞   子类（4－－＞5），</p> <p>​	新建一个对象空间只申请一次（该空间存放所有父类和子类）。）</p> <ul><li><p>（4）初始化本类的实例变量（该类的所有属性）；</p></li> <li><p>（5）执行本类的构造方法，（构造方法只会在创建一个对象的时候被执行一次）</p></li></ul> <p>用super调用父类被子类覆盖的普通方法和遮盖的属性，指代的是在创建子类对象过程中，由JVM自动创建的那个父类，如：<code>super.方法名（）</code></p> <p>用super调用父类的构造方法；必须出现在子类构造方法的第一句。如：<code>super(形参);</code></p> <ul><li>1，在子类的构造方法里如果没有指明调用哪一个父类的构造方法（就是子类中没有super（形参）语句；）</li></ul> <p>​	JVM会默认调用父类的无参构造方法，跟本类构造方法的形参没有关系。</p> <ul><li><p>2，显示的写super，JVM会根据参数调用相应的父类构造方法。</p></li> <li><p>3，有this(形参)，在本类的构造方法之间调用，看被调用的那个构造方法的第一行。</p></li></ul> <h4 id="多态"><a href="#多态" aria-hidden="true" class="header-anchor">#</a> 多态</h4> <p>多态（polymorphism）：多态只有方法多态，没有属性多态。用父类类型屏蔽子类之间的差异</p> <p>所有的子类对象都可以当父类对象来用，一个父类型的引用可能指向的是一个子类对象，</p> <p>如：把狗（对象）看作动物（类型）。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Animal</span> a<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			

<span class="token comment">//（编译时类型）	（运行时类型）</span>
</code></pre></div><p>编译看前面，运行看后面。</p> <ul><li><p>1，运行时对象不会改变（对象是客观存在的），如：狗这个对象的属性和方法是不会改变的。</p></li> <li><p>2，对一个引用，只能调用编译时类型里的已知方法。</p></li></ul> <p>​	如：编译器知道动物里已有的属性和方法，但不知道狗的属性和方法。</p> <ul><li>3，运行时会根据运行时类型自动寻找覆盖过的方法运行。</li></ul> <h4 id="static"><a href="#static" aria-hidden="true" class="header-anchor">#</a> static</h4> <p>static变量：如：static int index=2;</p> <p>类的所有对象共同拥有的一个属性；可以用类名直接访问，又称为类变量，类第一次被加载时会初始化静态变量（也就是会先执行static修饰的变量）；</p> <p>跟类创建了多少对象无关；任何对象对静态变量做的修改，其他对象看到的是修改后的值。</p> <p>可以用作计数器，记录类创建对象的个数 ， static变量在类加载的时候只会被初始化一次，</p> <p>​</p> <p>static方法：如：<code>public static void teach(){}</code></p> <p>可以用类名直接去调用，不需要对象所以不能直接访问（在没有对象的情况下）实例变量，</p> <p>在静态方法里不能出现this和super，类的所有对象共同拥有的一个方法；跟类创建了多少对象无关。</p> <p>在继承里，父类的静态方法只能被子类的静态方法覆盖，且覆盖以后没有多态，（访问的是父类的静态方法）；</p> <p>static初始化块：如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Teacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> index<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>
	<span class="token keyword">static</span><span class="token punctuation">{</span>		<span class="token comment">//static初始化块</span>

	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>静态初始华块：用static修饰类里面的一个独立的代码块，类第一次被JVM加载的时候执行，只被执行一次。</p> <p>​</p> <p>类加载：JVM在第一次使用一个类时，会到classpath所指定的路径去找这个类所对应的字节码文件，并读进JVM保存起来，这个过程称之为类加载，一个线程一个jvm。</p> <h4 id="final"><a href="#final" aria-hidden="true" class="header-anchor">#</a> final</h4> <p>final类：如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>表示该类不能被继承，意味着不能改变里面的代码；</p> <p>对虚拟机的正常运行有重要作用的类通常用final修饰，如：String,System,Math ...等类</p> <p>final方法：如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>该方法不能被覆盖（修改），但能被子类访问。</p> <p>​</p> <p>final变量：如：</p> <div class="language- extra-class"><pre class="language-text"><code>final (static) int index=4;
</code></pre></div><p>该变量是常量能被继承（访问）；</p> <p>final修饰的变量就是常量，通常和static一起连用，来声明常量；</p> <p>final修饰引用类型数据，指的是引用（地址）不能变，但引用里的数据不受限制。</p> <p>final修饰的变量，只要在初始化的过程中就可以赋值。</p> <p>实例变量：声明的同时或构造方法里赋值；</p> <p>静态变量：声明的同时或在静态代码块里赋值；</p> <h4 id="abstract"><a href="#abstract" aria-hidden="true" class="header-anchor">#</a> abstract</h4> <p>abstract类：如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>抽象类，不能创建对象(如一些父类)，但是可以声明一个抽象类型的引用（可以声明父类类型子类对象，编译时利用多态调用抽象方法）。</p> <p>含有抽象方法的类一定是抽象类，但抽象类并不一定要有抽象方法；</p> <p>抽象类一般是用来被继承的；子类继承自抽象类，就要实现里面的抽象方法，</p> <p>如果不想让子类也是抽象类的话，必须实现父类里面所有的抽象方法。</p> <p>抽象类有构造方法，有父类，也遵循单继承的规律。</p> <p>​</p> <p>abstract方法：如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>抽象方法，只有方法名的定义，没有实现体（只定义了能做什么，没定义怎么做），不能被调用，</p> <p>用于被子类的方法覆盖或重新实现。只能放在抽象类中。</p> <p>好处：允许方法的定义和实现分开。</p> <p>可以：</p> <ul><li><p>public static</p></li> <li><p>private static</p></li> <li><p>public final</p></li> <li><p>public static final</p></li></ul> <p>不可以：</p> <ul><li><p>abstract final void eat();</p></li> <li><p>private abstract void eat();</p></li> <li><p>static abstract void eat();</p></li></ul> <p><strong>abstract不能和final、private、static连用。</strong></p> <h4 id="interface"><a href="#interface" aria-hidden="true" class="header-anchor">#</a> interface</h4> <p>理解为接口是一个特殊的抽象类，所以接口不能创建对象，且接口没有构造方法，</p> <p>但可以声明一个接口类型的引用，m是接口类型实现类对象，如：</p> <div class="language- extra-class"><pre class="language-text"><code>M m=new N();
</code></pre></div><p>接口存在的意义是被子类实现，如果不想让子类也抽象，就要实现接口里面所有的抽象方法，实现过程中注意访问权限；</p> <p>用  implements 关键字实现接口</p> <ul><li><p>接口里面的常量默认都是public static final的；</p></li> <li><p>接口里面的方法默认都是public abstract的。</p></li></ul> <p>​</p> <p>接口本身支持多继承，继承了父接口里功能的定义，如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">B</span><span class="token punctuation">,</span><span class="token class-name">C</span><span class="token punctuation">,</span><span class="token class-name">D</span><span class="token punctuation">{</span><span class="token punctuation">}</span>		
</code></pre></div><p>类可以同时继承一个父类和实现接口（或多个接口），如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> AA <span class="token keyword">extends</span> BB <span class="token keyword">implements</span> CC<span class="token punctuation">,</span>DD<span class="token punctuation">,</span>EE<span class="token punctuation">{</span><span class="token punctuation">}</span>		<span class="token comment">//AA，BB是类，CC，DD，EE是接口；</span>
</code></pre></div><p>作用：</p> <ul><li>用接口去实现多继承，接口是对类的共性进行再次抽象，抽象出类的次要类型。</li></ul> <p>​			如：蜘蛛侠，拥有人和蜘蛛的属性，但主要类型是人，次要类型（接口）是蜘蛛，因为接口是次要类型，所以在类关系里不占一个节点，不会破坏类层次关系的树状结构，</p> <ul><li>标准（保证弱耦合）：一个接口就是一个标准（里面的属性不能改变，只定义了功能，</li></ul> <p>但没有被实现），接口将标准的制定者，标准的实现者以及标准的使用者分离开，降低实现者和使用者的耦合。接口是java里一种重要的降低耦合的工具；接口可以屏蔽不同实现类的差异，当底层的实现类更换后，不会对上层的使用者产生影响，体现在参数和返回值。</p> <p>​</p> <p>写程序时，应该先写实现者再写使用者，如：Bank.java是实现者，View.java是使用者，但是有了接口之后，就可以用接口回调的功能；</p> <p>接口回调：</p> <ul><li><p>先定义接口，然后写使用者和实现者的顺序随便（一般是先写使用者，后写实现者）；</p></li> <li><p>利用参数把实现者传给使用者（即：实现者是使用者的属性），使用者利用接口调用实现者相应的功能。</p></li></ul> <h4 id="object"><a href="#object" aria-hidden="true" class="header-anchor">#</a> Object</h4> <p>Object是Java里所有类的直接或间接父类，Object类里面的所有功能是所有java类共有的</p> <ul><li>1，JVM调用垃圾回收器回收不用的内存（没有引用指向的对象）前运行<strong>finalize()</strong>，给JVM用的方法。</li></ul> <p>​	程序显示的通知JVM回收没用的内存（但不一定马上就回收）：<code>System.gc();</code>或  <code>Runtime.getRuntime().gc();</code></p> <ul><li><p>2，<code>toString()</code>返回对象的字符串表现形式，打印对象时，虚拟机会自动调用<code>toString</code>获取对象的字符串表现格式，如：</p> <div class="language- extra-class"><pre class="language-text"><code>System.out.println(str.toString());
System.out.println(str);
</code></pre></div></li></ul> <p>​	如果本类不提供（覆盖）<code>toString()</code>，那么使用的是Object类里的相应方法，打印的就是地址，如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token string">&quot;.....&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>3，**基本类型时，“==“判断变量本身的值是否相等；引用类型时，判断的是地址是否相等。equals判断的是对象内容是否相等。**对于自己创建的类，应该覆盖Object类的equals()方法，否则使用的是Object类里的equals()方法，比的是地址。</li></ul> <p>​	覆盖方法如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span><span class="token punctuation">{</span>  
  <span class="token keyword">if</span><span class="token punctuation">(</span>o<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>o<span class="token operator">==</span><span class="token keyword">this</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

  <span class="token keyword">final</span> <span class="token class-name">Student</span> s<span class="token operator">=</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">==</span>s<span class="token punctuation">.</span>age <span class="token punctuation">;</span>	<span class="token comment">//比较原则；</span>
<span class="token punctuation">}</span>  
</code></pre></div><p>覆盖euqals()方法时遵循的原则：</p> <ul><li>自反性：<code>a.quals(a);	//true</code></li> <li>对称性：<code>a.equals(b);＜==＞ b.equals(a);	//true</code></li> <li>传递性：<code>a.equals(b);//true 		 b.equals(c); //true －－－＞则：a.equals(c); //为true</code></li></ul> <p>​</p> <h4 id="封装类"><a href="#封装类" aria-hidden="true" class="header-anchor">#</a> 封装类</h4> <p>封装类（Wrapper class）：OverLoading时，基本类型时采用向上匹配原则，如果没有基本类型的话就向包装类转换，如果还没有就让这个基本类型在包装类里也采用向上匹配原则；</p> <p>装箱和拆箱：</p> <p>装箱：基本类型转换到－－＞包装类：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">boolean</span>－－－－－＞<span class="token class-name">Boolean</span>

<span class="token keyword">int</span>－－－－－－－－＞<span class="token class-name">Integer</span>   	<span class="token comment">//Integer是引用类型，</span>

<span class="token keyword">int</span>－－－－－－－－＞<span class="token class-name">Ddouble</span>		<span class="token comment">//合法，		但Integer－－－－－－＞Double	非法</span>

<span class="token keyword">double</span>－－－－－－＞<span class="token class-name">Double</span>


任何类型－－－－－＞<span class="token class-name">Object</span>
</code></pre></div><p>基本数据类型int可以向double自动扩展，但是包装类型之间不能自动的相互转换，举例：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>

<span class="token class-name">Integer</span> it<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//手动转换；基本类型向包装类型转换。</span>

<span class="token keyword">int</span> <span class="token operator">&lt;</span>－－－－<span class="token operator">&gt;</span> <span class="token class-name">Integer</span> <span class="token operator">&lt;</span>－－－－<span class="token operator">&gt;</span> <span class="token class-name">String</span>
</code></pre></div><p>转换时String类型必须为全数字字符串。如：&quot;2515&quot;	 不能为：&quot;abc265&quot;,&quot;aec&quot;…等。</p> <p>拆箱：</p> <h4 id="内部类"><a href="#内部类" aria-hidden="true" class="header-anchor">#</a> 内部类</h4> <p>定义在其他代码块（类体或者方法体）里的类称为内部类；编译后每一个内部类都会有自己的独立的字节码文件，</p> <p>文件名：<code>Outer$Inner.class</code>－－＞内部类也可以有父类和实现接口。也可以有抽象方法。</p> <p>根据位置和修饰符的不同分为四种：</p> <ul><li>1，member inner class	成员内部类，当实例方法或变量一样理解。
<ul><li>1）定义的位置：类以内，方法之外，没有静态修饰符（static）。</li> <li>2）本身能定义的属性和方法：只能定义非静态的属性和方法。</li> <li>3）能直接访问的什么：能访问外部类的所有静态和非静态的属性或方法。</li> <li>4）怎么创建对象：在外部类内的方法内：Outer.Inner inner=new Outer().new Inner();</li></ul></li></ul> <p>​		 在外部类外的类的方法内：Outer.Inner inner=new Outer().new Inner();或</p> <p>在Outer类里提供一个getInner()方法,返回内部类的对象，这样在外部类外的类的方法内也可以用该成员内部类。</p> <p>​</p> <ul><li>2，static inner class 	静态内部类（嵌套内部类），当静态方法或变量一样理解。static只能修饰内部类，不能修饰外部类。
<ul><li>1）定义的位置：类以内，方法之外，有静态修饰符（static）。一般写在外部类的属性下面。</li> <li>2）本身能定义的属性和方法：可以定义静态和非静态的属性或方法。</li> <li>3）能直接访问的什么：只能访问外部类的静态属性和方法。</li> <li>4）怎么创建对象：
<ul><li>在外部类内的类方法里： 	Outer.Inner inner=new Outer.Inner();</li> <li>在外部类外的类方法里：   Outer.Inner inner=new Outer.Inner();</li></ul></li></ul></li></ul> <p>​</p> <ul><li>3，local inner class 		局部内部类		当局部变量一样理解。
<ul><li>1）定义的位置：方法里面的类，前面不能用public或static修饰。</li> <li>2）本身能定义的属性和方法：只能定义非静态的属性和方法。</li> <li>3）能直接访问的什么：能访问方法内用final修饰的局部变量（不能与该类内的变量名相同）。能访问外部类的所有静态和非静态的属性或方法。</li> <li>4）怎么创建对象：只能在方法内创建对象，如：Inner inner=new Inner(); 对象的作用范围只在方法内。</li></ul></li></ul> <p>​</p> <ul><li>4，annonymous inner class		匿名内部类	如：	Teacher tc=new Teacher(){}
<ul><li>1）没有名字的类，没有构造方法。是一个特殊的局部内部类，可以实现一个接口，	或者一个类，生命周期里只能产生一个对象(tc)，也就是说只能被一个对象（tc）调用</li> <li>2）除了没有名字外，看匿名内部类所在的位置，他的定义和访问将和成员内部类、静态内部类、局部内部类一样。一般像局部内部类的定义和访问比较多。</li> <li>3）当试图创建接口或者抽象类对象的时候，用匿名内部类。表示类体的{...}紧跟在抽象实例（接口）之后，表示实现该抽象实例（接口）。调用匿名内部类的方法只能用写类时创建的那个对象（tc）。</li></ul></li></ul> <p>作用：</p> <ul><li>1，不破坏访问权限的情况下，内部类可以使用外部类的私有成员变量和方法。</li> <li>2，将接口公开，将实现类（实现公开的接口）作成内部类隐藏起来，强制要求使用者使用接口，强制降低偶合度。</li> <li>3，Java通过接口和内部类两种机制来实现多继承。在类内部可以建立本类的实例，然后调用本类内的其他方法。</li></ul> <h2 id="异常"><a href="#异常" aria-hidden="true" class="header-anchor">#</a> 异常</h2> <p>Exception(异常)：运行时的概念。</p> <p>1，Throwable：运行时可能碰到的任何问题的总称；</p> <ul><li>1）Error：指非常严重的错误，系统不要求程序员处理，也处理不了。如：硬件坏了.....等。</li> <li>2）Exception：从代码的角度是程序员可以处理的问题；
<ul><li>UncheckedException(RuntimeException 的子类) （未检查异常），程序员小心谨慎完全可以避免的异常，系统不要求程序员处理（可以不管,运行会提示错误），如：3/0数组下标越界。</li> <li>CheckedExcepiton   （已检查异常），系统要求必须处理异常。</li></ul></li></ul> <p>2，异常处理：异常是相对于方法来说的。</p> <p><strong>1）声明抛出异常（消极的处理）</strong>，throws（抛弃）：写在方法名的定义上，后面跟要抛弃的异常类型，如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>异常产生时，责任可能并不在当前方法，向外抛弃（把异常抛弃，留给调用者处理）可以让异常找到一个最佳的位置处理。</p> <p>抛弃过程中可以对异常类型进行扩展，但是不能缩小。</p> <p>throw（抛出）：一般出现在方法实现里，用来抛出异常对象（或者是产生异常），如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">FileNotFoundException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>当代码出现异常时，代码不会向下执行，JVM会将异常封装成相应的异常类的对象，然后向外抛出。之后这个方法里剩下的代码就不会再执行了。</p> <p>​</p> <p>对于一个方法的返回值：</p> <ul><li>1）正常运行时，要求方法必须返回定义的类型的值。</li> <li>2）如果运行不正常（出现异常），方法返回的是异常对象</li></ul> <p>方法覆盖：名相同，参数相同，返回类型相同，访问权限不能更小，子类抛弃的异常不能比父类更多。</p> <p><strong>2）try....catch（积极的处理）</strong>：一个try语句后可以跟多个catch语句；catch时异常子类放上面，异常父类放下面。</p> <p>如果没有父子关系，先后无所谓</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token function">method1</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">try</span><span class="token punctuation">{</span>
    <span class="token comment">//可能会出现异常的代码</span>
    xxxxxxxxxx<span class="token punctuation">;</span>	 （<span class="token number">1</span>）
    xxxxxxxxxx<span class="token punctuation">;</span>	 （<span class="token number">2</span>）
  <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception1</span> e1<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//当try代码块出现异常时,执行catch代码块。</span>
    xxxxxxxxx<span class="token punctuation">;</span>	 （<span class="token number">3</span>）
  <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception2</span> e2<span class="token punctuation">)</span><span class="token punctuation">{</span>
 	 	xxxxxxxxx<span class="token punctuation">;</span>	 （<span class="token number">4</span>）
  <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>
    <span class="token comment">//不管有没有异常出现都要执行的代码。</span>
    xxxxxxxxx<span class="token punctuation">;</span>	 （<span class="token number">5</span>）
  <span class="token punctuation">}</span>
  xxxxxxxxx<span class="token punctuation">;</span>	 （<span class="token number">6</span>）
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p>1）如果（1），（2）没产生异常，（2）执行后直接执行（5），然后执行（6）。</p></li> <li><p>2）如果（1）产生异常，（2）不会被执行，直接跑出try{..},匹配catch，和catch里定义的类型一致，</p></li></ul> <p>执行catch完了后，直接跳到（5）执行，最后再执行（6）,如果异常类型都不一致，将导至语法问题。</p> <p><strong>3）自定义异常类型（业务异常</strong>）：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">MyException</span> <span class="token keyword">extends</span> <span class="token class-name">Exception</span><span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token class-name">MyException</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">super</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/wiki/interview/" class="prev router-link-active">
          编程之道
        </a></span> <span class="next"><a href="/wiki/interview/java-1-数据结构和算法.html">
          基本概念
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/wiki/assets/js/app.dd178f5a.js" defer></script><script src="/wiki/assets/js/2.9f273a62.js" defer></script><script src="/wiki/assets/js/28.4e15bea1.js" defer></script>
  </body>
</html>
