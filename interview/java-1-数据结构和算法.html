<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>基本概念 | JavaChen Wiki</title>
    <meta name="description" content="JavaChen Wiki">
    <link rel="icon" href="/wiki/img/logo.ico">
  <meta http-quiv="pragma" cotent="no-cache">
  <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
  <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/wiki/assets/css/0.styles.bdf32acf.css" as="style"><link rel="preload" href="/wiki/assets/js/app.dd178f5a.js" as="script"><link rel="preload" href="/wiki/assets/js/2.9f273a62.js" as="script"><link rel="preload" href="/wiki/assets/js/29.bed7cbfd.js" as="script"><link rel="prefetch" href="/wiki/assets/js/10.e389070d.js"><link rel="prefetch" href="/wiki/assets/js/11.19e9f97f.js"><link rel="prefetch" href="/wiki/assets/js/12.f95e0459.js"><link rel="prefetch" href="/wiki/assets/js/13.127730fd.js"><link rel="prefetch" href="/wiki/assets/js/14.34eed2f7.js"><link rel="prefetch" href="/wiki/assets/js/15.a8cf4000.js"><link rel="prefetch" href="/wiki/assets/js/16.6346731c.js"><link rel="prefetch" href="/wiki/assets/js/17.143af375.js"><link rel="prefetch" href="/wiki/assets/js/18.7d95703a.js"><link rel="prefetch" href="/wiki/assets/js/19.8726bd0b.js"><link rel="prefetch" href="/wiki/assets/js/20.2914a04f.js"><link rel="prefetch" href="/wiki/assets/js/21.ebd751e0.js"><link rel="prefetch" href="/wiki/assets/js/22.f6801be0.js"><link rel="prefetch" href="/wiki/assets/js/23.87ecfe73.js"><link rel="prefetch" href="/wiki/assets/js/24.cabcaf93.js"><link rel="prefetch" href="/wiki/assets/js/25.306828f5.js"><link rel="prefetch" href="/wiki/assets/js/26.59450304.js"><link rel="prefetch" href="/wiki/assets/js/27.44fddb85.js"><link rel="prefetch" href="/wiki/assets/js/28.4e15bea1.js"><link rel="prefetch" href="/wiki/assets/js/3.28138f41.js"><link rel="prefetch" href="/wiki/assets/js/30.36a67cca.js"><link rel="prefetch" href="/wiki/assets/js/31.dde8666e.js"><link rel="prefetch" href="/wiki/assets/js/32.148ea73a.js"><link rel="prefetch" href="/wiki/assets/js/33.61c937cc.js"><link rel="prefetch" href="/wiki/assets/js/34.eb7c4b0c.js"><link rel="prefetch" href="/wiki/assets/js/35.abb4ce3d.js"><link rel="prefetch" href="/wiki/assets/js/36.f03d0378.js"><link rel="prefetch" href="/wiki/assets/js/37.84491176.js"><link rel="prefetch" href="/wiki/assets/js/38.2a06b872.js"><link rel="prefetch" href="/wiki/assets/js/39.63965d3b.js"><link rel="prefetch" href="/wiki/assets/js/4.c0af9872.js"><link rel="prefetch" href="/wiki/assets/js/40.bf2e354a.js"><link rel="prefetch" href="/wiki/assets/js/41.bed53451.js"><link rel="prefetch" href="/wiki/assets/js/42.34d4f2f5.js"><link rel="prefetch" href="/wiki/assets/js/43.867c0e23.js"><link rel="prefetch" href="/wiki/assets/js/44.0201a314.js"><link rel="prefetch" href="/wiki/assets/js/45.d6f1a311.js"><link rel="prefetch" href="/wiki/assets/js/46.419d44e4.js"><link rel="prefetch" href="/wiki/assets/js/47.a3f8b595.js"><link rel="prefetch" href="/wiki/assets/js/48.574cc219.js"><link rel="prefetch" href="/wiki/assets/js/49.224dd6c4.js"><link rel="prefetch" href="/wiki/assets/js/5.c521f8b1.js"><link rel="prefetch" href="/wiki/assets/js/50.c8825040.js"><link rel="prefetch" href="/wiki/assets/js/51.2dab614a.js"><link rel="prefetch" href="/wiki/assets/js/52.8382a180.js"><link rel="prefetch" href="/wiki/assets/js/53.bfab18a9.js"><link rel="prefetch" href="/wiki/assets/js/54.87a1d37c.js"><link rel="prefetch" href="/wiki/assets/js/55.5f207671.js"><link rel="prefetch" href="/wiki/assets/js/56.f0e8e082.js"><link rel="prefetch" href="/wiki/assets/js/57.c868e5c9.js"><link rel="prefetch" href="/wiki/assets/js/6.6a737c5b.js"><link rel="prefetch" href="/wiki/assets/js/7.48bba6b4.js"><link rel="prefetch" href="/wiki/assets/js/8.26532964.js"><link rel="prefetch" href="/wiki/assets/js/9.3c4a4032.js">
    <link rel="stylesheet" href="/wiki/assets/css/0.styles.bdf32acf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/wiki/" class="home-link router-link-active"><!----> <span class="site-name">JavaChen Wiki</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/wiki/" class="nav-link">主页</a></div><div class="nav-item"><a href="/wiki/docker/" class="nav-link">Docker</a></div><div class="nav-item"><a href="/wiki/elasticsearch/" class="nav-link">Elasticsearch</a></div><div class="nav-item"><a href="/wiki/hadoop/" class="nav-link">Hadoop</a></div><div class="nav-item"><a href="/wiki/interview/" class="nav-link router-link-active">Interview</a></div><div class="nav-item"><a href="/wiki/rabbitMQ/" class="nav-link">RabbitMQ</a></div><div class="nav-item"><a href="/wiki/redis/" class="nav-link">Redis</a></div><div class="nav-item"><a href="/wiki/spring-cloud-cshop/" class="nav-link">Spring-cloud-cshop</a></div><div class="nav-item"><a href="/wiki/about.html" class="nav-link">关于</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/wiki/" class="nav-link">主页</a></div><div class="nav-item"><a href="/wiki/docker/" class="nav-link">Docker</a></div><div class="nav-item"><a href="/wiki/elasticsearch/" class="nav-link">Elasticsearch</a></div><div class="nav-item"><a href="/wiki/hadoop/" class="nav-link">Hadoop</a></div><div class="nav-item"><a href="/wiki/interview/" class="nav-link router-link-active">Interview</a></div><div class="nav-item"><a href="/wiki/rabbitMQ/" class="nav-link">RabbitMQ</a></div><div class="nav-item"><a href="/wiki/redis/" class="nav-link">Redis</a></div><div class="nav-item"><a href="/wiki/spring-cloud-cshop/" class="nav-link">Spring-cloud-cshop</a></div><div class="nav-item"><a href="/wiki/about.html" class="nav-link">关于</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Interview</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/wiki/interview/" class="sidebar-link">编程之道</a></li><li><a href="/wiki/interview/java-0-基础.html" class="sidebar-link">Java基础</a></li><li><a href="/wiki/interview/java-1-数据结构和算法.html" class="active sidebar-link">基本概念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/interview/java-1-数据结构和算法.html#二分查找" class="sidebar-link">二分查找</a></li><li class="sidebar-sub-header"><a href="/wiki/interview/java-1-数据结构和算法.html#map接口" class="sidebar-link">Map接口</a></li><li class="sidebar-sub-header"><a href="/wiki/interview/java-1-数据结构和算法.html#abstractmap类" class="sidebar-link">AbstractMap类</a></li><li class="sidebar-sub-header"><a href="/wiki/interview/java-1-数据结构和算法.html#hashmap" class="sidebar-link">HashMap</a></li><li class="sidebar-sub-header"><a href="/wiki/interview/java-1-数据结构和算法.html#原理-2" class="sidebar-link">原理</a></li><li class="sidebar-sub-header"><a href="/wiki/interview/java-1-数据结构和算法.html#_1-7与1-8中的不同" class="sidebar-link">1.7与1.8中的不同</a></li><li class="sidebar-sub-header"><a href="/wiki/interview/java-1-数据结构和算法.html#arraylist-和-linkedlist-区别" class="sidebar-link">ArrayList 和 LinkedList 区别?</a></li><li class="sidebar-sub-header"><a href="/wiki/interview/java-1-数据结构和算法.html#hashmap-和-hashtable-区别" class="sidebar-link">HashMap 和 HashTable 区别?</a></li><li class="sidebar-sub-header"><a href="/wiki/interview/java-1-数据结构和算法.html#set-接口" class="sidebar-link">Set 接口</a></li><li class="sidebar-sub-header"><a href="/wiki/interview/java-1-数据结构和算法.html#list-和-set-区别" class="sidebar-link">List 和 Set 区别</a></li></ul></li><li><a href="/wiki/interview/java-2-JVM.html" class="sidebar-link">JVM</a></li><li><a href="/wiki/interview/java-3-线程.html" class="sidebar-link">线程</a></li><li><a href="/wiki/interview/java-4-网络编程.html" class="sidebar-link">NIO、BIO、AIO</a></li><li><a href="/wiki/interview/java-5-设计模式.html" class="sidebar-link">设计模式</a></li><li><a href="/wiki/interview/java-6-框架.html" class="sidebar-link">开源框架</a></li><li><a href="/wiki/interview/java-7-数据库.html" class="sidebar-link">数据库</a></li><li><a href="/wiki/interview/java-8-分布式.html" class="sidebar-link">分布式</a></li><li><a href="/wiki/interview/java-9-微服务.html" class="sidebar-link">微服务</a></li><li><a href="/wiki/interview/java-99-面试题目.html" class="sidebar-link">面试题目</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="基本概念"><a href="#基本概念" aria-hidden="true" class="header-anchor">#</a> 基本概念</h1> <p>逻辑结构分为：</p> <ul><li>集合</li> <li>线性结构</li> <li>树形结构</li> <li>图状结构</li></ul> <p>存储结构分为：</p> <ul><li>顺序</li> <li>链式</li> <li>索引</li> <li>散列</li></ul> <p>数据运算：在数据的逻辑结构上定义的操作，它在数据的存储结构上实现。</p> <ul><li>插入</li> <li>删除</li> <li>修改</li> <li>查找</li> <li>排序</li></ul> <p>常见的数据结构：</p> <ul><li>线性表</li> <li>栈</li> <li>队列</li> <li>树</li> <li>图</li></ul> <p>算法具有以下特点：</p> <ul><li>输入：算法具有0个或者多个输入</li> <li>输出：至少有一个或多个输出</li> <li>有穷性：算法在有限的步骤之后会自动结束，而不会无限循环</li> <li>确定性：算法中的 每一步都有确定的含义，不会产生歧义</li> <li>可行性：算法的每一步都是可行的</li></ul> <p>算法的时间复杂度：</p> <ul><li>算法效率严重依赖于操作数量</li> <li>在判断是首先关注操作数量的最高次项</li> <li>操作数量的估算可以作为时间复杂度的估算</li></ul> <p>去掉表示算法运行时间中的低阶项和首相常数，就是度量算法的渐进时间复杂度，简称时间复杂度，通常用O表示。例如：遍历一个数组长度为n的数组，时间复杂度为O(N)。</p> <p>算法的空间复杂度：为了解决问题的实例而执行的操作所需要的存储空间的数目，但是它不包括用来存储输入实例的空间。算法的空间复杂度是通过计算算法的存储空间实现，同样用O来表示。</p> <p>时间与空间的策略：</p> <ul><li>多数情况下，算法执行时所用的时间更令人关注</li> <li>如果有必要，可以通过增加空间复杂度来降低时间复杂度</li> <li>可以通过时间复杂度降低空间复杂度</li></ul> <p>算法复杂度分析：</p> <ul><li>计算循环次数</li> <li>分析最高频度的基本操作</li> <li>最佳、最坏和平均情况分析</li> <li>均摊分析</li></ul> <h1 id="算法"><a href="#算法" aria-hidden="true" class="header-anchor">#</a> 算法</h1> <h2 id="二分查找"><a href="#二分查找" aria-hidden="true" class="header-anchor">#</a> 二分查找</h2> <p>二分查找的条件：</p> <ul><li>序列必须支持随机访问</li> <li>序列中的元素必须有序</li></ul> <p>实例：</p> <ul><li><p>1、定义变量low和high，分别指向起始和人末尾位置</p></li> <li><p>2、根据low和high计算出位于两者中间的索引</p></li> <li><p>3、将mid位置上的元素与要找的元素进行比较</p> <ul><li>相等：表示已找到目标元素，返回当前索引mid</li> <li>比目标值小：可排除左边一半的元素，把low值赋值为mid+1后转到第二步</li> <li>比目标值大：可排除又边一半的元素，把high值赋值为mid-1后转到第二步</li></ul></li> <li><p>4、重复执行2、3步，直到找到目标元素。若直到low大于high时仍未找到，则表示目标元素不存在</p></li></ul> <p>代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> low<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>hight<span class="token operator">=</span>arr<span class="token punctuation">.</span>lenth<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> mid<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span><span class="token punctuation">{</span>
		mid<span class="token operator">=</span>low<span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span>hight<span class="token operator">-</span>low<span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>v<span class="token punctuation">)</span><span class="token punctuation">{</span>
			low<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&gt;</span>v<span class="token punctuation">)</span><span class="token punctuation">{</span>
			high<span class="token operator">=</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
			<span class="token keyword">return</span> mid<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g63xtoxbnfj315e0n8qhi.jpg" alt="image-20190818170135166"></p> <h1 id="线性表"><a href="#线性表" aria-hidden="true" class="header-anchor">#</a> 线性表</h1> <p>顺序表的顺序存储是用一组地址连续的存储单元依次存储线性表的数据元素。</p> <h3 id="数组"><a href="#数组" aria-hidden="true" class="header-anchor">#</a> 数组</h3> <p>在<strong>内存中是一串连续的空间</strong>。</p> <h3 id="链表"><a href="#链表" aria-hidden="true" class="header-anchor">#</a> 链表</h3> <p>链表是一系列的存储数据元素的单元通过指针串接起来形成的，因此每个单元至少有两个域，一个用于数据元素的存储，一个是指向其他单元的指针。</p> <p>链表在内存中是不连续的。</p> <p>链表分为：单链表，双向链表、环形链表。</p> <h4 id="常见算法"><a href="#常见算法" aria-hidden="true" class="header-anchor">#</a> 常见算法</h4> <h5 id="判断环形链表"><a href="#判断环形链表" aria-hidden="true" class="header-anchor">#</a> 判断环形链表</h5> <ul><li>暴力枚举，判断尾结点的next为空</li> <li>引入一个set，将遍历过的节点保存起来，再判断next节点是否在set存在</li> <li>快慢指针</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code>public boolean isLoop<span class="token punctuation">(</span>Node head<span class="token punctuation">)</span><span class="token punctuation">{</span>
	Node slow<span class="token operator">=</span>head<span class="token punctuation">;</span>
	Node fast<span class="token operator">=</span>head<span class="token punctuation">;</span>
	while<span class="token punctuation">(</span>fast<span class="token operator">!=</span>null <span class="token operator">&amp;&amp;</span> fast.next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
		slow<span class="token operator">=</span>slow.next<span class="token punctuation">;</span>
		fast<span class="token operator">=</span>fast.next.next<span class="token punctuation">;</span>
		if<span class="token punctuation">(</span>slow<span class="token operator">=</span>fast<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="反转链表"><a href="#反转链表" aria-hidden="true" class="header-anchor">#</a> 反转链表</h5> <ul><li>两个指针，依次往后移动</li> <li>递归</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">reverserLinkedList</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token class-name">Node</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token class-name">Node</span> post <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   post <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
   head<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>
   pre <span class="token operator">=</span> head<span class="token punctuation">;</span>
   head <span class="token operator">=</span> post<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">reverserLinkedList</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span><span class="token keyword">null</span><span class="token operator">||</span>head<span class="token punctuation">.</span>next<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> head<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token class-name">Node</span> last<span class="token operator">=</span><span class="token function">reverserLinkedList</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
  head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token operator">=</span>head<span class="token punctuation">;</span>
  head<span class="token punctuation">.</span>next<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> last<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h5 id="约瑟夫环"><a href="#约瑟夫环" aria-hidden="true" class="header-anchor">#</a> 约瑟夫环</h5> <p>有n个人站成环从1开始报数，报k的人去死，之后下一个人报1，问当你是第几个的时候可以活下来?</p> <p>f(n,k)=(f(n-1,k)+k)%n</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> <span class="token function">cir</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> p<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        p<span class="token operator">=</span><span class="token punctuation">(</span>p<span class="token operator">+</span>k<span class="token punctuation">)</span><span class="token operator">%</span>i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h1 id="散列表"><a href="#散列表" aria-hidden="true" class="header-anchor">#</a> 散列表</h1> <p>散列表</p> <p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g63vx4yok8j31eg0t01kx.jpg" alt="image-20190818155542014"></p> <p>基本概念</p> <p>![image-20190818155652532](../../../../../Library/Application Support/typora-user-images/image-20190818155652532.png)</p> <p>散列函数：</p> <p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g63vzjzawgj317k0n6tl1.jpg" alt="image-20190818155801163"></p> <h4 id="hash冲突解决方案"><a href="#hash冲突解决方案" aria-hidden="true" class="header-anchor">#</a> Hash冲突解决方案</h4> <p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g63w3ates1j31ce0pu19q.jpg" alt="image-20190818160137749"></p> <p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g63w7x18r8j31c80pqqjr.jpg" alt="image-20190818160603706"></p> <p>链表</p> <p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g63wba5qupj315y0q2qid.jpg" alt="image-20190818160917760"></p> <p>暴雪哈希：</p> <p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g63wcmknvdj31d00qa7p1.jpg" alt="image-20190818161034995"></p> <p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g63whoa72mj31dm0pu1fh.jpg" alt="image-20190818161526046"></p> <p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g63wippr0lj31c80oeh2g.jpg" alt="image-20190818161625818"></p> <p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g63wjz45l7j31c60pudwy.jpg" alt="image-20190818161739061"></p> <p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g63wp1q26qj31bc0oah45.jpg" alt="image-20190818162231509"></p> <p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g63wqdi5pqj31de0ni1g6.jpg" alt="image-20190818162347922"></p> <p>哈希数</p> <p>布谷鸟哈希</p> <p>局部敏感哈希LSH</p> <p>minHash</p> <p>simHash</p> <h1 id="布隆过滤器"><a href="#布隆过滤器" aria-hidden="true" class="header-anchor">#</a> 布隆过滤器</h1> <p>位图：</p> <p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g63wysvk4oj31dq0oiaod.jpg" alt="image-20190818163153782"></p> <p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g63x7c2507j31cq0peqj3.jpg" alt="image-20190818164005968"></p> <p>布隆过滤器</p> <p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g63x9ighuzj31ck0poh8y.jpg" alt="image-20190818164211272"></p> <p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g63xc2y846j318c0n8and.jpg" alt="image-20190818164439760"></p> <p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g63xd69oofj31e40piwtm.jpg" alt="image-20190818164542645"></p> <p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g63xdnlq0cj31d40pkqq2.jpg" alt="image-20190818164610709"></p> <h1 id="集合"><a href="#集合" aria-hidden="true" class="header-anchor">#</a> 集合</h1> <h2 id="map接口"><a href="#map接口" aria-hidden="true" class="header-anchor">#</a> Map接口</h2> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">boolean</span> <span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">boolean</span> <span class="token function">containsValue</span><span class="token punctuation">(</span><span class="token class-name">Object</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">V</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">putAll</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> <span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token class-name">Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">default</span> <span class="token class-name">V</span> <span class="token function">getOrDefault</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> defaultValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">V</span> v<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token operator">?</span> v
            <span class="token operator">:</span> defaultValue<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">BiConsumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> <span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">K</span> k<span class="token punctuation">;</span> <span class="token class-name">V</span> v<span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                k <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                v <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">IllegalStateException</span> ise<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// this usually means the entry is no longer in the map.</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span>ise<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            action<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token class-name">BiFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">V</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> function<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>function<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> <span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">K</span> k<span class="token punctuation">;</span>
            <span class="token class-name">V</span> v<span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                k <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                v <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">IllegalStateException</span> ise<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// this usually means the entry is no longer in the map.</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span>ise<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token comment">// ise thrown from function is not a cme.</span>
            v <span class="token operator">=</span> function<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                entry<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">IllegalStateException</span> ise<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// this usually means the entry is no longer in the map.</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span>ise<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">default</span> <span class="token class-name">V</span> <span class="token function">putIfAbsent</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">V</span> v <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            v <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> v<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Object</span> curValue <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>curValue<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">||</span>
            <span class="token punctuation">(</span>curValue <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
  
  <span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">replace</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> oldValue<span class="token punctuation">,</span> <span class="token class-name">V</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Object</span> curValue <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>curValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span> <span class="token operator">||</span>
            <span class="token punctuation">(</span>curValue <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
  
  <span class="token keyword">default</span> <span class="token class-name">V</span> <span class="token function">replace</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">V</span> curValue<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>curValue <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            curValue <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> curValue<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">default</span> <span class="token class-name">V</span> <span class="token function">computeIfAbsent</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> mappingFunction<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       
  <span class="token punctuation">}</span>

  <span class="token keyword">default</span> <span class="token class-name">V</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span>
                    <span class="token class-name">BiFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">V</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> remappingFunction<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  
  <span class="token keyword">default</span> <span class="token class-name">V</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span>
            <span class="token class-name">BiFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">V</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">V</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> remappingFunction<span class="token punctuation">)</span> 
<span class="token punctuation">}</span>  
</code></pre></div><p>1、利用Java8新特性添加了接口的默认方法</p> <p>2、添加了函数方法foreach、computeIfAbsent、compute、merge</p> <h2 id="abstractmap类"><a href="#abstractmap类" aria-hidden="true" class="header-anchor">#</a> AbstractMap类</h2> <p>1、构造方法protected</p> <p>2、添加了两个变量：</p> <div class="language- extra-class"><pre class="language-text"><code>transient Set&lt;K&gt;        keySet;
transient Collection&lt;V&gt; values;
</code></pre></div><p>3、实现了默认的一些方法</p> <p>4、抽象方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="hashmap"><a href="#hashmap" aria-hidden="true" class="header-anchor">#</a> HashMap</h2> <h3 id="原理"><a href="#原理" aria-hidden="true" class="header-anchor">#</a> 原理</h3> <p>​		HashMap中通过一个Node&lt;K,V&gt;[]数组来保存添加到map中的键值对，而在同一个数组位置是通过链表和红黑树的形式来保存的。但是这个数组只有在第一次添加元素的时候才会初始化，否则只是初始化一个ConcurrentHashMap对象的话，只是设定了一个sizeCtl变量，这个变量用来判断对象的一些状态和是否需要扩容</p> <p>​		第一次添加元素的时候，默认初期长度为16，当往map中继续添加元素的时候，通过hash值跟数组长度取与来决定放在数组的哪个位置，如果出现放在同一个位置的时候，优先以链表的形式存放，在同一个位置的个数又达到了8个以上，如果数组的长度还小于64的时候，则会扩容数组。如果数组的长度大于等于64了的话，在会将该节点的链表转换成树。</p> <p>通过扩容数组的方式来把这些节点给分散开。然后将这些元素复制到扩容后的新的数组中，同一个链表中的元素通过hash值的数组长度位来区分，是还是放在原来的位置还是放到扩容的长度的相同位置去 。在扩容完成之后，如果某个节点的是树，同时现在该节点的个数又小于等于6个了，则会将该树转为链表。</p> <p>取元素的时候，相对来说比较简单，通过计算hash来确定该元素在数组的哪个位置，然后在通过遍历链表或树来判断key和key的hash，取出value值。</p> <h3 id="类的定义："><a href="#类的定义：" aria-hidden="true" class="header-anchor">#</a> 类的定义：</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span> 
</code></pre></div><p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g5fj9j0z5qj31qi0rg0z0.jpg" alt=""></p> <h3 id="重要参数"><a href="#重要参数" aria-hidden="true" class="header-anchor">#</a> 重要参数</h3> <p>HashMap中的主要参数 同JDK1.7，即： 容量，加载因子，扩容阀值
但由于JDK1.8后引入了红黑树，所以多了红黑树相关的参数。具体如下</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/** 
* 主要参数 同  JDK 1.7 
* 即：容量、加载因子、扩容阈值（要求、范围均相同）
*/</span>

<span class="token comment">// 1. 容量（capacity）： 必须是2的幂 &amp; &lt;最大容量（2的30次方）</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// 默认容量 = 16 = 1&lt;&lt;4 = 00001中的1向左移4位 = 10000 = 十进制的2^4=16</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token comment">// 最大容量 =  2的30次方（若传入的容量过大，将被最大值替换）</span>

<span class="token comment">// 2. 加载因子(Load factor)：HashMap在其容量自动增加前可达到多满的一种尺度 </span>
<span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span> <span class="token comment">// 实际加载因子</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span> <span class="token comment">// 默认加载因子 = 0.75</span>

<span class="token comment">// 3. 扩容阈值（threshold）：当哈希表的大小 ≥ 扩容阈值时，就会扩容哈希表（即扩充HashMap的容量） </span>
<span class="token comment">// a. 扩容 = 对哈希表进行resize操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数</span>
<span class="token comment">// b. 扩容阈值 = 容量 x 加载因子</span>
<span class="token keyword">int</span> threshold<span class="token punctuation">;</span>

<span class="token comment">// 4. 其他</span>
<span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>  <span class="token comment">// 存储数据的Node类型 数组，长度 = 2的幂；数组的每个元素 = 1个单链表</span>
<span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token comment">// HashMap的大小，即 HashMap中存储的键值对的数量</span>


<span class="token comment">/** 
* 与红黑树相关的参数
*/</span>
<span class="token comment">// 1. 桶的树化阈值：即 链表转成红黑树的阈值，在存储数据时，当链表长度 &gt; 该值时，则将链表转换成红黑树</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span> 
<span class="token comment">// 2. 桶的链表还原阈值：即 红黑树转为链表的阈值，当在扩容（resize（））时（此时HashMap的数据存储位置会重新计算），在重新计算存储位置后，当原有的红黑树内数量 &lt; 6时，则将 红黑树转换成链表</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
<span class="token comment">// 3. 最小树形化容量阈值：即 当哈希表中的容量 &gt; 该值时，才允许树形化链表 （即 将链表 转换成红黑树）</span>
<span class="token comment">// 否则，若桶内元素太多时，则直接扩容，而不是树形化</span>
<span class="token comment">// 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>
</code></pre></div><p>初始容量是16</p> <p>最大容量是2的30次方</p> <p>扩展因子是0.75</p> <p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g5fjerl47hj30z509pn07.jpg" alt=""></p> <p>内部存储结构：</p> <p><img src="https://upload-images.jianshu.io/upload_images/2059840-8386849414328b14.png" alt="img"></p> <h3 id="使用红黑树的改进"><a href="#使用红黑树的改进" aria-hidden="true" class="header-anchor">#</a> 使用红黑树的改进</h3> <p>在 java jdk8 中对 HashMap 的源码进行了优化，在 jdk7 中，HashMap 处理 “碰撞” 的时候，都是采用链表来存储，当碰撞的结点很多时，查询时间是 O(n)。
在 jdk8 中，HashMap 处理 “碰撞” 增加了红黑树这种数据结构，当碰撞结点较少时，采用链表存储，当较大时（&gt;8 个），采用红黑树（特点是查询时间是 O(logn)）存储（有一个阀值控制，大于阀值 (8 个)，将链表存储转换成红黑树存储）</p> <p>问题分析：
哈希碰撞会对 hashMap 的性能带来灾难性的影响。如果多个 hashCode() 的值落到同一个桶内的时候，这些值是存储到一个链表中的。最坏的情况下，所有的 key 都映射到同一个桶中，这样 hashmap 就退化成了一个链表——查找时间从 O(1) 到 O(n)。</p> <p>随着 HashMap 的大小的增长，get() 方法的开销也越来越大。由于所有的记录都在同一个桶里的超长链表内，平均查询一条记录就需要遍历一半的列表。
JDK1.8HashMap 的红黑树是这样解决的：
如果某个桶中的记录过大的话（当前是 TREEIFY_THRESHOLD = 8），HashMap 会动态的使用一个专门的 treemap 实现来替换掉它。这样做的结果会更好，是 O(logn)，而不是糟糕的 O(n)。</p> <p>它是如何工作的？前面产生冲突的那些 KEY 对应的记录只是简单的追加到一个链表后面，这些记录只能通过遍历来进行查找。但是超过这个阈值后 HashMap 开始将列表升级成一个二叉树，使用哈希值作为树的分支变量，如果两个哈希值不等，但指向同一个桶的话，较大的那个会插入到右子树里。如果哈希值相等，HashMap 希望 key 值最好是实现了 Comparable 接口的，这样它可以按照顺序来进行插入。这对 HashMap 的 key 来说并不是必须的，不过如果实现了当然最好。如果没有实现这个接口，在出现严重的哈希碰撞的时候，你就并别指望能获得性能提升了。</p> <h3 id="插入数据"><a href="#插入数据" aria-hidden="true" class="header-anchor">#</a> 插入数据</h3> <p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5fjj33xztj30q30rsabz.jpg" alt=""></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>hash(key)：计算传入数据的哈希码（哈希值、Hash值），该函数在JDK 1.7 和 1.8 中的实现不同，但原理一样 = 扰动函数 = 使得根据key生成的哈希码（hash值）分布更加均匀、更具备随机性，避免出现hash值冲突（即指不同key但生成同1个hash值）</p> <p>JDK 1.7实现：将 键key 转换成 哈希码（hash值）操作  = 使用hashCode() + 4次位运算 + 5次异或运算（9次扰动）</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  h <span class="token operator">^=</span> k<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>JDK 1.8实现：将 键key 转换成 哈希码（hash值）操作 = 使用hashCode() + 1次位运算 + 1次异或运算（2次扰动）</p> <ol><li>取hashCode值： h = key.hashCode()</li> <li>高位参与低位的运算：h ^ (h &gt;&gt;&gt; 16)</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> h<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// a. 当key = null时，hash值 = 0，所以HashMap的key 可为null      </span>
<span class="token comment">// 注：对比HashTable，HashTable对key直接hashCode（），若key为null时，会抛出异常，所以HashTable的key不可为null</span>
<span class="token comment">// b. 当key ≠ null时，则通过先计算出 key的 hashCode()（记为h），然后 对哈希码进行扰动处理： 按位异或（^）哈希码自身右移16位后的二进制</span>
<span class="token punctuation">}</span>
</code></pre></div><p>JDK 1.7计算存储位置的函数分析</p> <p>注：该函数仅存在于JDK 1.7 ，JDK 1.8中实际上无该函数（直接用1条语句判断写出），但原理相同为了方便讲解，故提前到此讲解</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
	<span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token comment">// 将对哈希码扰动处理后的结果 与运算(&amp;) （数组长度-1），最终得到存储在数组table的位置（即数组下标、索引）</span>
<span class="token punctuation">}</span>
</code></pre></div><p>实际上这部分代码在jdk8中也有：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>
               <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token comment">//计算数组中存放位置</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            e <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st</span>
                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                p <span class="token operator">=</span> e<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// existing mapping for key</span>
            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>
        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5fk2oaq64j30ms0b10v1.jpg" alt=""></p> <p>计算示意图
<img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5fk2zw8oqj30t00fk0w4.jpg" alt="在这里插入图片描述"></p> <p>​		Map初始化长度16减去1等于15，就是二进制的1111</p> <p>在了解如何计算存放数组table中的位置后，下面讲解为什么要这样计算，即主要回答以下3个问题</p> <ol><li>为什么不直接采用经过hashCode（）处理的哈希码作为存储数组table的下标位置？</li> <li>为什么采用哈希码<strong>与运算（&amp;）</strong>（数组长度-1）计算数组下标？</li> <li>为什么在计算数组下标前，需对哈希码进行二次处理：扰动处理 ？
在回答这三个问题前，请大家记住一个核心思想：</li></ol> <p><strong>所有处理的根本目的，都是为了提高存储key-value的数组下标位置的随机性&amp;分布均匀性，尽量避免出现hash值冲突。即对于不同key，存储位置的数组下标尽量一样</strong></p> <p><strong>问题1: 为什么不直接采用经过hashCode（）处理的哈希码作为存储数组table的下标位置？</strong></p> <p>结论： 容易出现哈希码 与 数组大小范围不匹配的情况，即计算出来的哈希码可能不在数组大小范围内，从而导致无法匹配存储位置</p> <p><strong>问题2：为什么采用哈希码</strong>与运算（&amp;）<strong>（数组长度-1）计算数组下标？</strong></p> <p>结论：根据HashMap的容量大小（数组长度），按需取哈希码一定数量的低位作为存储的数组下标位置，从而解决“哈希码与数组大小范围不匹配”的问题</p> <p><strong>问题3:为什么在计算数组下标前，需对哈希码进行二次处理：扰动处理 ？</strong></p> <p>加大哈希码低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突具体描述</p> <p><strong>putVal</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
     * 分析2：putVal(hash(key), key, value, false, true)
     */</span>
     <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>
               <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>

            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>

        <span class="token comment">// 1. 若哈希表的数组tab为空，则 通过resize() 创建</span>
        <span class="token comment">// 所以，初始化哈希表的时机 = 第1次调用put函数时，即调用resize() 初始化创建</span>
        <span class="token comment">// 关于resize（）的源码分析将在下面讲解扩容时详细分析，此处先跳过</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>

        <span class="token comment">// 2. 计算插入存储的数组索引i：根据键值key计算的hash值 得到</span>
        <span class="token comment">// 此处的数组下标计算方式 = i = (n - 1) &amp; hash，同JDK 1.7中的indexFor（），上面已详细描述</span>

        <span class="token comment">// 3. 插入时，需判断是否存在Hash冲突：</span>
        <span class="token comment">// 若不存在（即当前table[i] == null），则直接在该数组位置新建节点，插入完毕</span>
        <span class="token comment">// 否则，代表存在Hash冲突，即当前存储位置已存在节点，则依次往下判断：a. 当前位置的key是否与需插入的key相同、b. 判断需插入的数据结构是否为红黑树 or 链表</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// newNode(hash, key, value, null)的源码 = new Node&lt;&gt;(hash, key, value, next)</span>

    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>

        <span class="token comment">// a. 判断 table[i]的元素的key是否与 需插入的key一样，若相同则 直接用新value 覆盖 旧value</span>
        <span class="token comment">// 判断原则：equals（）</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            e <span class="token operator">=</span> p<span class="token punctuation">;</span>

        <span class="token comment">// b. 继续判断：需插入的数据结构是否为红黑树 or 链表</span>
        <span class="token comment">// 若是红黑树，则直接在树中插入 or 更新键值对</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">-&gt;</span><span class="token operator">&gt;</span>分析<span class="token number">3</span>

        <span class="token comment">// 若是链表,则在链表中插入 or 更新键值对</span>
        <span class="token comment">// i.  遍历table[i]，判断Key是否已存在：采用equals（） 对比当前遍历节点的key 与 需插入数据的key：若已存在，则直接用新value 覆盖 旧value</span>
        <span class="token comment">// ii. 遍历完毕后仍无发现上述情况，则直接在链表尾部插入数据</span>
        <span class="token comment">// 注：新增节点后，需判断链表长度是否&gt;8（8 = 桶的树化阈值）：若是，则把链表转换为红黑树</span>
        
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 对于ii：若数组的下1个位置，表示已到表尾也没有找到key值相同节点，则新建节点 = 插入节点</span>
                <span class="token comment">// 注：此处是从链表尾插入，与JDK 1.7不同（从链表头插入，即永远都是添加到数组的位置，原来数组位置的数据则往后移）</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                    <span class="token comment">// 插入节点后，若链表节点&gt;数阈值，则将链表转换为红黑树</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> 
                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 树化操作</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token comment">// 对于i</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>

                <span class="token comment">// 更新p指向下一个节点，继续遍历</span>
                p <span class="token operator">=</span> e<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 对i情况的后续操作：发现key已存在，直接用新value 覆盖 旧value &amp; 返回旧value</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 替换旧值时会调用的方法（默认实现为空）</span>
            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>

    <span class="token comment">// 插入成功后，判断实际存在的键值对数量size &gt; 最大容量threshold</span>
    <span class="token comment">// 若 &gt; ，则进行扩容 -&gt;&gt;分析4（但单独讲解，请直接跳出该代码块）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>
        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 插入成功时会调用的方法（默认实现为空）</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token comment">/**
     * 分析3：putTreeVal(this, tab, hash, key, value)
     * 作用：向红黑树插入 or 更新数据（键值对）
     * 过程：遍历红黑树判断该节点的key是否与需插入的key 相同：
     *      a. 若相同，则新value覆盖旧value
     *      b. 若不相同，则插入
     */</span>
<span class="token keyword">final</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span>
                               <span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token class-name">K</span> k<span class="token punctuation">,</span> <span class="token class-name">V</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> kc <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">boolean</span> searched <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> root <span class="token operator">=</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> root<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> dir<span class="token punctuation">,</span> ph<span class="token punctuation">;</span> <span class="token class-name">K</span> pk<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ph <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">&gt;</span> h<span class="token punctuation">)</span>
      dir <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ph <span class="token operator">&lt;</span> h<span class="token punctuation">)</span>
      dir <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pk <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> k <span class="token operator">||</span> <span class="token punctuation">(</span>k <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> k<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>pk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> p<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>kc <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
              <span class="token punctuation">(</span>kc <span class="token operator">=</span> <span class="token function">comparableClassFor</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">||</span>
             <span class="token punctuation">(</span>dir <span class="token operator">=</span> <span class="token function">compareComparables</span><span class="token punctuation">(</span>kc<span class="token punctuation">,</span> k<span class="token punctuation">,</span> pk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>searched<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> q<span class="token punctuation">,</span> ch<span class="token punctuation">;</span>
        searched <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> p<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
             <span class="token punctuation">(</span>q <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> k<span class="token punctuation">,</span> kc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">||</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
             <span class="token punctuation">(</span>q <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> k<span class="token punctuation">,</span> kc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token keyword">return</span> q<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      dir <span class="token operator">=</span> <span class="token function">tieBreakOrder</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> pk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> xp <span class="token operator">=</span> p<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span>dir <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> p<span class="token punctuation">.</span>left <span class="token operator">:</span> p<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> xpn <span class="token operator">=</span> xp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
      <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">newTreeNode</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> k<span class="token punctuation">,</span> v<span class="token punctuation">,</span> xpn<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>dir <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        xp<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">;</span>
      <span class="token keyword">else</span>
        xp<span class="token punctuation">.</span>right <span class="token operator">=</span> x<span class="token punctuation">;</span>
      xp<span class="token punctuation">.</span>next <span class="token operator">=</span> x<span class="token punctuation">;</span>
      x<span class="token punctuation">.</span>parent <span class="token operator">=</span> x<span class="token punctuation">.</span>prev <span class="token operator">=</span> xp<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>xpn <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>xpn<span class="token punctuation">)</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> x<span class="token punctuation">;</span>
      <span class="token function">moveRootToFront</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token function">balanceInsertion</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>初始化哈希表的时机 = 第1次调用put函数时，即调用resize() 初始化创建</p> <p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g5fk8qmyqmj30tg1dqaf3.jpg" alt="img"></p> <p><strong>扩容机制</strong></p> <p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g5fkjjkxeoj30u01g846z.jpg" alt="img"></p> <p><strong>JDK1.8扩容时，数据存储位置重新计算的方式</strong></p> <p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g5fkm8ixerj31re0oojxw.jpg" alt="å¨è¿éæå¥å¾çæè¿°"></p> <p>结论示意图
<img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5fkngu452j30oq0futbn.jpg" alt="在这里插入图片描述">数组位置转换的示意图
<img src="http://ww3.sinaimg.cn/large/006tNc79gy1g5fkng0vewj315m0imaaw.jpg" alt="在这里插入图片描述">JDK1.8根据此结论作出的新元素存储位置计算规则非常简单：JDK1.7在扩容后，都需按照原来方法重新计算，即
<strong>hashCode() -&gt;&gt;扰动处理 -&gt;&gt;(h &amp; (length-1)</strong></p> <p><strong>总结</strong>
添加数据的流程
<img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5fknzm3i2j30rs19gtej.jpg" alt="在这里插入图片描述">
与JDK1.7的区别
<img src="http://ww2.sinaimg.cn/large/006tNc79gy1g5fknysbn9j30z50lejvh.jpg" alt="在这里插入图片描述"></p> <h3 id="获取数据"><a href="#获取数据" aria-hidden="true" class="header-anchor">#</a> 获取数据</h3> <p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5fkois0sfj30640ge0ta.jpg" alt="img"></p> <h3 id="与jdk1-7的区别"><a href="#与jdk1-7的区别" aria-hidden="true" class="header-anchor">#</a> <strong>与JDK1.7的区别</strong></h3> <p>JDk1.8的优化目的主要是：减少Hash冲突 &amp; 提高哈希表的存，取效率</p> <h3 id="其他问题"><a href="#其他问题" aria-hidden="true" class="header-anchor">#</a> <strong>其他问题</strong></h3> <p><strong>HashMap 的实现原理</strong></p> <p>HashMap 是典型的空间换时间的一种技术手段。</p> <ul><li>如何解决 hash 冲突</li> <li>loadFactor 等核心概念</li> <li>扩容机制</li></ul> <p><strong>哈希表如何解决Hash冲突</strong> <img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5fkrjzy8hj31do0run2d.jpg" alt="在这里插入图片描述"></p> <p><strong>为什么HashMap具备下述特点：键-值（key-value）都允许为空，线程不安全，不保证有序，储存位置随时间变化</strong> <img src="http://ww3.sinaimg.cn/large/006tNc79gy1g5fkrtdt5wj30wa0f8q49.jpg" alt="在这里插入图片描述"></p> <p>在扩容resize（）过程中，在将旧数组上的数据转移到新数组上时，<strong>转移数据操作 = 按旧链表的正序遍历链表，在新链表的头部依次插入</strong>，即在转移数据，扩容后，容易出现<strong>链表逆序的情况</strong></p> <p>由于JDK1.8转移数据操作 = 按旧链表的正序遍历链表，在新链表的尾部依次插入，所以不会出现链表逆序，倒置的情况，故不容易出现环形链表的情况</p> <p>如果 key 为 null，则直接从哈希表的第一个位置 table[0] 对应的链表上查找,由 putForNullKey（）实现。记住，key 为 null 的键值对永远都放在以 table[0] 为头结点的链表中。</p> <p><strong>为什么 HashMap 是线程不安全的，实际会如何体现？</strong></p> <p>第一，如果多个线程同时使用 put 方法添加元素
假设正好存在两个 put 的 key 发生了碰撞 (hash 值一样)，那么根据 HashMap 的实现，这两个 key 会添加到数组的同一个位置，这样最终就会发生其中一个线程的 put 的数据被覆盖。</p> <p>第二，如果多个线程同时检测到元素个数超过数组大小 * loadFactor
这样会发生多个线程同时对 hash 数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给 table，也就是说其他线程的都会丢失，并且各自线程 put 的数据也丢失。且会引起死循环的错误。</p> <p><strong>为什么HashMap中的String，Integer这样的包装类适合作为key</strong> <img src="http://ww1.sinaimg.cn/large/006tNc79gy1g5fktzz7q1j31e80f8wh4.jpg" alt="在这里插入图片描述"></p> <p><strong>HashMap中的key若Object类型，则需实现哪些方法？</strong> <img src="http://ww2.sinaimg.cn/large/006tNc79gy1g5fku6x8t5j31ii0k0acx.jpg" alt="在这里插入图片描述"></p> <p><strong>HashTable 和 HashMap 的区别有哪些？</strong></p> <p>HashMap 和 Hashtable 都实现了 Map 接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步 (synchronization)，以及速度。</p> <p>理解 HashMap 是 Hashtable 的轻量级实现（非线程安全的实现，hashtable 是非轻量级，线程安全的），都实现 Map 接口，主要区别在于：</p> <ol><li><p>由于 HashMap 非线程安全，在只有一个线程访问的情况下，效率要高于 HashTable</p></li> <li><p>HashMap 允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。</p></li> <li><p>HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsValue 和 containsKey。因为 contains 方法容易让人引起误解。</p></li> <li><p>Hashtable 继承自陈旧的 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map 的一个实现。</p></li> <li><p>Hashtable 和 HashMap 扩容的方法不一样，HashTable 中 hash 数组默认大小 11，扩容方式是 old*2+1。HashMap 中 hash 数组的默认大小是 16，而且一定是 2 的指数，增加为原来的 2 倍，没有加 1。</p></li> <li><p>两者通过 hash 值散列到 hash 表的算法不一样，HashTbale 是古老的除留余数法，直接使用 hashcode，而后者是强制容量为 2 的幂，重新根据 hashcode 计算 hash 值，在使用 hash 位与 （hash 表长度 – 1），也等价取膜，但更加高效，取得的位置更加分散，偶数，奇数保证了都会分散到。前者就不能保证。</p></li> <li><p>另一个区别是 HashMap 的迭代器 (Iterator) 是 fail-fast 迭代器，而 Hashtable 的 enumerator 迭代器不是 fail-fast 的。所以当有其它线程改变了 HashMap 的结构（增加或者移除元素），将会抛出 ConcurrentModificationException，但迭代器本身的 remove() 方法移除元素则不会抛出 ConcurrentModificationException 异常。但这并不是一个一定发生的行为，要看 JVM。这条同样也是 Enumeration 和 Iterator 的区别。
fail-fast 和 iterator 迭代器相关。如果某个集合对象创建了 Iterator 或者 ListIterator，然后其它的线程试图 “结构上” 更改集合对象，将会抛出 ConcurrentModificationException 异常。但其它线程可以通过 set() 方法更改集合对象是允许的，因为这并没有从 “结构上” 更改集合。但是假如已经从结构上进行了更改，再调用 set() 方法，将会抛出 IllegalArgumentException 异常。
结构上的更改指的是删除或者插入一个元素，这样会影响到 map 的结构。</p> <p>该条说白了就是在使用迭代器的过程中有其他线程在结构上修改了 map，那么将抛出ConcurrentModificationException，这就是所谓 fail-fast 策略。</p></li></ol> <h1 id="concurrenthashmap"><a href="#concurrenthashmap" aria-hidden="true" class="header-anchor">#</a> ConcurrentHashMap</h1> <h2 id="原理-2"><a href="#原理-2" aria-hidden="true" class="header-anchor">#</a> 原理</h2> <p>利用 ==CAS + synchronized== 来保证并发更新的安全
底层使用==数组+链表+红黑树==来实现</p> <h4 id="put过程描述"><a href="#put过程描述" aria-hidden="true" class="header-anchor">#</a> put过程描述</h4> <p>假设table已经初始化完成，put操作采用==CAS+synchronized==实现并发插入或更新操作：
- 当前bucket为空时，使用CAS操作，将Node放入对应的bucket中。
- 出现hash冲突，则采用synchronized关键字。</p> <h2 id="_1-7与1-8中的不同"><a href="#_1-7与1-8中的不同" aria-hidden="true" class="header-anchor">#</a> 1.7与1.8中的不同</h2> <table><thead><tr><th>项目</th> <th>JDK1.7</th> <th>JDK1.8</th></tr></thead> <tbody><tr><td>概览</td> <td><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g5flj9rprfj30ba0c20ti.jpg" alt="img"></td> <td><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g5fljfri3ij30bq07gwf3.jpg" alt="è¿éåå¾çæè¿°"></td></tr> <tr><td>同步机制</td> <td>分段锁，每个segment继承ReentrantLock</td> <td>CAS + synchronized保证并发更新</td></tr> <tr><td>存储结构</td> <td>数组+链表</td> <td>数组+链表+红黑树</td></tr> <tr><td>键值对</td> <td>HashEntry</td> <td>Node</td></tr> <tr><td>put操作</td> <td>多个线程同时竞争获取同一个segment锁，获取成功的线程更新map；失败的线程尝试多次获取锁仍未成功，则挂起线程，等待释放锁</td> <td>访问相应的bucket时，使用sychronizeded关键字，防止多个线程同时操作同一个bucket，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；更新了节点数量，还要考虑扩容和链表转红黑树</td></tr> <tr><td>size实现</td> <td>统计每个Segment对象中的元素个数，然后进行累加，但是这种方式计算出来的结果并不一样的准确的。先采用不加锁的方式，连续计算元素的个数，最多计算3次：如果前后两次计算结果相同，则说明计算出来的元素个数是准确的；如果前后两次计算结果都不同，则给每个Segment进行加锁，再计算一次元素的个数</td> <td>通过累加baseCount和CounterCell数组中的数量，即可得到元素的总个数；</td></tr></tbody></table> <p><strong>ConcurrentHashMap能完全替代HashTable吗？</strong>
hash table虽然性能上不如ConcurrentHashMap，但并不能完全被取代，两者的迭代器的一致性不同的，hash table的迭代器是强一致性的，而concurrenthashmap是弱一致的。 ConcurrentHashMap的get，clear，iterator 都是弱一致性的。
下面是大白话的解释：</p> <ul><li>Hashtable的任何操作都会把整个表锁住，是阻塞的。好处是总能获取最实时的更新，比如说线程A调用putAll写入大量数据，期间线程B调用get，线程B就会被阻塞，直到线程A完成putAll，因此线程B肯定能获取到线程A写入的完整数据。坏处是所有调用都要排队，效率较低。</li> <li>ConcurrentHashMap 是设计为非阻塞的。在更新时会局部锁住某部分数据，但不会把整个表都锁住。同步读取操作则是完全非阻塞的。好处是在保证合理的同步前提下，效率很高。坏处 是严格来说读取操作不能保证反映最近的更新。例如线程A调用putAll写入大量数据，期间线程B调用get，则只能get到目前为止已经顺利插入的部分 数据。</li></ul> <p>选择哪一个，是在性能与数据一致性之间权衡。ConcurrentHashMap适用于追求性能的场景，大多数线程都只做insert/delete操作，对读取数据的一致性要求较低。</p> <h1 id="collection"><a href="#collection" aria-hidden="true" class="header-anchor">#</a> Collection</h1> <p>Collection</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
	 <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">boolean</span> <span class="token function">containsAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">boolean</span> <span class="token function">removeAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">boolean</span> <span class="token function">retainAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  
   <span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">removeIf</span><span class="token punctuation">(</span><span class="token class-name">Predicate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> filter<span class="token punctuation">)</span>
	 <span class="token keyword">default</span> <span class="token class-name">Spliterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">spliterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	 <span class="token keyword">default</span> <span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	 <span class="token keyword">default</span> <span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">parallelStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>List：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
 	<span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">boolean</span> <span class="token function">containsAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">boolean</span> <span class="token function">removeAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	 
	 <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token class-name">E</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">int</span> <span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token class-name">ListIterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token class-name">ListIterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">subList</span><span class="token punctuation">(</span><span class="token keyword">int</span> fromIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> toIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>

	 <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token class-name">UnaryOperator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> operator<span class="token punctuation">)</span>
	 <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span>
	 
	 <span class="token keyword">default</span> <span class="token class-name">Spliterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">spliterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>AbstractCollection:</p> <p>AbstractList:</p> <p>ArrayList</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
        <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">RandomAccess</span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span><span class="token class-name">Serializable</span>
</code></pre></div><p>初始容量为10，1.5倍扩容。线程不安全。</p> <p>LinkedList</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">extends</span> <span class="token class-name">AbstractSequentialList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span><span class="token class-name">Serializable</span>
</code></pre></div><p>底层使用的双向链表结构，有一个头结点和一个尾结点，双向链表意味着我们可以从头开始正向遍历，或者是从尾开始逆向遍历，并且可以针对头部和尾部进行相应的操作。</p> <p>HashSet</p> <p>HashSet底层是基于HashMap 或者 LinkedHashMap实现的，所以HashSet数据结构就是HashMap或者LinkedHashMap的数据结构</p> <h2 id="arraylist-和-linkedlist-区别"><a href="#arraylist-和-linkedlist-区别" aria-hidden="true" class="header-anchor">#</a> ArrayList 和 LinkedList 区别?</h2> <p>ArrayList 基于数组实现，LinkedList 基于链表实现，ArrayList 增加和删除比 LinkedList 慢，但是 LinkedList 在查找的时需要递归查找，效 率比 ArrayList 慢。</p> <p>ArrayList默认初始化数组容量为10，通常建议使用2的次幂作为初始化容量大小，因为计算机分配空间大都使用次幂去分配，减少碎片空间。</p> <p>初始化ArrayList时，给一个初始化大小，相比较一个默认的ArrayList，添加元素会更快一些。</p> <p>数组扩容：</p> <p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g6316kssu8j311c0tqdra.jpg" alt="image-20190817221208852"></p> <ul><li>新增数据的时候需要判断当前空间是否有空闲空间（原来数组大小的两倍）存储数据。</li> <li>扩容需要申请新的连续空闲空间</li> <li>把老的数组复制过去</li> <li>添加新内容</li> <li>回收老的数组空间</li></ul> <p>链表：不需要连续内存空间，大小不定</p> <p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g6316tzqasj31180s6dom.jpg" alt="image-20190817221227034"></p> <p>时间复杂度对比：</p> <p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g6317livuyj30he0gcwh1.jpg" alt="image-20190817221310819"></p> <p>同样查找都是O(N)，数组遍历比链表快：因为数组的连续内存，会有一部分货全部数据一起进入到CPU缓存，而链表还有去内存中根据上下表查找。CPU缓存比内存快太多。</p> <p>小结：</p> <p>数组大小固定，不适合动态存储，动态添加，内存为一连续的地址，可以随机访问，查询较快，而链表大小可变，扩展性强，只能顺着指针的方向查询，速度较慢</p> <p>应用：</p> <p>数组：有序数组、无序数组、多维数组、矩阵</p> <p>链表：单链表、双向链表、循环链表、双向循环链表等等</p> <h2 id="hashmap-和-hashtable-区别"><a href="#hashmap-和-hashtable-区别" aria-hidden="true" class="header-anchor">#</a> HashMap 和 HashTable 区别?</h2> <p>HashMap结构：</p> <p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g631ewrzxpj30x40pc48y.jpg" alt="image-20190817222012681"></p> <p>1、Hashtable 是基于陈旧的 Dictionary 类的，HashMap 是 Java 1.2 引 进的 Map 接口的一个实现</p> <p>2、Hashtable 的方法是同步的，而 HashMap 的方法不是，因此</p> <p>HashTable 是线程安全的，但是代码的执行效率上要慢于 HashMap。</p> <p>3、HashMap 允许空值和空键，但是 HashTable 不可以。</p> <p>4、HashMap 非同步实现 Map 接口，是一个“链表数组”的数据结构， 最大承载量是 16，可以自动变长，由 Entry[]控制(key，value，next)， hashCode()判断 key 是否重复。</p> <p>5、建议需要做同步，使用 ConcurrentHashMap，降低了锁的粒度。在 hashMap 的基础上，ConcurrentHashMap 将数据分为多个 segment， 默认 16 个(concurrency level)，然后每次操作对一个 segment 加锁， 避免多线程锁得几率，提高并发效率。这里在并发读取时，除了 key 对应的 value 为 null 之外，并没有使用锁。</p> <h3 id="常见问题"><a href="#常见问题" aria-hidden="true" class="header-anchor">#</a> 常见问题</h3> <h4 id="_1、环形链表"><a href="#_1、环形链表" aria-hidden="true" class="header-anchor">#</a> 1、环形链表</h4> <p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g631jpzj6aj30xe0ho0z1.jpg" alt="image-20190817222449906"></p> <h4 id="_2、弥补措施"><a href="#_2、弥补措施" aria-hidden="true" class="header-anchor">#</a> 2、弥补措施</h4> <ul><li>扩容顺序：1.7 是先扩容后增加元素，1.8是增加元素后扩容</li> <li>插入顺序：1.7 是插入头部的，1.8中是插入尾部的</li></ul> <p>3、其他问题</p> <p>并发下其他问题：</p> <ul><li>并发操作，扩容时，老表允许插入，新插入的对象在迁移对象中没有，会造成数据丢失</li> <li>并发操作，每个线程都会建立新表对象然后往共享变量赋值，会造成其他线程的新表数据丢失</li> <li>并发操作，导致链表头部数据被覆盖，数据丢失</li></ul> <p>5、算法题目</p> <h2 id="set-接口"><a href="#set-接口" aria-hidden="true" class="header-anchor">#</a> <strong>Set</strong> 接口</h2> <p>1、HashSet 是 Set 接口的典型实现，HashSet 按 hash 算法来存储元 素，因此具有很好的存取和查找性能。</p> <p>特点：不能保证元素的排列顺 序，顺序有可能发生变化;HashSet 是异步的;集合元素值可以是 null; 当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode()方法来得到该对象的 hashCode 值，然后根据该 HashCode 值来确定该对象在 HashSet 中存储的位置。HashSet 还有 一个子类LinkedHashSet，其集合也是根据元素 hashCode 值来决定 元素的存储位置，但它同时用链表来维护元素的次序，这样使得元素 看起来是以插入的顺序保存的，也就是说，当遍历 LinkedHashSet 集 合元素时，它将会按元素的添加顺序来访问集合里的元素。所以 LinkedHashSet 的性能略低于 HashSet，但在迭代访问全部元素时将 有很好的性能，因为它以链表来维护内部顺序。</p> <p>2、TreeSet 是 SortSet 接口的唯一实现，TreeSet 可以确保集合元素处 于排序状态。TreeSet 不是根据元素插入顺序进行排序的，而是根据 元素的值来排序的。TreeSet 支持两种排序方法:自然排序和定制排 序。</p> <p>3、EnumSet 中所有值都必须是指定枚举类型的值，它的元素也是有序 的，以枚举值在枚举类的定义顺序来决定集合元素的顺序。EnumSet 集合不允许加入 null 元素，否则会抛出 NullPointerException 异常。 EnumSet 类没有暴露任何构造器来创建该类的实例，程序应该通过它提供的 static 方法来创建 EnumSet 对象。</p> <p>4、总结:
A、HashSet 的性能比 Treeset 好，因为 TreeSet 需要额外的红黑树算 法来维护集合元素的次序，只有当需要一个保持排序的 Set 时，才会 用 TreeSet。
B、EnumSet 是性能最好的，但它只能保存枚举值。</p> <p>C、它们都是线程不安全的。</p> <p>注：Set 是一种不包含重复的元素的 Collection，即任意的两个元素 e1 和 e2 都有 e1.equals(e2)=false，Set 最多有一个 null 元素。</p> <p>关于 HashSet，条目数和容量之和来讲，迭代是线性的。因此，如果 迭代性能很重要，那就应该慎重选择一个适当的初始容量。容量选得 太大，既浪费空间，也浪费时间。默认的初试容量是 101，一般来讲， 它比你所需要的要多。可以使用 int 构造函数来指定初始容量。要分 配 HashSet 的初始容量为 17:</p> <div class="language- extra-class"><pre class="language-text"><code>Set s=new HashSet(17);
</code></pre></div><p>HashSet 另有一个称作装载因数(load factor)的&quot;调整参数(tuning parameter)&quot;。</p> <p>区别:</p> <p>1、HashSet 是通过 HashMap 实现的，TreeSet 是通过 TreeMap 实现 的，只不过 Set 用的只是 Map 的 key。</p> <p>2、Map 的 key 和 Set 都有一个共同的特性就是集合的唯一 性。TreeMap 更是多了一个排序的功能。</p> <p>3、hashCode 和 equal()是 HashMap 用的，因为无需排序所以只需要关注定位和唯一性即可。
a. hashCode 是用来计算 hash 值的，hash 值是用来确定 hash 表索引的。
b. hash 表中的一个索引处存放的是一张链表， 所以还要通过 equal 方法循环比较链上的每一个对象才可以真正定位到键值对应的 Entry。</p> <p>c. put时，如果hash表中没定位到,就在链表前加一个Entry，如果 定位到了,则更换 Entry 中的 value,并返回旧 value。</p> <p>4、由于 TreeMap 需要排序，所以需要一个 Comparator 为键值进行 大小比较。当然也是用 Comparator 定位的.。</p> <p>a. Comparator 可以在创建 TreeMap 时指定</p> <p>b. 如果创建时没有确定，那么就会使用 key.compareTo()方法，这就要求 key 必须实现 Comparable 接口。
TreeMap 是使用 Tree 数据结构实现的,所以使用 compare 接口就可 以完成定位了。</p> <h2 id="list-和-set-区别"><a href="#list-和-set-区别" aria-hidden="true" class="header-anchor">#</a> List 和 Set 区别</h2> <ul><li>Set和hashCode以及equals方法的联系</li> <li>Set内存放的元素为什么不可以重复，内部是如何保证和实现的？</li> <li>List 和 Map 区别</li> <li>ArrayList 与 Vector 区别</li></ul> <p>首先看这两类都实现List接口，而List接口一共有三个实现类，分别是ArrayList、Vector和LinkedList。List用于存放多个元素，能够维护元素的次序，并且允许元素的重复。3个具体实现类的相关区别如下：</p> <p>ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</p> <p>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。</p> <p>LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</p> <p>vector是线程（Thread）同步（Synchronized）的，所以它也是线程安全的，而Arraylist是线程异步（ASynchronized）的，是不安全的。如果不考虑到线程的安全因素，一般用Arraylist效率比较高。</p> <p>如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度</p> <p>的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。</p> <p>如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，都是0(1),这个时候使用vector和arraylist都可以。而</p> <p>如果移动一个指定位置的数据花费的时间为0(n-i)n为总长度，这个时候就应该考虑到使用Linkedlist,因为它移动一个指定位置的数据</p> <p>所花费的时间为0(1),而查询一个指定位置的数据时花费的时间为0(i)。</p> <p>ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，</p> <p>都允许直接序号索引元素，但是插入数据要设计到数组元素移动 等内存操作，所以索引数据快插入数据慢，</p> <p>Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差</p> <p>LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快！</p> <p>笼统来说：</p> <p>LinkedList：增删改快</p> <p>​        ArrayList：查询快（有索引的存在）</p> <ul><li><p>HashSet 和 HashMap 区别</p></li> <li><p>Java Collections和Arrays的sort方法默认的排序方法是什么；</p></li> <li><p>说一下TreeMap的实现原理？红黑树的性质？红黑树遍历方式有哪些？如果key冲突如何解决？setColor()方法在什么时候用？什么时候会进行旋转和颜色转换？</p></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/wiki/interview/java-0-基础.html" class="prev">
          Java基础
        </a></span> <span class="next"><a href="/wiki/interview/java-2-JVM.html">
          JVM
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/wiki/assets/js/app.dd178f5a.js" defer></script><script src="/wiki/assets/js/2.9f273a62.js" defer></script><script src="/wiki/assets/js/29.bed7cbfd.js" defer></script>
  </body>
</html>
