<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Docker 网络 | JavaChen Wiki</title>
    <meta name="description" content="JavaChen Wiki">
    <link rel="icon" href="/wiki/img/logo.ico">
  <meta http-quiv="pragma" cotent="no-cache">
  <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
  <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/wiki/assets/css/0.styles.bdf32acf.css" as="style"><link rel="preload" href="/wiki/assets/js/app.dd178f5a.js" as="script"><link rel="preload" href="/wiki/assets/js/2.9f273a62.js" as="script"><link rel="preload" href="/wiki/assets/js/14.34eed2f7.js" as="script"><link rel="prefetch" href="/wiki/assets/js/10.e389070d.js"><link rel="prefetch" href="/wiki/assets/js/11.19e9f97f.js"><link rel="prefetch" href="/wiki/assets/js/12.f95e0459.js"><link rel="prefetch" href="/wiki/assets/js/13.127730fd.js"><link rel="prefetch" href="/wiki/assets/js/15.a8cf4000.js"><link rel="prefetch" href="/wiki/assets/js/16.6346731c.js"><link rel="prefetch" href="/wiki/assets/js/17.143af375.js"><link rel="prefetch" href="/wiki/assets/js/18.7d95703a.js"><link rel="prefetch" href="/wiki/assets/js/19.8726bd0b.js"><link rel="prefetch" href="/wiki/assets/js/20.2914a04f.js"><link rel="prefetch" href="/wiki/assets/js/21.ebd751e0.js"><link rel="prefetch" href="/wiki/assets/js/22.f6801be0.js"><link rel="prefetch" href="/wiki/assets/js/23.87ecfe73.js"><link rel="prefetch" href="/wiki/assets/js/24.cabcaf93.js"><link rel="prefetch" href="/wiki/assets/js/25.306828f5.js"><link rel="prefetch" href="/wiki/assets/js/26.59450304.js"><link rel="prefetch" href="/wiki/assets/js/27.44fddb85.js"><link rel="prefetch" href="/wiki/assets/js/28.4e15bea1.js"><link rel="prefetch" href="/wiki/assets/js/29.bed7cbfd.js"><link rel="prefetch" href="/wiki/assets/js/3.28138f41.js"><link rel="prefetch" href="/wiki/assets/js/30.36a67cca.js"><link rel="prefetch" href="/wiki/assets/js/31.dde8666e.js"><link rel="prefetch" href="/wiki/assets/js/32.148ea73a.js"><link rel="prefetch" href="/wiki/assets/js/33.61c937cc.js"><link rel="prefetch" href="/wiki/assets/js/34.eb7c4b0c.js"><link rel="prefetch" href="/wiki/assets/js/35.abb4ce3d.js"><link rel="prefetch" href="/wiki/assets/js/36.f03d0378.js"><link rel="prefetch" href="/wiki/assets/js/37.84491176.js"><link rel="prefetch" href="/wiki/assets/js/38.2a06b872.js"><link rel="prefetch" href="/wiki/assets/js/39.63965d3b.js"><link rel="prefetch" href="/wiki/assets/js/4.c0af9872.js"><link rel="prefetch" href="/wiki/assets/js/40.bf2e354a.js"><link rel="prefetch" href="/wiki/assets/js/41.bed53451.js"><link rel="prefetch" href="/wiki/assets/js/42.34d4f2f5.js"><link rel="prefetch" href="/wiki/assets/js/43.867c0e23.js"><link rel="prefetch" href="/wiki/assets/js/44.0201a314.js"><link rel="prefetch" href="/wiki/assets/js/45.d6f1a311.js"><link rel="prefetch" href="/wiki/assets/js/46.419d44e4.js"><link rel="prefetch" href="/wiki/assets/js/47.a3f8b595.js"><link rel="prefetch" href="/wiki/assets/js/48.574cc219.js"><link rel="prefetch" href="/wiki/assets/js/49.224dd6c4.js"><link rel="prefetch" href="/wiki/assets/js/5.c521f8b1.js"><link rel="prefetch" href="/wiki/assets/js/50.c8825040.js"><link rel="prefetch" href="/wiki/assets/js/51.2dab614a.js"><link rel="prefetch" href="/wiki/assets/js/52.8382a180.js"><link rel="prefetch" href="/wiki/assets/js/53.bfab18a9.js"><link rel="prefetch" href="/wiki/assets/js/54.87a1d37c.js"><link rel="prefetch" href="/wiki/assets/js/55.5f207671.js"><link rel="prefetch" href="/wiki/assets/js/56.f0e8e082.js"><link rel="prefetch" href="/wiki/assets/js/57.c868e5c9.js"><link rel="prefetch" href="/wiki/assets/js/6.6a737c5b.js"><link rel="prefetch" href="/wiki/assets/js/7.48bba6b4.js"><link rel="prefetch" href="/wiki/assets/js/8.26532964.js"><link rel="prefetch" href="/wiki/assets/js/9.3c4a4032.js">
    <link rel="stylesheet" href="/wiki/assets/css/0.styles.bdf32acf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/wiki/" class="home-link router-link-active"><!----> <span class="site-name">JavaChen Wiki</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/wiki/" class="nav-link">主页</a></div><div class="nav-item"><a href="/wiki/docker/" class="nav-link router-link-active">Docker</a></div><div class="nav-item"><a href="/wiki/elasticsearch/" class="nav-link">Elasticsearch</a></div><div class="nav-item"><a href="/wiki/hadoop/" class="nav-link">Hadoop</a></div><div class="nav-item"><a href="/wiki/interview/" class="nav-link">Interview</a></div><div class="nav-item"><a href="/wiki/rabbitMQ/" class="nav-link">RabbitMQ</a></div><div class="nav-item"><a href="/wiki/redis/" class="nav-link">Redis</a></div><div class="nav-item"><a href="/wiki/spring-cloud-cshop/" class="nav-link">Spring-cloud-cshop</a></div><div class="nav-item"><a href="/wiki/about.html" class="nav-link">关于</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/wiki/" class="nav-link">主页</a></div><div class="nav-item"><a href="/wiki/docker/" class="nav-link router-link-active">Docker</a></div><div class="nav-item"><a href="/wiki/elasticsearch/" class="nav-link">Elasticsearch</a></div><div class="nav-item"><a href="/wiki/hadoop/" class="nav-link">Hadoop</a></div><div class="nav-item"><a href="/wiki/interview/" class="nav-link">Interview</a></div><div class="nav-item"><a href="/wiki/rabbitMQ/" class="nav-link">RabbitMQ</a></div><div class="nav-item"><a href="/wiki/redis/" class="nav-link">Redis</a></div><div class="nav-item"><a href="/wiki/spring-cloud-cshop/" class="nav-link">Spring-cloud-cshop</a></div><div class="nav-item"><a href="/wiki/about.html" class="nav-link">关于</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Docker</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/wiki/docker/" class="sidebar-link">Docker概述</a></li><li><a href="/wiki/docker/docker-1-介绍.html" class="sidebar-link">Docker介绍</a></li><li><a href="/wiki/docker/docker-2-架构.html" class="sidebar-link">Docker架构</a></li><li><a href="/wiki/docker/docker-3-镜像.html" class="sidebar-link">Docker镜像</a></li><li><a href="/wiki/docker/docker-4-容器.html" class="sidebar-link">Docker容器</a></li><li><a href="/wiki/docker/docker-5-仓库.html" class="sidebar-link">Docker仓库</a></li><li><a href="/wiki/docker/docker-6-数据卷.html" class="sidebar-link">Docker数据卷</a></li><li><a href="/wiki/docker/docker-7-网络.html" class="active sidebar-link">Docker 网络</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/docker/docker-7-网络.html#docker-外部访问容器" class="sidebar-link">Docker 外部访问容器</a></li><li class="sidebar-sub-header"><a href="/wiki/docker/docker-7-网络.html#docker-容器互联" class="sidebar-link">Docker 容器互联</a></li><li class="sidebar-sub-header"><a href="/wiki/docker/docker-7-网络.html#docker-配置-dns" class="sidebar-link">Docker 配置 DNS</a></li><li class="sidebar-sub-header"><a href="/wiki/docker/docker-7-网络.html#docker-高级网络配置" class="sidebar-link">Docker 高级网络配置</a></li></ul></li><li><a href="/wiki/docker/docker-8-安装.html" class="sidebar-link">Docker安装</a></li><li><a href="/wiki/docker/docker-9-附录.html" class="sidebar-link">附录</a></li><li><a href="/wiki/docker/docker-compose.html" class="sidebar-link">Docker Compose</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="docker-网络"><a href="#docker-网络" aria-hidden="true" class="header-anchor">#</a> Docker 网络</h1> <p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务</p> <h2 id="docker-外部访问容器"><a href="#docker-外部访问容器" aria-hidden="true" class="header-anchor">#</a> Docker 外部访问容器</h2> <p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p> <p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个 <code>49000~49900</code> 的端口到内部容器开放的网络端口。</p> <p>使用 <code>docker container ls</code> 可以看到，本地主机的 49155 被映射到了容器的 5000 端口。此时访问本机的 49155 端口即可访问容器内 web 应用提供的界面。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ docker run -d -P training/webapp python app.py

$ docker container <span class="token function">ls</span> -l
CONTAINER ID  IMAGE                   COMMAND       CREATED        STATUS        PORTS                    NAMES
bc533791f3f5  training/webapp:latest  python app.py 5 seconds ago  Up 2 seconds  0.0.0.0:49155-<span class="token operator">&gt;</span>5000/tcp  nostalgic_morse
</code></pre></div><p>同样的，可以通过 <code>docker logs</code> 命令来查看应用的信息。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ docker logs -f nostalgic_morse
* Running on http://0.0.0.0:5000/
10.0.2.2 - - <span class="token punctuation">[</span>23/May/2014 20:16:31<span class="token punctuation">]</span> <span class="token string">&quot;GET / HTTP/1.1&quot;</span> 200 -
10.0.2.2 - - <span class="token punctuation">[</span>23/May/2014 20:16:31<span class="token punctuation">]</span> <span class="token string">&quot;GET /favicon.ico HTTP/1.1&quot;</span> 404 -
</code></pre></div><p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p> <h3 id="映射所有接口地址"><a href="#映射所有接口地址" aria-hidden="true" class="header-anchor">#</a> 映射所有接口地址</h3> <p>使用 <code>hostPort:containerPort</code> 格式本地的 5000 端口映射到容器的 5000 端口，可以执行</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ docker run -d -p 5000:5000 training/webapp python app.py
</code></pre></div><p>此时默认会绑定本地所有接口上的所有地址。</p> <h3 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" aria-hidden="true" class="header-anchor">#</a> 映射到指定地址的指定端口</h3> <p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py
</code></pre></div><h3 id="映射到指定地址的任意端口"><a href="#映射到指定地址的任意端口" aria-hidden="true" class="header-anchor">#</a> 映射到指定地址的任意端口</h3> <p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ docker run -d -p 127.0.0.1::5000 training/webapp python app.py
</code></pre></div><p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py
</code></pre></div><h3 id="查看映射端口配置"><a href="#查看映射端口配置" aria-hidden="true" class="header-anchor">#</a> 查看映射端口配置</h3> <p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ docker port nostalgic_morse 5000
127.0.0.1:49155.
</code></pre></div><p>注意：</p> <ul><li>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）</li> <li><code>-p</code> 标记可以多次使用来绑定多个端口</li></ul> <p>例如</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ docker run -d \
    -p 5000:5000 \
    -p 3000:80 \
    training/webapp \
    python app.py
</code></pre></div><h2 id="docker-容器互联"><a href="#docker-容器互联" aria-hidden="true" class="header-anchor">#</a> Docker 容器互联</h2> <p>如果你之前有 <code>Docker</code> 使用经验，你可能已经习惯了使用 <code>--link</code> 参数来使容器互联。</p> <p>随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 <code>--link</code> 参数。</p> <h3 id="新建网络"><a href="#新建网络" aria-hidden="true" class="header-anchor">#</a> 新建网络</h3> <p>下面先创建一个新的 Docker 网络。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ docker network create -d bridge my-net
</code></pre></div><p><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code> <code>overlay</code>。其中 <code>overlay</code> 网络类型用于 <code>Swarm mode</code>，在本小节中你可以忽略它。</p> <h3 id="连接容器"><a href="#连接容器" aria-hidden="true" class="header-anchor">#</a> 连接容器</h3> <p>运行一个容器并连接到新建的 <code>my-net</code> 网络</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ docker run -it --rm --name busybox1 --network my-net busybox sh
</code></pre></div><p>打开新的终端，再运行一个容器并加入到 <code>my-net</code> 网络</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ docker run -it --rm --name busybox2 --network my-net busybox sh
</code></pre></div><p>再打开一个新的终端查看容器信息</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ docker container <span class="token function">ls</span>

CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
b47060aca56b        busybox             <span class="token string">&quot;sh&quot;</span>                11 minutes ago      Up 11 minutes                           busybox2
8720575823ec        busybox             <span class="token string">&quot;sh&quot;</span>                16 minutes ago      Up 16 minutes                           busybox1
</code></pre></div><p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p> <p>在 <code>busybox1</code> 容器输入以下命令</p> <div class="language-bash extra-class"><pre class="language-bash"><code>/ <span class="token comment"># ping busybox2</span>
PING busybox2 <span class="token punctuation">(</span>172.19.0.3<span class="token punctuation">)</span>: 56 data bytes
64 bytes from 172.19.0.3: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.072 ms
64 bytes from 172.19.0.3: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.118 ms
</code></pre></div><p>用 ping 来测试连接 <code>busybox2</code> 容器，它会解析成 <code>172.19.0.3</code>。</p> <p>同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>/ <span class="token comment"># ping busybox1</span>
PING busybox1 <span class="token punctuation">(</span>172.19.0.2<span class="token punctuation">)</span>: 56 data bytes
64 bytes from 172.19.0.2: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.064 ms
64 bytes from 172.19.0.2: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.143 ms
</code></pre></div><p>这样，<code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p> <h3 id="docker-compose"><a href="#docker-compose" aria-hidden="true" class="header-anchor">#</a> Docker Compose</h3> <p>如果你有多个容器之间需要互相连接，推荐使用 <code>Docker Compose</code>。</p> <h2 id="docker-配置-dns"><a href="#docker-配置-dns" aria-hidden="true" class="header-anchor">#</a> Docker 配置 DNS</h2> <p>如何自定义配置容器的主机名和 DNS 呢？秘诀就是 Docker 利用虚拟文件来挂载容器的 3 个相关配置文件。</p> <p>在容器中使用 <code>mount</code> 命令可以看到挂载信息：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">mount</span>
/dev/disk/by-uuid/1fec<span class="token punctuation">..</span>.ebdf on /etc/hostname <span class="token function">type</span> ext4 <span class="token punctuation">..</span>.
/dev/disk/by-uuid/1fec<span class="token punctuation">..</span>.ebdf on /etc/hosts <span class="token function">type</span> ext4 <span class="token punctuation">..</span>.
tmpfs on /etc/resolv.conf <span class="token function">type</span> tmpfs <span class="token punctuation">..</span>.
</code></pre></div><p>这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 <code>/etc/resolv.conf</code> 文件立刻得到更新。</p> <p>配置全部容器的 DNS ，也可以在 <code>/etc/docker/daemon.json</code> 文件中增加以下内容来设置。</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;dns&quot;</span> <span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">&quot;114.114.114.114&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;8.8.8.8&quot;</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样每次启动的容器 DNS 自动配置为 <code>114.114.114.114</code> 和 <code>8.8.8.8</code>。使用以下命令来证明其已经生效。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ docker run -it --rm ubuntu:17.10  <span class="token function">cat</span> etc/resolv.conf

nameserver 114.114.114.114
nameserver 8.8.8.8
</code></pre></div><p>如果用户想要手动指定容器的配置，可以在使用 <code>docker run</code> 命令启动容器时加入如下参数：</p> <p><code>-h HOSTNAME</code> 或者 <code>--hostname=HOSTNAME</code> 设定容器的主机名，它会被写到容器内的 <code>/etc/hostname</code>和 <code>/etc/hosts</code>。但它在容器外部看不到，既不会在 <code>docker container ls</code> 中显示，也不会在其他的容器的 <code>/etc/hosts</code> 看到。</p> <p><code>--dns=IP_ADDRESS</code> 添加 DNS 服务器到容器的 <code>/etc/resolv.conf</code> 中，让容器用这个服务器来解析所有不在 <code>/etc/hosts</code> 中的主机名。</p> <p><code>--dns-search=DOMAIN</code> 设定容器的搜索域，当设定搜索域为 <code>.example.com</code> 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 <code>host.example.com</code>。</p> <blockquote><p>注意：如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的 <code>/etc/resolv.conf</code> 来配置容器。</p></blockquote> <h2 id="docker-高级网络配置"><a href="#docker-高级网络配置" aria-hidden="true" class="header-anchor">#</a> Docker 高级网络配置</h2> <blockquote><p>注意：本章属于 <code>Docker</code> 高级配置，如果您是初学者，您可以暂时跳过本章节，直接学习 <code>Docker Compose</code> 一节。</p></blockquote> <p>本章将介绍 Docker 的一些高级网络配置和选项。</p> <p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code> 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p> <p>同时，Docker 随机分配一个本地未占用的私有网段（在 <a href="http://tools.ietf.org/html/rfc1918" target="_blank" rel="noopener noreferrer">RFC1918<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中定义）中的一个地址给 <code>docker0</code>接口。比如典型的 <code>172.17.42.1</code>，掩码为 <code>255.255.0.0</code>。此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p> <p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code> 网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p> <p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g59y3hsl2lj31b20u0gmn.jpg" alt="Docker 网络"></p> <p>接下来的部分将介绍在一些场景中，Docker 所有的网络定制配置。以及通过 Linux 命令来调整、补充、甚至替换 Docker 默认的网络配置。</p> <h3 id="docker-快速配置指南"><a href="#docker-快速配置指南" aria-hidden="true" class="header-anchor">#</a> Docker 快速配置指南</h3> <p>下面是一个跟 Docker 网络相关的命令列表。</p> <p>其中有些命令选项只有在 Docker 服务启动的时候才能配置，而且不能马上生效。</p> <ul><li><code>-b BRIDGE</code> 或 <code>--bridge=BRIDGE</code> 指定容器挂载的网桥</li> <li><code>--bip=CIDR</code> 定制 docker0 的掩码</li> <li><code>-H SOCKET...</code> 或 <code>--host=SOCKET...</code> Docker 服务端接收命令的通道</li> <li><code>--icc=true|false</code> 是否支持容器之间进行通信</li> <li><code>--ip-forward=true|false</code> 请看下文容器之间的通信</li> <li><code>--iptables=true|false</code> 是否允许 Docker 添加 iptables 规则</li> <li><code>--mtu=BYTES</code> 容器网络中的 MTU</li></ul> <p>下面2个命令选项既可以在启动服务时指定，也可以在启动容器时指定。在 Docker 服务启动的时候指定则会成为默认值，后面执行 <code>docker run</code> 时可以覆盖设置的默认值。</p> <ul><li><code>--dns=IP_ADDRESS...</code> 使用指定的DNS服务器</li> <li><code>--dns-search=DOMAIN...</code> 指定DNS搜索域</li></ul> <p>最后这些选项只有在 <code>docker run</code> 执行时使用，因为它是针对容器的特性内容。</p> <ul><li><code>-h HOSTNAME</code> 或 <code>--hostname=HOSTNAME</code> 配置容器主机名</li> <li><code>--link=CONTAINER_NAME:ALIAS</code> 添加到另一个容器的连接</li> <li><code>--net=bridge|none|container:NAME_or_ID|host</code> 配置容器的桥接模式</li> <li><code>-p SPEC</code> 或 <code>--publish=SPEC</code> 映射容器端口到宿主主机</li> <li><code>-P or --publish-all=true|false</code> 映射容器所有端口到宿主主机</li></ul> <h3 id="docker-容器访问控制"><a href="#docker-容器访问控制" aria-hidden="true" class="header-anchor">#</a> Docker 容器访问控制</h3> <p>容器的访问控制，主要通过 Linux 上的 <code>iptables</code> 防火墙来进行管理和实现。<code>iptables</code> 是 Linux 上默认的防火墙软件，在大部分发行版中都自带。</p> <h4 id="容器访问外部网络"><a href="#容器访问外部网络" aria-hidden="true" class="header-anchor">#</a> 容器访问外部网络</h4> <p>容器要想访问外部网络，需要本地系统的转发支持。在Linux 系统中，检查转发是否打开。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token variable">$sysctl</span> net.ipv4.ip_forward
net.ipv4.ip_forward <span class="token operator">=</span> 1
</code></pre></div><p>如果为 0，说明没有开启转发，则需要手动打开。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token variable">$sysctl</span> -w net.ipv4.ip_forward<span class="token operator">=</span>1
</code></pre></div><p>如果在启动 Docker 服务的时候设定 <code>--ip-forward=true</code>, Docker 就会自动设定系统的 <code>ip_forward</code>参数为 1。</p> <h4 id="容器之间访问"><a href="#容器之间访问" aria-hidden="true" class="header-anchor">#</a> 容器之间访问</h4> <p>容器之间相互访问，需要两方面的支持。</p> <ul><li>容器的网络拓扑是否已经互联。默认情况下，所有容器都会被连接到 <code>docker0</code> 网桥上。</li> <li>本地系统的防火墙软件 -- <code>iptables</code> 是否允许通过。</li></ul> <h4 id="访问所有端口"><a href="#访问所有端口" aria-hidden="true" class="header-anchor">#</a> 访问所有端口</h4> <p>当启动 Docker 服务时候，默认会添加一条转发策略到 iptables 的 FORWARD 链上。策略为通过（<code>ACCEPT</code>）还是禁止（<code>DROP</code>）取决于配置<code>--icc=true</code>（缺省值）还是 <code>--icc=false</code>。当然，如果手动指定 <code>--iptables=false</code> 则不会添加 <code>iptables</code> 规则。</p> <p>可见，默认情况下，不同容器之间是允许网络互通的。如果为了安全考虑，可以在 <code>/etc/default/docker</code> 文件中配置 <code>DOCKER_OPTS=--icc=false</code> 来禁止它。</p> <h4 id="访问指定端口"><a href="#访问指定端口" aria-hidden="true" class="header-anchor">#</a> 访问指定端口</h4> <p>在通过 <code>-icc=false</code> 关闭网络访问后，还可以通过 <code>--link=CONTAINER_NAME:ALIAS</code> 选项来访问容器的开放端口。</p> <p>例如，在启动 Docker 服务时，可以同时使用 <code>icc=false --iptables=true</code> 参数来关闭允许相互的网络访问，并让 Docker 可以修改系统中的 <code>iptables</code> 规则。</p> <p>此时，系统中的 <code>iptables</code> 规则可能是类似</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">sudo</span> iptables -nL
<span class="token punctuation">..</span>.
Chain FORWARD <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token function">source</span>               destination
DROP       all  --  0.0.0.0/0            0.0.0.0/0
<span class="token punctuation">..</span>.
</code></pre></div><p>之后，启动容器（<code>docker run</code>）时使用 <code>--link=CONTAINER_NAME:ALIAS</code> 选项。Docker 会在 <code>iptable</code> 中为 两个容器分别添加一条 <code>ACCEPT</code> 规则，允许相互访问开放的端口（取决于 <code>Dockerfile</code>中的 <code>EXPOSE</code> 指令）。</p> <p>当添加了 <code>--link=CONTAINER_NAME:ALIAS</code> 选项后，添加了 <code>iptables</code> 规则。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">sudo</span> iptables -nL
<span class="token punctuation">..</span>.
Chain FORWARD <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token function">source</span>               destination
ACCEPT     tcp  --  172.17.0.2           172.17.0.3           tcp spt:80
ACCEPT     tcp  --  172.17.0.3           172.17.0.2           tcp dpt:80
DROP       all  --  0.0.0.0/0            0.0.0.0/0
</code></pre></div><p>注意：<code>--link=CONTAINER_NAME:ALIAS</code> 中的 <code>CONTAINER_NAME</code> 目前必须是 Docker 分配的名字，或使用 <code>--name</code> 参数指定的名字。主机名则不会被识别。</p> <h3 id="docker-端口映射实现"><a href="#docker-端口映射实现" aria-hidden="true" class="header-anchor">#</a> Docker 端口映射实现</h3> <p>默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器。</p> <h4 id="容器访问外部实现"><a href="#容器访问外部实现" aria-hidden="true" class="header-anchor">#</a> 容器访问外部实现</h4> <p>容器所有到外部网络的连接，源地址都会被 NAT 成本地系统的 IP 地址。这是使用 <code>iptables</code> 的源地址伪装操作实现的。</p> <p>查看主机的 NAT 规则。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">sudo</span> iptables -t nat -nL
<span class="token punctuation">..</span>.
Chain POSTROUTING <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token function">source</span>               destination
MASQUERADE  all  --  172.17.0.0/16       <span class="token operator">!</span>172.17.0.0/16
<span class="token punctuation">..</span>.
</code></pre></div><p>其中，上述规则将所有源地址在 <code>172.17.0.0/16</code> 网段，目标地址为其他网段（外部网络）的流量动态伪装为从系统网卡发出。MASQUERADE 跟传统 SNAT 的好处是它能动态从网卡获取地址。</p> <h4 id="外部访问容器实现"><a href="#外部访问容器实现" aria-hidden="true" class="header-anchor">#</a> 外部访问容器实现</h4> <p>容器允许外部访问，可以在 <code>docker run</code> 时候通过 <code>-p</code> 或 <code>-P</code> 参数来启用。</p> <p>不管用那种办法，其实也是在本地的 <code>iptable</code> 的 nat 表中添加相应的规则。</p> <p>使用 <code>-P</code> 时：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ iptables -t nat -nL
<span class="token punctuation">..</span>.
Chain DOCKER <span class="token punctuation">(</span>2 references<span class="token punctuation">)</span>
target     prot opt <span class="token function">source</span>               destination
DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:49153 to:172.17.0.2:80
</code></pre></div><p>使用 <code>-p 80:80</code> 时：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ iptables -t nat -nL
Chain DOCKER <span class="token punctuation">(</span>2 references<span class="token punctuation">)</span>
target     prot opt <span class="token function">source</span>               destination
DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:172.17.0.2:80
</code></pre></div><p>注意：</p> <ul><li>这里的规则映射了 <code>0.0.0.0</code>，意味着将接受主机来自所有接口的流量。用户可以通过 <code>-p IP:host_port:container_port</code> 或 <code>-p IP::port</code> 来指定允许访问容器的主机上的 IP、接口等，以制定更严格的规则。</li> <li>如果希望永久绑定到某个固定的 IP 地址，可以在 Docker 配置文件 <code>/etc/docker/daemon.json</code> 中添加如下内容。</li></ul> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;ip&quot;</span><span class="token operator">:</span> <span class="token string">&quot;0.0.0.0&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="配置-docker0-网桥"><a href="#配置-docker0-网桥" aria-hidden="true" class="header-anchor">#</a> 配置 docker0 网桥</h3> <p>Docker 服务默认会创建一个 <code>docker0</code> 网桥（其上有一个 <code>docker0</code> 内部接口），它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。</p> <p>Docker 默认指定了 <code>docker0</code> 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信，它还给出了 MTU（接口允许接收的最大传输单元），通常是 1500 Bytes，或宿主主机网络路由上支持的默认值。这些值都可以在服务启动的时候进行配置。</p> <ul><li><code>--bip=CIDR</code> IP 地址加掩码格式，例如 192.168.1.5/24</li> <li><code>--mtu=BYTES</code> 覆盖默认的 Docker mtu 配置</li></ul> <p>也可以在配置文件中配置 DOCKER_OPTS，然后重启服务。</p> <p>由于目前 Docker 网桥是 Linux 网桥，用户可以使用 <code>brctl show</code> 来查看网桥和端口连接信息。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">sudo</span> brctl show
bridge name     bridge <span class="token function">id</span>               STP enabled     interfaces
docker0         8000.3a1d7362b4ee       no              veth65f9
                                             vethdda6
</code></pre></div><p>*注：<code>brctl</code> 命令在 Debian、Ubuntu 中可以使用 <code>sudo apt-get install bridge-utils</code> 来安装。</p> <p>每次创建一个新容器的时候，Docker 从可用的地址段中选择一个空闲的 IP 地址分配给容器的 eth0 端口。使用本地主机上 <code>docker0</code> 接口的 IP 作为所有容器的默认网关。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">sudo</span> docker run -i -t --rm base /bin/bash
$ <span class="token function">ip</span> addr show eth0
24: eth0: <span class="token operator">&lt;</span>BROADCAST,UP,LOWER_UP<span class="token operator">&gt;</span> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 32:6f:e0:35:57:91 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.3/16 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::306f:e0ff:fe35:5791/64 scope <span class="token function">link</span>
       valid_lft forever preferred_lft forever
$ <span class="token function">ip</span> route
default via 172.17.42.1 dev eth0
172.17.0.0/16 dev eth0  proto kernel  scope <span class="token function">link</span>  src 172.17.0.3
</code></pre></div><h3 id="docker-自定义网桥"><a href="#docker-自定义网桥" aria-hidden="true" class="header-anchor">#</a> Docker 自定义网桥</h3> <p>除了默认的 <code>docker0</code> 网桥，用户也可以指定网桥来连接各个容器。</p> <p>在启动 Docker 服务的时候，使用 <code>-b BRIDGE</code>或<code>--bridge=BRIDGE</code> 来指定使用的网桥。</p> <p>如果服务已经运行，那需要先停止服务，并删除旧的网桥。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">sudo</span> systemctl stop docker
$ <span class="token function">sudo</span> <span class="token function">ip</span> <span class="token function">link</span> <span class="token keyword">set</span> dev docker0 down
$ <span class="token function">sudo</span> brctl delbr docker0
</code></pre></div><p>然后创建一个网桥 <code>bridge0</code>。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">sudo</span> brctl addbr bridge0
$ <span class="token function">sudo</span> <span class="token function">ip</span> addr <span class="token function">add</span> 192.168.5.1/24 dev bridge0
$ <span class="token function">sudo</span> <span class="token function">ip</span> <span class="token function">link</span> <span class="token keyword">set</span> dev bridge0 up
</code></pre></div><p>查看确认网桥创建并启动。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">ip</span> addr show bridge0
4: bridge0: <span class="token operator">&lt;</span>BROADCAST,MULTICAST<span class="token operator">&gt;</span> mtu 1500 qdisc noop state UP group default
    link/ether 66:38:d0:0d:76:18 brd ff:ff:ff:ff:ff:ff
    inet 192.168.5.1/24 scope global bridge0
       valid_lft forever preferred_lft forever
</code></pre></div><p>在 Docker 配置文件 <code>/etc/docker/daemon.json</code> 中添加如下内容，即可将 Docker 默认桥接到创建的网桥上。</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;bridge&quot;</span><span class="token operator">:</span> <span class="token string">&quot;bridge0&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>启动 Docker 服务。</p> <p>新建一个容器，可以看到它已经桥接到了 <code>bridge0</code> 上。</p> <p>可以继续用 <code>brctl show</code> 命令查看桥接的信息。另外，在容器中可以使用 <code>ip addr</code> 和 <code>ip route</code> 命令来查看 IP 地址配置和路由信息。</p> <h3 id="docker-工具和示例"><a href="#docker-工具和示例" aria-hidden="true" class="header-anchor">#</a> Docker 工具和示例</h3> <p>在介绍自定义网络拓扑之前，你可能会对一些外部工具和例子感兴趣：</p> <h4 id="pipework"><a href="#pipework" aria-hidden="true" class="header-anchor">#</a> pipework</h4> <p>Jérôme Petazzoni 编写了一个叫 <a href="https://github.com/jpetazzo/pipework" target="_blank" rel="noopener noreferrer">pipework<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的 shell 脚本，可以帮助用户在比较复杂的场景中完成容器的连接。</p> <h4 id="playground"><a href="#playground" aria-hidden="true" class="header-anchor">#</a> playground</h4> <p>Brandon Rhodes 创建了一个提供完整的 Docker 容器网络拓扑管理的 <a href="https://github.com/brandon-rhodes/fopnp/tree/m/playground" target="_blank" rel="noopener noreferrer">Python库<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，包括路由、NAT 防火墙；以及一些提供 HTTP, SMTP, POP, IMAP, Telnet, SSH, FTP 的服务器。</p> <h3 id="docker-编辑网络配置文件"><a href="#docker-编辑网络配置文件" aria-hidden="true" class="header-anchor">#</a> Docker 编辑网络配置文件</h3> <p>Docker 1.2.0 开始支持在运行中的容器里编辑 <code>/etc/hosts</code>, <code>/etc/hostname</code> 和 <code>/etc/resolv.conf</code>文件。</p> <p>但是这些修改是临时的，只在运行的容器中保留，容器终止或重启后并不会被保存下来。也不会被 <code>docker commit</code> 提交。</p> <h3 id="实例：创建一个点到点连接"><a href="#实例：创建一个点到点连接" aria-hidden="true" class="header-anchor">#</a> 实例：创建一个点到点连接</h3> <p>默认情况下，Docker 会将所有容器连接到由 <code>docker0</code> 提供的虚拟子网中。</p> <p>用户有时候需要两个容器之间可以直连通信，而不用通过主机网桥进行桥接。</p> <p>解决办法很简单：创建一对 <code>peer</code> 接口，分别放到两个容器中，配置成点到点链路类型即可。</p> <p>首先启动 2 个容器：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ docker run -i -t --rm --net<span class="token operator">=</span>none base /bin/bash
root@1f1f4c1f931a:/<span class="token comment">#</span>
$ docker run -i -t --rm --net<span class="token operator">=</span>none base /bin/bash
root@12e343489d2f:/<span class="token comment">#</span>
</code></pre></div><p>找到进程号，然后创建网络命名空间的跟踪文件。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ docker inspect -f <span class="token string">'{{.State.Pid}}'</span> 1f1f4c1f931a
2989
$ docker inspect -f <span class="token string">'{{.State.Pid}}'</span> 12e343489d2f
3004
$ <span class="token function">sudo</span> <span class="token function">mkdir</span> -p /var/run/netns
$ <span class="token function">sudo</span> <span class="token function">ln</span> -s /proc/2989/ns/net /var/run/netns/2989
$ <span class="token function">sudo</span> <span class="token function">ln</span> -s /proc/3004/ns/net /var/run/netns/3004
</code></pre></div><p>创建一对 <code>peer</code> 接口，然后配置路由</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">sudo</span> <span class="token function">ip</span> <span class="token function">link</span> <span class="token function">add</span> A <span class="token function">type</span> veth peer name B

$ <span class="token function">sudo</span> <span class="token function">ip</span> <span class="token function">link</span> <span class="token keyword">set</span> A netns 2989
$ <span class="token function">sudo</span> <span class="token function">ip</span> netns <span class="token function">exec</span> 2989 <span class="token function">ip</span> addr <span class="token function">add</span> 10.1.1.1/32 dev A
$ <span class="token function">sudo</span> <span class="token function">ip</span> netns <span class="token function">exec</span> 2989 <span class="token function">ip</span> <span class="token function">link</span> <span class="token keyword">set</span> A up
$ <span class="token function">sudo</span> <span class="token function">ip</span> netns <span class="token function">exec</span> 2989 <span class="token function">ip</span> route <span class="token function">add</span> 10.1.1.2/32 dev A

$ <span class="token function">sudo</span> <span class="token function">ip</span> <span class="token function">link</span> <span class="token keyword">set</span> B netns 3004
$ <span class="token function">sudo</span> <span class="token function">ip</span> netns <span class="token function">exec</span> 3004 <span class="token function">ip</span> addr <span class="token function">add</span> 10.1.1.2/32 dev B
$ <span class="token function">sudo</span> <span class="token function">ip</span> netns <span class="token function">exec</span> 3004 <span class="token function">ip</span> <span class="token function">link</span> <span class="token keyword">set</span> B up
$ <span class="token function">sudo</span> <span class="token function">ip</span> netns <span class="token function">exec</span> 3004 <span class="token function">ip</span> route <span class="token function">add</span> 10.1.1.1/32 dev B
</code></pre></div><p>现在这 2 个容器就可以相互 ping 通，并成功建立连接。点到点链路不需要子网和子网掩码。</p> <p>此外，也可以不指定 <code>--net=none</code> 来创建点到点链路。这样容器还可以通过原先的网络来通信。</p> <p>利用类似的办法，可以创建一个只跟主机通信的容器。但是一般情况下，更推荐使用 <code>--icc=false</code> 来关闭容器之间的通信。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/wiki/docker/docker-6-数据卷.html" class="prev">
          Docker数据卷
        </a></span> <span class="next"><a href="/wiki/docker/docker-8-安装.html">
          Docker安装
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/wiki/assets/js/app.dd178f5a.js" defer></script><script src="/wiki/assets/js/2.9f273a62.js" defer></script><script src="/wiki/assets/js/14.34eed2f7.js" defer></script>
  </body>
</html>
