<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>附录 | JavaChen Wiki</title>
    <meta name="description" content="JavaChen Wiki">
    <link rel="icon" href="/wiki/img/logo.ico">
  <meta http-quiv="pragma" cotent="no-cache">
  <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
  <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/wiki/assets/css/0.styles.bdf32acf.css" as="style"><link rel="preload" href="/wiki/assets/js/app.dd178f5a.js" as="script"><link rel="preload" href="/wiki/assets/js/2.9f273a62.js" as="script"><link rel="preload" href="/wiki/assets/js/16.6346731c.js" as="script"><link rel="prefetch" href="/wiki/assets/js/10.e389070d.js"><link rel="prefetch" href="/wiki/assets/js/11.19e9f97f.js"><link rel="prefetch" href="/wiki/assets/js/12.f95e0459.js"><link rel="prefetch" href="/wiki/assets/js/13.127730fd.js"><link rel="prefetch" href="/wiki/assets/js/14.34eed2f7.js"><link rel="prefetch" href="/wiki/assets/js/15.a8cf4000.js"><link rel="prefetch" href="/wiki/assets/js/17.143af375.js"><link rel="prefetch" href="/wiki/assets/js/18.7d95703a.js"><link rel="prefetch" href="/wiki/assets/js/19.8726bd0b.js"><link rel="prefetch" href="/wiki/assets/js/20.2914a04f.js"><link rel="prefetch" href="/wiki/assets/js/21.ebd751e0.js"><link rel="prefetch" href="/wiki/assets/js/22.f6801be0.js"><link rel="prefetch" href="/wiki/assets/js/23.87ecfe73.js"><link rel="prefetch" href="/wiki/assets/js/24.cabcaf93.js"><link rel="prefetch" href="/wiki/assets/js/25.306828f5.js"><link rel="prefetch" href="/wiki/assets/js/26.59450304.js"><link rel="prefetch" href="/wiki/assets/js/27.44fddb85.js"><link rel="prefetch" href="/wiki/assets/js/28.4e15bea1.js"><link rel="prefetch" href="/wiki/assets/js/29.bed7cbfd.js"><link rel="prefetch" href="/wiki/assets/js/3.28138f41.js"><link rel="prefetch" href="/wiki/assets/js/30.36a67cca.js"><link rel="prefetch" href="/wiki/assets/js/31.dde8666e.js"><link rel="prefetch" href="/wiki/assets/js/32.148ea73a.js"><link rel="prefetch" href="/wiki/assets/js/33.61c937cc.js"><link rel="prefetch" href="/wiki/assets/js/34.eb7c4b0c.js"><link rel="prefetch" href="/wiki/assets/js/35.abb4ce3d.js"><link rel="prefetch" href="/wiki/assets/js/36.f03d0378.js"><link rel="prefetch" href="/wiki/assets/js/37.84491176.js"><link rel="prefetch" href="/wiki/assets/js/38.2a06b872.js"><link rel="prefetch" href="/wiki/assets/js/39.63965d3b.js"><link rel="prefetch" href="/wiki/assets/js/4.c0af9872.js"><link rel="prefetch" href="/wiki/assets/js/40.bf2e354a.js"><link rel="prefetch" href="/wiki/assets/js/41.bed53451.js"><link rel="prefetch" href="/wiki/assets/js/42.34d4f2f5.js"><link rel="prefetch" href="/wiki/assets/js/43.867c0e23.js"><link rel="prefetch" href="/wiki/assets/js/44.0201a314.js"><link rel="prefetch" href="/wiki/assets/js/45.d6f1a311.js"><link rel="prefetch" href="/wiki/assets/js/46.419d44e4.js"><link rel="prefetch" href="/wiki/assets/js/47.a3f8b595.js"><link rel="prefetch" href="/wiki/assets/js/48.574cc219.js"><link rel="prefetch" href="/wiki/assets/js/49.224dd6c4.js"><link rel="prefetch" href="/wiki/assets/js/5.c521f8b1.js"><link rel="prefetch" href="/wiki/assets/js/50.c8825040.js"><link rel="prefetch" href="/wiki/assets/js/51.2dab614a.js"><link rel="prefetch" href="/wiki/assets/js/52.8382a180.js"><link rel="prefetch" href="/wiki/assets/js/53.bfab18a9.js"><link rel="prefetch" href="/wiki/assets/js/54.87a1d37c.js"><link rel="prefetch" href="/wiki/assets/js/55.5f207671.js"><link rel="prefetch" href="/wiki/assets/js/56.f0e8e082.js"><link rel="prefetch" href="/wiki/assets/js/57.c868e5c9.js"><link rel="prefetch" href="/wiki/assets/js/6.6a737c5b.js"><link rel="prefetch" href="/wiki/assets/js/7.48bba6b4.js"><link rel="prefetch" href="/wiki/assets/js/8.26532964.js"><link rel="prefetch" href="/wiki/assets/js/9.3c4a4032.js">
    <link rel="stylesheet" href="/wiki/assets/css/0.styles.bdf32acf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/wiki/" class="home-link router-link-active"><!----> <span class="site-name">JavaChen Wiki</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/wiki/" class="nav-link">主页</a></div><div class="nav-item"><a href="/wiki/docker/" class="nav-link router-link-active">Docker</a></div><div class="nav-item"><a href="/wiki/elasticsearch/" class="nav-link">Elasticsearch</a></div><div class="nav-item"><a href="/wiki/hadoop/" class="nav-link">Hadoop</a></div><div class="nav-item"><a href="/wiki/interview/" class="nav-link">Interview</a></div><div class="nav-item"><a href="/wiki/rabbitMQ/" class="nav-link">RabbitMQ</a></div><div class="nav-item"><a href="/wiki/redis/" class="nav-link">Redis</a></div><div class="nav-item"><a href="/wiki/spring-cloud-cshop/" class="nav-link">Spring-cloud-cshop</a></div><div class="nav-item"><a href="/wiki/about.html" class="nav-link">关于</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/wiki/" class="nav-link">主页</a></div><div class="nav-item"><a href="/wiki/docker/" class="nav-link router-link-active">Docker</a></div><div class="nav-item"><a href="/wiki/elasticsearch/" class="nav-link">Elasticsearch</a></div><div class="nav-item"><a href="/wiki/hadoop/" class="nav-link">Hadoop</a></div><div class="nav-item"><a href="/wiki/interview/" class="nav-link">Interview</a></div><div class="nav-item"><a href="/wiki/rabbitMQ/" class="nav-link">RabbitMQ</a></div><div class="nav-item"><a href="/wiki/redis/" class="nav-link">Redis</a></div><div class="nav-item"><a href="/wiki/spring-cloud-cshop/" class="nav-link">Spring-cloud-cshop</a></div><div class="nav-item"><a href="/wiki/about.html" class="nav-link">关于</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Docker</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/wiki/docker/" class="sidebar-link">Docker概述</a></li><li><a href="/wiki/docker/docker-1-介绍.html" class="sidebar-link">Docker介绍</a></li><li><a href="/wiki/docker/docker-2-架构.html" class="sidebar-link">Docker架构</a></li><li><a href="/wiki/docker/docker-3-镜像.html" class="sidebar-link">Docker镜像</a></li><li><a href="/wiki/docker/docker-4-容器.html" class="sidebar-link">Docker容器</a></li><li><a href="/wiki/docker/docker-5-仓库.html" class="sidebar-link">Docker仓库</a></li><li><a href="/wiki/docker/docker-6-数据卷.html" class="sidebar-link">Docker数据卷</a></li><li><a href="/wiki/docker/docker-7-网络.html" class="sidebar-link">Docker 网络</a></li><li><a href="/wiki/docker/docker-8-安装.html" class="sidebar-link">Docker安装</a></li><li><a href="/wiki/docker/docker-9-附录.html" class="active sidebar-link">附录</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/docker/docker-9-附录.html#附录" class="sidebar-link">附录</a></li></ul></li><li><a href="/wiki/docker/docker-compose.html" class="sidebar-link">Docker Compose</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="附录"><a href="#附录" aria-hidden="true" class="header-anchor">#</a> 附录</h2> <h3 id="常用命令"><a href="#常用命令" aria-hidden="true" class="header-anchor">#</a> 常用命令</h3> <h4 id="基本语法"><a href="#基本语法" aria-hidden="true" class="header-anchor">#</a> 基本语法</h4> <p>Docker 命令有两大类，客户端命令和服务端命令。前者是主要的操作接口，后者用来启动 Docker Daemon。</p> <ul><li>客户端命令：基本命令格式为 <code>docker [OPTIONS] COMMAND [arg...]</code>；</li> <li>服务端命令：基本命令格式为 <code>dockerd [OPTIONS]</code>。</li></ul> <h4 id="客户端命令选项"><a href="#客户端命令选项" aria-hidden="true" class="header-anchor">#</a> 客户端命令选项</h4> <div class="language-bash extra-class"><pre class="language-bash"><code>--config<span class="token operator">=</span><span class="token string">&quot;&quot;</span>：指定客户端配置文件，默认为 <span class="token variable"><span class="token variable">`</span>/.docker<span class="token variable">`</span></span>；
-D<span class="token operator">=</span>true<span class="token operator">|</span>false：是否使用 debug 模式。默认不开启；
-H, --host<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>：指定命令对应 Docker 守护进程的监听接口，可以为 unix 套接字（unix:///path/to/socket），文件句柄（fd://socketfd）或 tcp 套接字（tcp://<span class="token punctuation">[</span>host<span class="token punctuation">[</span>:port<span class="token punctuation">]</span><span class="token punctuation">]</span>），默认为 unix:///var/run/docker.sock；
-l, --log-level<span class="token operator">=</span><span class="token string">&quot;debug|info|warn|error|fatal&quot;</span>：指定日志输出级别；
--tls<span class="token operator">=</span>true<span class="token operator">|</span>false：是否对 Docker 守护进程启用 TLS 安全机制，默认为否；
--tlscacert<span class="token operator">=</span> /.docker/ca.pem：TLS CA 签名的可信证书文件路径；
--tlscert<span class="token operator">=</span> /.docker/cert.pem：TLS 可信证书文件路径；
--tlscert<span class="token operator">=</span> /.docker/key.pem：TLS 密钥文件路径；
--tlsverify<span class="token operator">=</span>true<span class="token operator">|</span>false：启用 TLS 校验，默认为否。
</code></pre></div><h4 id="dockerd-命令选项"><a href="#dockerd-命令选项" aria-hidden="true" class="header-anchor">#</a> dockerd 命令选项</h4> <div class="language-bash extra-class"><pre class="language-bash"><code>--api-cors-header<span class="token operator">=</span><span class="token string">&quot;&quot;</span>：CORS 头部域，默认不允许 CORS，要允许任意的跨域访问，可以指定为 “*”；
--authorization-plugin<span class="token operator">=</span><span class="token string">&quot;&quot;</span>：载入认证的插件；
-b<span class="token operator">=</span><span class="token string">&quot;&quot;</span>：将容器挂载到一个已存在的网桥上。指定为 <span class="token string">'none'</span> 时则禁用容器的网络，与 --bip 选项互斥；
--bip<span class="token operator">=</span><span class="token string">&quot;&quot;</span>：让动态创建的 docker0 网桥采用给定的 CIDR 地址<span class="token punctuation">;</span> 与 -b 选项互斥；
--cgroup-parent<span class="token operator">=</span><span class="token string">&quot;&quot;</span>：指定 cgroup 的父组，默认 fs cgroup 驱动为 <span class="token variable"><span class="token variable">`</span>/docker<span class="token variable">`</span></span>，systemd cgroup 驱动为 <span class="token variable"><span class="token variable">`</span>system.slice<span class="token variable">`</span></span>；
--cluster-store<span class="token operator">=</span><span class="token string">&quot;&quot;</span>：构成集群（如 Swarm）时，集群键值数据库服务地址；
--cluster-advertise<span class="token operator">=</span><span class="token string">&quot;&quot;</span>：构成集群时，自身的被访问地址，可以为 <span class="token variable"><span class="token variable">`</span>host:port<span class="token variable">`</span></span> 或 <span class="token variable"><span class="token variable">`</span>interface:port<span class="token variable">`</span></span>；
--cluster-store-opt<span class="token operator">=</span><span class="token string">&quot;&quot;</span>：构成集群时，键值数据库的配置选项；
--config-file<span class="token operator">=</span><span class="token string">&quot;/etc/docker/daemon.json&quot;</span>：daemon 配置文件路径；
--containerd<span class="token operator">=</span><span class="token string">&quot;&quot;</span>：containerd 文件的路径；
-D, --debug<span class="token operator">=</span>true<span class="token operator">|</span>false：是否使用 Debug 模式。缺省为 false；
--default-gateway<span class="token operator">=</span><span class="token string">&quot;&quot;</span>：容器的 IPv4 网关地址，必须在网桥的子网段内；
--default-gateway-v6<span class="token operator">=</span><span class="token string">&quot;&quot;</span>：容器的 IPv6 网关地址；
--default-ulimit<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>：默认的 <span class="token function">ulimit</span> 值；
--disable-legacy-registry<span class="token operator">=</span>true<span class="token operator">|</span>false：是否允许访问旧版本的镜像仓库服务器；
--dns<span class="token operator">=</span><span class="token string">&quot;&quot;</span>：指定容器使用的 DNS 服务器地址；
--dns-opt<span class="token operator">=</span><span class="token string">&quot;&quot;</span>：DNS 选项；
--dns-search<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>：DNS 搜索域；
--exec-opt<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>：运行时的执行选项；
--exec-root<span class="token operator">=</span><span class="token string">&quot;&quot;</span>：容器执行状态文件的根路径，默认为 <span class="token variable"><span class="token variable">`</span>/var/run/docker<span class="token variable">`</span></span>；
--fixed-cidr<span class="token operator">=</span><span class="token string">&quot;&quot;</span>：限定分配 IPv4 地址范围；
--fixed-cidr-v6<span class="token operator">=</span><span class="token string">&quot;&quot;</span>：限定分配 IPv6 地址范围；
-G, --group<span class="token operator">=</span><span class="token string">&quot;&quot;</span>：分配给 unix 套接字的组，默认为 <span class="token variable"><span class="token variable">`</span>docker<span class="token variable">`</span></span>；
-g, --graph<span class="token operator">=</span><span class="token string">&quot;&quot;</span>：Docker 运行时的根路径，默认为 <span class="token variable"><span class="token variable">`</span>/var/lib/docker<span class="token variable">`</span></span>；
-H, --host<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>：指定命令对应 Docker daemon 的监听接口，可以为 unix 套接字（unix:///path/to/socket），文件句柄（fd://socketfd）或 tcp 套接字（tcp://<span class="token punctuation">[</span>host<span class="token punctuation">[</span>:port<span class="token punctuation">]</span><span class="token punctuation">]</span>），默认为 unix:///var/run/docker.sock；
--icc<span class="token operator">=</span>true<span class="token operator">|</span>false：是否启用容器间以及跟 daemon 所在主机的通信。默认为 true。
--insecure-registry<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>：允许访问给定的非安全仓库服务；
--ip<span class="token operator">=</span><span class="token string">&quot;&quot;</span>：绑定容器端口时候的默认 IP 地址。缺省为 0.0.0.0；
--ip-forward<span class="token operator">=</span>true<span class="token operator">|</span>false：是否检查启动在 Docker 主机上的启用 IP 转发服务，默认开启。注意关闭该选项将不对系统转发能力进行任何检查修改；
--ip-masq<span class="token operator">=</span>true<span class="token operator">|</span>false：是否进行地址伪装，用于容器访问外部网络，默认开启；
--iptables<span class="token operator">=</span>true<span class="token operator">|</span>false：是否允许 Docker 添加 iptables 规则。缺省为 true；
--ipv6<span class="token operator">=</span>true<span class="token operator">|</span>false：是否启用 IPv6 支持，默认关闭；
-l, --log-level<span class="token operator">=</span><span class="token string">&quot;debug|info|warn|error|fatal&quot;</span>：指定日志输出级别；
--label<span class="token operator">=</span><span class="token string">&quot;[]&quot;</span>：添加指定的键值对标注；
--log-driver<span class="token operator">=</span><span class="token string">&quot;json-file|syslog|journald|gelf|fluentd|awslogs|splunk|etwlogs|gcplogs|none&quot;</span>：指定日志后端驱动，默认为 json-file；
--log-opt<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>：日志后端的选项；
--mtu<span class="token operator">=</span>VALUE：指定容器网络的 mtu；
-p<span class="token operator">=</span><span class="token string">&quot;&quot;</span>：指定 daemon 的 PID 文件路径。缺省为 <span class="token variable"><span class="token variable">`</span>/var/run/docker.pid<span class="token variable">`</span></span>；
--raw-logs：输出原始，未加色彩的日志信息；
--registry-mirror<span class="token operator">=</span><span class="token operator">&lt;</span>scheme<span class="token operator">&gt;</span>://<span class="token operator">&lt;</span>host<span class="token operator">&gt;</span>：指定 <span class="token variable"><span class="token variable">`</span>docker pull<span class="token variable">`</span></span> 时使用的注册服务器镜像地址；
-s, --storage-driver<span class="token operator">=</span><span class="token string">&quot;&quot;</span>：指定使用给定的存储后端；
--selinux-enabled<span class="token operator">=</span>true<span class="token operator">|</span>false：是否启用 SELinux 支持。缺省值为 false。SELinux 目前尚不支持 overlay 存储驱动；
--storage-opt<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>：驱动后端选项；
--tls<span class="token operator">=</span>true<span class="token operator">|</span>false：是否对 Docker daemon 启用 TLS 安全机制，默认为否；
--tlscacert<span class="token operator">=</span> /.docker/ca.pem：TLS CA 签名的可信证书文件路径；
--tlscert<span class="token operator">=</span> /.docker/cert.pem：TLS 可信证书文件路径；
--tlscert<span class="token operator">=</span> /.docker/key.pem：TLS 密钥文件路径；
--tlsverify<span class="token operator">=</span>true<span class="token operator">|</span>false：启用 TLS 校验，默认为否；
--userland-proxy<span class="token operator">=</span>true<span class="token operator">|</span>false：是否使用用户态代理来实现容器间和出容器的回环通信，默认为 true；
--userns-remap<span class="token operator">=</span>default<span class="token operator">|</span>uid:gid<span class="token operator">|</span>user:group<span class="token operator">|</span>user<span class="token operator">|</span>uid：指定容器的用户命名空间，默认是创建新的 UID 和 GID 映射到容器内进程。
</code></pre></div><h4 id="客户端命令"><a href="#客户端命令" aria-hidden="true" class="header-anchor">#</a> 客户端命令</h4> <p>可以通过 <code>docker COMMAND --help</code> 来查看这些命令的具体用法。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>attach：依附到一个正在运行的容器中；
build：从一个 Dockerfile 创建一个镜像；
commit：从一个容器的修改中创建一个新的镜像；
cp：在容器和本地宿主系统之间复制文件中；
create：创建一个新容器，但并不运行它；
diff：检查一个容器内文件系统的修改，包括修改和增加；
events：从服务端获取实时的事件；
exec：在运行的容器内执行命令；
export：导出容器内容为一个 <span class="token function">tar</span> 包；
history：显示一个镜像的历史信息；
images：列出存在的镜像；
import：导入一个文件（典型为 <span class="token function">tar</span> 包）路径或目录来创建一个本地镜像；
info：显示一些相关的系统信息；
inspect：显示一个容器的具体配置信息；
kill：关闭一个运行中的容器 <span class="token punctuation">(</span>包括进程和所有相关资源<span class="token punctuation">)</span>；
load：从一个 <span class="token function">tar</span> 包中加载一个镜像；
login：注册或登录到一个 Docker 的仓库服务器；
logout：从 Docker 的仓库服务器登出；
logs：获取容器的 log 信息；
network：管理 Docker 的网络，包括查看、创建、删除、挂载、卸载等；
node：管理 swarm 集群中的节点，包括查看、更新、删除、提升/取消管理节点等；
pause：暂停一个容器中的所有进程；
port：查找一个 nat 到一个私有网口的公共口；
ps：列出主机上的容器；
pull：从一个Docker的仓库服务器下拉一个镜像或仓库；
push：将一个镜像或者仓库推送到一个 Docker 的注册服务器；
rename：重命名一个容器；
restart：重启一个运行中的容器；
rm：删除给定的若干个容器；
rmi：删除给定的若干个镜像；
run：创建一个新容器，并在其中运行给定命令；
save：保存一个镜像为 <span class="token function">tar</span> 包文件；
search：在 Docker index 中搜索一个镜像；
service：管理 Docker 所启动的应用服务，包括创建、更新、删除等；
start：启动一个容器；
stats：输出（一个或多个）容器的资源使用统计信息；
stop：终止一个运行中的容器；
swarm：管理 Docker swarm 集群，包括创建、加入、退出、更新等；
tag：为一个镜像打标签；
top：查看一个容器中的正在运行的进程信息；
unpause：将一个容器内所有的进程从暂停状态中恢复；
update：更新指定的若干容器的配置信息；
version：输出 Docker 的版本信息；
volume：管理 Docker volume，包括查看、创建、删除等；
wait：阻塞直到一个容器终止，然后输出它的退出符。
</code></pre></div><h4 id="一张图总结-docker-的命令"><a href="#一张图总结-docker-的命令" aria-hidden="true" class="header-anchor">#</a> 一张图总结 Docker 的命令</h4> <p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g59ykwyvtjj30vl0u0wxr.jpg" alt="Docker 命令总结"></p> <p>常用命令</p> <p>查看 Docker 版本</p> <div class="language-text extra-class"><pre class="language-text"><code>docker version
</code></pre></div><p>从 Docker 文件构建 Docker 映像</p> <div class="language-text extra-class"><pre class="language-text"><code>docker build -t image-name docker-file-location
</code></pre></div><p>运行 Docker 映像</p> <div class="language-text extra-class"><pre class="language-text"><code>docker run -d image-name
</code></pre></div><p>查看可用的 Docker 映像</p> <div class="language-text extra-class"><pre class="language-text"><code>docker images
</code></pre></div><p>查看最近的运行容器</p> <div class="language-text extra-class"><pre class="language-text"><code>docker ps -l
</code></pre></div><p>查看所有正在运行的容器</p> <div class="language-text extra-class"><pre class="language-text"><code>docker ps -a
</code></pre></div><p>停止运行容器</p> <div class="language-text extra-class"><pre class="language-text"><code>docker stop container_id
</code></pre></div><p>删除一个镜像</p> <div class="language-text extra-class"><pre class="language-text"><code>docker rmi image-name
</code></pre></div><p>删除所有镜像</p> <div class="language-text extra-class"><pre class="language-text"><code>docker rmi $(docker images -q)
</code></pre></div><p>强制删除所有镜像</p> <div class="language-text extra-class"><pre class="language-text"><code>docker rmi -r $(docker images -q)
</code></pre></div><p>删除所有虚悬镜像</p> <div class="language-text extra-class"><pre class="language-text"><code>docker rmi $(docker images -q -f dangling=true)
</code></pre></div><p>删除所有容器</p> <div class="language-text extra-class"><pre class="language-text"><code>docker rm $(docker ps -a -q)
</code></pre></div><p>进入 Docker 容器</p> <div class="language-text extra-class"><pre class="language-text"><code>docker exec -it container-id /bin/bash
</code></pre></div><p>查看所有数据卷</p> <div class="language-text extra-class"><pre class="language-text"><code>docker volume ls
</code></pre></div><p>删除指定数据卷</p> <div class="language-text extra-class"><pre class="language-text"><code>docker volume rm [volume_name]
</code></pre></div><p>删除所有未关联的数据卷</p> <div class="language-text extra-class"><pre class="language-text"><code>docker volume rm $(docker volume ls -qf dangling=true)
</code></pre></div><p>从主机复制文件到容器</p> <div class="language-text extra-class"><pre class="language-text"><code>sudo docker cp host_path containerID:container_path
</code></pre></div><p>从容器复制文件到主机</p> <div class="language-text extra-class"><pre class="language-text"><code>sudo docker cp containerID:container_path host_path
</code></pre></div><h3 id="dockerfile-最佳实践"><a href="#dockerfile-最佳实践" aria-hidden="true" class="header-anchor">#</a> Dockerfile 最佳实践</h3> <h4 id="一般性的指南和建议"><a href="#一般性的指南和建议" aria-hidden="true" class="header-anchor">#</a> 一般性的指南和建议</h4> <h5 id="容器应该是短暂的"><a href="#容器应该是短暂的" aria-hidden="true" class="header-anchor">#</a> 容器应该是短暂的</h5> <p>通过 <code>Dockerfile</code> 构建的镜像所启动的容器应该尽可能短暂（生命周期短）。「短暂」意味着可以停止和销毁容器，并且创建一个新容器并部署好所需的设置和配置工作量应该是极小的。</p> <h5 id="使用-dockerignore-文件"><a href="#使用-dockerignore-文件" aria-hidden="true" class="header-anchor">#</a> 使用 <code>.dockerignore</code> 文件</h5> <p>使用 <code>Dockerfile</code> 构建镜像时最好是将 <code>Dockerfile</code> 放置在一个新建的空目录下。然后将构建镜像所需要的文件添加到该目录中。为了提高构建镜像的效率，你可以在目录下新建一个 <code>.dockerignore</code> 文件来指定要忽略的文件和目录。<code>.dockerignore</code> 文件的排除模式语法和 Git 的 <code>.gitignore</code> 文件相似。</p> <h5 id="使用多阶段构建"><a href="#使用多阶段构建" aria-hidden="true" class="header-anchor">#</a> 使用多阶段构建</h5> <p>在 <code>Docker 17.05</code> 以上版本中，你可以使用 <code>多阶段构建</code> 来减少所构建镜像的大小。</p> <h5 id="避免安装不必要的包"><a href="#避免安装不必要的包" aria-hidden="true" class="header-anchor">#</a> 避免安装不必要的包</h5> <p>为了降低复杂性、减少依赖、减小文件大小、节约构建时间，你应该避免安装任何不必要的包。例如，不要在数据库镜像中包含一个文本编辑器。</p> <h5 id="一个容器只运行一个进程"><a href="#一个容器只运行一个进程" aria-hidden="true" class="header-anchor">#</a> 一个容器只运行一个进程</h5> <p>应该保证在一个容器中只运行一个进程。将多个应用解耦到不同容器中，保证了容器的横向扩展和复用。例如 web 应用应该包含三个容器：web应用、数据库、缓存。</p> <p>如果容器互相依赖，你可以使用 <code>Docker 自定义网络</code> 来把这些容器连接起来。</p> <h5 id="镜像层数尽可能少"><a href="#镜像层数尽可能少" aria-hidden="true" class="header-anchor">#</a> 镜像层数尽可能少</h5> <p>你需要在 <code>Dockerfile</code> 可读性（也包括长期的可维护性）和减少层数之间做一个平衡。</p> <h5 id="将多行参数排序"><a href="#将多行参数排序" aria-hidden="true" class="header-anchor">#</a> 将多行参数排序</h5> <p>将多行参数按字母顺序排序（比如要安装多个包时）。这可以帮助你避免重复包含同一个包，更新包列表时也更容易。也便于 <code>PRs</code> 阅读和审查。建议在反斜杠符号 <code>\</code> 之前添加一个空格，以增加可读性。</p> <p>下面是来自 <code>buildpack-deps</code> 镜像的例子：</p> <div class="language-docker extra-class"><pre class="language-docker"><code><span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update &amp;&amp; apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y \
  bzr \
  cvs \
  git \
  mercurial \
  subversion
</code></pre></div><h5 id="构建缓存"><a href="#构建缓存" aria-hidden="true" class="header-anchor">#</a> 构建缓存</h5> <p>在镜像的构建过程中，Docker 会遍历 <code>Dockerfile</code> 文件中的指令，然后按顺序执行。在执行每条指令之前，Docker 都会在缓存中查找是否已经存在可重用的镜像，如果有就使用现存的镜像，不再重复创建。如果你不想在构建过程中使用缓存，你可以在 <code>docker build</code> 命令中使用 <code>--no-cache=true</code> 选项。</p> <p>但是，如果你想在构建的过程中使用缓存，你得明白什么时候会，什么时候不会找到匹配的镜像，遵循的基本规则如下：</p> <ul><li>从一个基础镜像开始（<code>FROM</code> 指令指定），下一条指令将和该基础镜像的所有子镜像进行匹配，检查这些子镜像被创建时使用的指令是否和被检查的指令完全一样。如果不是，则缓存失效。</li> <li>在大多数情况下，只需要简单地对比 <code>Dockerfile</code> 中的指令和子镜像。然而，有些指令需要更多的检查和解释。</li> <li>对于 <code>ADD</code> 和 <code>COPY</code> 指令，镜像中对应文件的内容也会被检查，每个文件都会计算出一个校验和。文件的最后修改时间和最后访问时间不会纳入校验。在缓存的查找过程中，会将这些校验和和已存在镜像中的文件校验和进行对比。如果文件有任何改变，比如内容和元数据，则缓存失效。</li> <li>除了 <code>ADD</code> 和 <code>COPY</code> 指令，缓存匹配过程不会查看临时容器中的文件来决定缓存是否匹配。例如，当执行完 <code>RUN apt-get -y update</code> 指令后，容器中一些文件被更新，但 Docker 不会检查这些文件。这种情况下，只有指令字符串本身被用来匹配缓存。</li></ul> <p>一旦缓存失效，所有后续的 <code>Dockerfile</code> 指令都将产生新的镜像，缓存不会被使用。</p> <h4 id="dockerfile-指令"><a href="#dockerfile-指令" aria-hidden="true" class="header-anchor">#</a> Dockerfile 指令</h4> <p>下面针对 <code>Dockerfile</code> 中各种指令的最佳编写方式给出建议。</p> <h5 id="from"><a href="#from" aria-hidden="true" class="header-anchor">#</a> FROM</h5> <p>尽可能使用当前官方仓库作为你构建镜像的基础。推荐使用 <a href="https://hub.docker.com/_/alpine/" target="_blank" rel="noopener noreferrer">Alpine<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 镜像，因为它被严格控制并保持最小尺寸（目前小于 5 MB），但它仍然是一个完整的发行版。</p> <h5 id="label"><a href="#label" aria-hidden="true" class="header-anchor">#</a> LABEL</h5> <p>你可以给镜像添加标签来帮助组织镜像、记录许可信息、辅助自动化构建等。每个标签一行，由 <code>LABEL</code>开头加上一个或多个标签对。下面的示例展示了各种不同的可能格式。<code>#</code> 开头的行是注释内容。</p> <blockquote><p>注意：如果你的字符串中包含空格，必须将字符串放入引号中或者对空格使用转义。如果字符串内容本身就包含引号，必须对引号使用转义。</p></blockquote> <div class="language-docker extra-class"><pre class="language-docker"><code><span class="token comment"># Set one or more individual labels</span>
<span class="token keyword">LABEL</span> com.example.version=<span class="token string">&quot;0.0.1-beta&quot;</span>

<span class="token keyword">LABEL</span> vendor=<span class="token string">&quot;ACME Incorporated&quot;</span>

<span class="token keyword">LABEL</span> com.example.release<span class="token punctuation">-</span>date=<span class="token string">&quot;2015-02-12&quot;</span>

<span class="token keyword">LABEL</span> com.example.version.is<span class="token punctuation">-</span>production=<span class="token string">&quot;&quot;</span>
</code></pre></div><p>一个镜像可以包含多个标签，但建议将多个标签放入到一个 <code>LABEL</code> 指令中。</p> <div class="language-docker extra-class"><pre class="language-docker"><code><span class="token comment"># Set multiple labels at once, using line-continuation characters to break long lines</span>
<span class="token keyword">LABEL</span> vendor=ACME\ Incorporated \
      com.example.is<span class="token punctuation">-</span>beta= \
      com.example.is<span class="token punctuation">-</span>production=<span class="token string">&quot;&quot;</span> \
      com.example.version=<span class="token string">&quot;0.0.1-beta&quot;</span> \
      com.example.release<span class="token punctuation">-</span>date=<span class="token string">&quot;2015-02-12&quot;</span>
</code></pre></div><p>关于标签可以接受的键值对，参考 <a href="https://docs.docker.com/engine/userguide/labels-custom-metadata/" target="_blank" rel="noopener noreferrer">Understanding object labels<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。关于查询标签信息，参考 <a href="https://docs.docker.com/engine/userguide/labels-custom-metadata/#managing-labels-on-objects" target="_blank" rel="noopener noreferrer">Managing labels on objects<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <h5 id="run"><a href="#run" aria-hidden="true" class="header-anchor">#</a> RUN</h5> <p>为了保持 <code>Dockerfile</code> 文件的可读性，可理解性，以及可维护性，建议将长的或复杂的 <code>RUN</code> 指令用反斜杠 <code>\</code> 分割成多行。</p> <h5 id="apt-get"><a href="#apt-get" aria-hidden="true" class="header-anchor">#</a> apt-get</h5> <p><code>RUN</code> 指令最常见的用法是安装包用的 <code>apt-get</code>。因为 <code>RUN apt-get</code> 指令会安装包，所以有几个问题需要注意。</p> <p>不要使用 <code>RUN apt-get upgrade</code> 或 <code>dist-upgrade</code>，因为许多基础镜像中的「必须」包不会在一个非特权容器中升级。如果基础镜像中的某个包过时了，你应该联系它的维护者。如果你确定某个特定的包，比如 <code>foo</code>，需要升级，使用 <code>apt-get install -y foo</code> 就行，该指令会自动升级 <code>foo</code> 包。</p> <p>永远将 <code>RUN apt-get update</code> 和 <code>apt-get install</code> 组合成一条 <code>RUN</code> 声明，例如：</p> <div class="language-docker extra-class"><pre class="language-docker"><code><span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update &amp;&amp; apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y \
        package<span class="token punctuation">-</span>bar \
        package<span class="token punctuation">-</span>baz \
        package<span class="token punctuation">-</span>foo
</code></pre></div><p>将 <code>apt-get update</code> 放在一条单独的 <code>RUN</code> 声明中会导致缓存问题以及后续的 <code>apt-get install</code> 失败。比如，假设你有一个 <code>Dockerfile</code> 文件：</p> <div class="language-docker extra-class"><pre class="language-docker"><code><span class="token keyword">FROM</span> ubuntu<span class="token punctuation">:</span>14.04

<span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update

<span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y curl
</code></pre></div><p>构建镜像后，所有的层都在 Docker 的缓存中。假设你后来又修改了其中的 <code>apt-get install</code> 添加了一个包：</p> <div class="language-docker extra-class"><pre class="language-docker"><code><span class="token keyword">FROM</span> ubuntu<span class="token punctuation">:</span>14.04

<span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update

<span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y curl nginx
</code></pre></div><p>Docker 发现修改后的 <code>RUN apt-get update</code> 指令和之前的完全一样。所以，<code>apt-get update</code> 不会执行，而是使用之前的缓存镜像。因为 <code>apt-get update</code> 没有运行，后面的 <code>apt-get install</code> 可能安装的是过时的 <code>curl</code> 和 <code>nginx</code> 版本。</p> <p>使用 <code>RUN apt-get update &amp;&amp; apt-get install -y</code> 可以确保你的 Dockerfiles 每次安装的都是包的最新的版本，而且这个过程不需要进一步的编码或额外干预。这项技术叫作 <code>cache busting</code>。你也可以显示指定一个包的版本号来达到 <code>cache-busting</code>，这就是所谓的固定版本，例如：</p> <div class="language-docker extra-class"><pre class="language-docker"><code><span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update &amp;&amp; apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y \
    package<span class="token punctuation">-</span>bar \
    package<span class="token punctuation">-</span>baz \
    package<span class="token punctuation">-</span>foo=1.3.*
</code></pre></div><p>固定版本会迫使构建过程检索特定的版本，而不管缓存中有什么。这项技术也可以减少因所需包中未预料到的变化而导致的失败。</p> <p>下面是一个 <code>RUN</code> 指令的示例模板，展示了所有关于 <code>apt-get</code> 的建议。</p> <div class="language-docker extra-class"><pre class="language-docker"><code><span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update &amp;&amp; apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y \
    aufs<span class="token punctuation">-</span>tools \
    automake \
    build<span class="token punctuation">-</span>essential \
    curl \
    dpkg<span class="token punctuation">-</span>sig \
    libcap<span class="token punctuation">-</span>dev \
    libsqlite3<span class="token punctuation">-</span>dev \
    mercurial \
    reprepro \
    ruby1.9.1 \
    ruby1.9.1<span class="token punctuation">-</span>dev \
    s3cmd=1.1.* \
 &amp;&amp; rm <span class="token punctuation">-</span>rf /var/lib/apt/lists/*
</code></pre></div><p>其中 <code>s3cmd</code> 指令指定了一个版本号 <code>1.1.*</code>。如果之前的镜像使用的是更旧的版本，指定新的版本会导致 <code>apt-get udpate</code> 缓存失效并确保安装的是新版本。</p> <p>另外，清理掉 apt 缓存 <code>var/lib/apt/lists</code> 可以减小镜像大小。因为 <code>RUN</code> 指令的开头为 <code>apt-get udpate</code>，包缓存总是会在 <code>apt-get install</code> 之前刷新。</p> <blockquote><p>注意：官方的 Debian 和 Ubuntu 镜像会自动运行 apt-get clean，所以不需要显式的调用 apt-get clean。</p></blockquote> <h5 id="cmd"><a href="#cmd" aria-hidden="true" class="header-anchor">#</a> CMD</h5> <p><code>CMD</code> 指令用于执行目标镜像中包含的软件，可以包含参数。<code>CMD</code> 大多数情况下都应该以 <code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;...]</code> 的形式使用。因此，如果创建镜像的目的是为了部署某个服务(比如 <code>Apache</code>)，你可能会执行类似于 <code>CMD [&quot;apache2&quot;, &quot;-DFOREGROUND&quot;]</code> 形式的命令。我们建议任何服务镜像都使用这种形式的命令。</p> <p>多数情况下，<code>CMD</code> 都需要一个交互式的 <code>shell</code> (bash, Python, perl 等)，例如 <code>CMD [&quot;perl&quot;, &quot;-de0&quot;]</code>，或者 <code>CMD [&quot;PHP&quot;, &quot;-a&quot;]</code>。使用这种形式意味着，当你执行类似 <code>docker run -it python</code>时，你会进入一个准备好的 <code>shell</code> 中。<code>CMD</code> 应该在极少的情况下才能以 <code>CMD [&quot;param&quot;, &quot;param&quot;]</code>的形式与 <code>ENTRYPOINT</code> 协同使用，除非你和你的镜像使用者都对 <code>ENTRYPOINT</code> 的工作方式十分熟悉。</p> <h5 id="expose"><a href="#expose" aria-hidden="true" class="header-anchor">#</a> EXPOSE</h5> <p><code>EXPOSE</code> 指令用于指定容器将要监听的端口。因此，你应该为你的应用程序使用常见的端口。例如，提供 <code>Apache</code> web 服务的镜像应该使用 <code>EXPOSE 80</code>，而提供 <code>MongoDB</code> 服务的镜像使用 <code>EXPOSE 27017</code>。</p> <p>对于外部访问，用户可以在执行 <code>docker run</code> 时使用一个标志来指示如何将指定的端口映射到所选择的端口。</p> <h5 id="env"><a href="#env" aria-hidden="true" class="header-anchor">#</a> ENV</h5> <p>为了方便新程序运行，你可以使用 <code>ENV</code> 来为容器中安装的程序更新 <code>PATH</code> 环境变量。例如使用 <code>ENV PATH /usr/local/nginx/bin:$PATH</code> 来确保 <code>CMD [&quot;nginx&quot;]</code> 能正确运行。</p> <p><code>ENV</code> 指令也可用于为你想要容器化的服务提供必要的环境变量，比如 Postgres 需要的 <code>PGDATA</code>。</p> <p>最后，<code>ENV</code> 也能用于设置常见的版本号，比如下面的示例：</p> <div class="language-docker extra-class"><pre class="language-docker"><code><span class="token keyword">ENV</span> PG_MAJOR 9.3

<span class="token keyword">ENV</span> PG_VERSION 9.3.4

<span class="token keyword">RUN</span> curl <span class="token punctuation">-</span>SL http<span class="token punctuation">:</span>//example.com/postgres<span class="token punctuation">-</span>$PG_VERSION.tar.xz <span class="token punctuation">|</span> tar <span class="token punctuation">-</span>xJC /usr/src/postgress &amp;&amp; …

<span class="token keyword">ENV</span> PATH /usr/local/postgres<span class="token punctuation">-</span>$PG_MAJOR/bin<span class="token punctuation">:</span>$PATH
</code></pre></div><p>类似于程序中的常量，这种方法可以让你只需改变 <code>ENV</code> 指令来自动的改变容器中的软件版本。</p> <h5 id="add-和-copy"><a href="#add-和-copy" aria-hidden="true" class="header-anchor">#</a> ADD 和 COPY</h5> <p>虽然 <code>ADD</code> 和 <code>COPY</code> 功能类似，但一般优先使用 <code>COPY</code>。因为它比 <code>ADD</code> 更透明。<code>COPY</code> 只支持简单将本地文件拷贝到容器中，而 <code>ADD</code> 有一些并不明显的功能（比如本地 tar 提取和远程 URL 支持）。因此，<code>ADD</code> 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 <code>ADD rootfs.tar.xz</code>。</p> <p>如果你的 <code>Dockerfile</code> 有多个步骤需要使用上下文中不同的文件。单独 <code>COPY</code> 每个文件，而不是一次性的 <code>COPY</code> 所有文件，这将保证每个步骤的构建缓存只在特定的文件变化时失效。例如：</p> <div class="language-docker extra-class"><pre class="language-docker"><code><span class="token keyword">COPY</span> requirements.txt /tmp/

<span class="token keyword">RUN</span> pip install <span class="token punctuation">-</span><span class="token punctuation">-</span>requirement /tmp/requirements.txt

<span class="token keyword">COPY</span> . /tmp/
</code></pre></div><p>如果将 <code>COPY . /tmp/</code> 放置在 <code>RUN</code> 指令之前，只要 <code>.</code> 目录中任何一个文件变化，都会导致后续指令的缓存失效。</p> <p>为了让镜像尽量小，最好不要使用 <code>ADD</code> 指令从远程 URL 获取包，而是使用 <code>curl</code> 和 <code>wget</code>。这样你可以在文件提取完之后删掉不再需要的文件来避免在镜像中额外添加一层。比如尽量避免下面的用法：</p> <div class="language-docker extra-class"><pre class="language-docker"><code><span class="token keyword">ADD</span> http<span class="token punctuation">:</span>//example.com/big.tar.xz /usr/src/things/

<span class="token keyword">RUN</span> tar <span class="token punctuation">-</span>xJf /usr/src/things/big.tar.xz <span class="token punctuation">-</span>C /usr/src/things

<span class="token keyword">RUN</span> make <span class="token punctuation">-</span>C /usr/src/things all
</code></pre></div><p>而是应该使用下面这种方法：</p> <div class="language-docker extra-class"><pre class="language-docker"><code><span class="token keyword">RUN</span> mkdir <span class="token punctuation">-</span>p /usr/src/things \
    &amp;&amp; curl <span class="token punctuation">-</span>SL http<span class="token punctuation">:</span>//example.com/big.tar.xz \
    <span class="token punctuation">|</span> tar <span class="token punctuation">-</span>xJC /usr/src/things \
    &amp;&amp; make <span class="token punctuation">-</span>C /usr/src/things all
</code></pre></div><p>上面使用的管道操作，所以没有中间文件需要删除。</p> <p>对于其他不需要 <code>ADD</code> 的自动提取功能的文件或目录，你应该使用 <code>COPY</code>。</p> <h5 id="entrypoint"><a href="#entrypoint" aria-hidden="true" class="header-anchor">#</a> ENTRYPOINT</h5> <p><code>ENTRYPOINT</code> 的最佳用处是设置镜像的主命令，允许将镜像当成命令本身来运行（用 <code>CMD</code> 提供默认选项）。</p> <p>例如，下面的示例镜像提供了命令行工具 <code>s3cmd</code>:</p> <div class="language-docker extra-class"><pre class="language-docker"><code><span class="token keyword">ENTRYPOINT</span> <span class="token punctuation">[</span><span class="token string">&quot;s3cmd&quot;</span><span class="token punctuation">]</span>

<span class="token keyword">CMD</span> <span class="token punctuation">[</span><span class="token string">&quot;--help&quot;</span><span class="token punctuation">]</span>
</code></pre></div><p>现在直接运行该镜像创建的容器会显示命令帮助：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ docker run s3cmd
</code></pre></div><p>或者提供正确的参数来执行某个命令：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ docker run s3cmd <span class="token function">ls</span> s3://mybucket
</code></pre></div><p>这样镜像名可以当成命令行的参考。</p> <p><code>ENTRYPOINT</code> 指令也可以结合一个辅助脚本使用，和前面命令行风格类似，即使启动工具需要不止一个步骤。</p> <p>例如，<code>Postgres</code> 官方镜像使用下面的脚本作为 <code>ENTRYPOINT</code>：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token shebang important">#!/bin/bash</span>
<span class="token keyword">set</span> -e

<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">&quot;<span class="token variable">$1</span>&quot;</span> <span class="token operator">=</span> <span class="token string">'postgres'</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token function">chown</span> -R postgres <span class="token string">&quot;<span class="token variable">$PGDATA</span>&quot;</span>

    <span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token string">&quot;<span class="token variable"><span class="token variable">$(</span><span class="token function">ls</span> -A <span class="token string">&quot;<span class="token variable">$PGDATA</span>&quot;</span><span class="token variable">)</span></span>&quot;</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
        gosu postgres initdb
    <span class="token keyword">fi</span>

    <span class="token function">exec</span> gosu postgres <span class="token string">&quot;<span class="token variable">$@</span>&quot;</span>
<span class="token keyword">fi</span>

<span class="token function">exec</span> <span class="token string">&quot;<span class="token variable">$@</span>&quot;</span>
</code></pre></div><blockquote><p>注意：该脚本使用了 Bash 的内置命令 exec，所以最后运行的进程就是容器的 PID 为 1 的进程。这样，进程就可以接收到任何发送给容器的 Unix 信号了。</p></blockquote> <p>该辅助脚本被拷贝到容器，并在容器启动时通过 <code>ENTRYPOINT</code> 执行：</p> <div class="language-docker extra-class"><pre class="language-docker"><code><span class="token keyword">COPY</span> ./docker<span class="token punctuation">-</span>entrypoint.sh /

<span class="token keyword">ENTRYPOINT</span> <span class="token punctuation">[</span><span class="token string">&quot;/docker-entrypoint.sh&quot;</span><span class="token punctuation">]</span>
</code></pre></div><p>该脚本可以让用户用几种不同的方式和 <code>Postgres</code> 交互。</p> <p>你可以很简单地启动 <code>Postgres</code>：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ docker run postgres
</code></pre></div><p>也可以执行 <code>Postgres</code> 并传递参数：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ docker run postgres postgres --help
</code></pre></div><p>最后，你还可以启动另外一个完全不同的工具，比如 <code>Bash</code>：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ docker run --rm -it postgres <span class="token function">bash</span>
</code></pre></div><h5 id="volume"><a href="#volume" aria-hidden="true" class="header-anchor">#</a> VOLUME</h5> <p><code>VOLUME</code> 指令用于暴露任何数据库存储文件，配置文件，或容器创建的文件和目录。强烈建议使用 <code>VOLUME</code> 来管理镜像中的可变部分和用户可以改变的部分。</p> <h5 id="user"><a href="#user" aria-hidden="true" class="header-anchor">#</a> USER</h5> <p>如果某个服务不需要特权执行，建议使用 <code>USER</code> 指令切换到非 root 用户。先在 <code>Dockerfile</code> 中使用类似 <code>RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</code> 的指令创建用户和用户组。</p> <blockquote><p>注意：在镜像中，用户和用户组每次被分配的 UID/GID 都是不确定的，下次重新构建镜像时被分配到的 UID/GID 可能会不一样。如果要依赖确定的 UID/GID，你应该显示的指定一个 UID/GID。</p></blockquote> <p>你应该避免使用 <code>sudo</code>，因为它不可预期的 TTY 和信号转发行为可能造成的问题比它能解决的问题还多。如果你真的需要和 <code>sudo</code> 类似的功能（例如，以 root 权限初始化某个守护进程，以非 root 权限执行它），你可以使用 <a href="https://github.com/tianon/gosu" target="_blank" rel="noopener noreferrer">gosu<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>最后，为了减少层数和复杂度，避免频繁地使用 <code>USER</code> 来回切换用户。</p> <h5 id="workdir"><a href="#workdir" aria-hidden="true" class="header-anchor">#</a> WORKDIR</h5> <p>为了清晰性和可靠性，你应该总是在 <code>WORKDIR</code> 中使用绝对路径。另外，你应该使用 <code>WORKDIR</code> 来替代类似于 <code>RUN cd ... &amp;&amp; do-something</code> 的指令，后者难以阅读、排错和维护。</p> <h5 id="官方仓库示例"><a href="#官方仓库示例" aria-hidden="true" class="header-anchor">#</a> 官方仓库示例</h5> <p>这些官方仓库的 Dockerfile 都是参考典范：https://github.com/docker-library/docs</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/wiki/docker/docker-8-安装.html" class="prev">
          Docker安装
        </a></span> <span class="next"><a href="/wiki/docker/docker-compose.html">
          Docker Compose
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/wiki/assets/js/app.dd178f5a.js" defer></script><script src="/wiki/assets/js/2.9f273a62.js" defer></script><script src="/wiki/assets/js/16.6346731c.js" defer></script>
  </body>
</html>
